import { IDataQuest } from './type';

export const dataQuestion: IDataQuest[] = [
  {
    name: 'Структуры данных',
    questions: [
      {
        question: 'Названия  типов данных',
        response: 'Number,string,boolean,object,null,undefined,Symbol,BigInt',
        active: false,
      },
      {
        question: 'Скалярные типы и строки',
        response:
          'Они же простые типы данных.' +
          ' Их ключевой особенностью является то, что при присвоении другим переменным,\n' +
          'значение копируется\n' +
          '\n' +
          'К скалярным типам данных относятся:string,number,boolean',
        active: false,
      },
      {
        question: 'Массивы',
        response:
          'Массив — это структура, в которой можно хранить' +
          ' коллекции элементов — чисел, строк, других массивов и так далее.' +
          ' Элементы нумеруются и хранятся в том порядке, в котором их поместили в массив.',
        active: false,
      },
      {
        question: 'Списки, словари (хэш-таблицы), множества',
        response:
          '1.В javascript в качестве списка выступает обычный массив.' +
          '2.Хэш-таблица это структура данных, которая позволяет' +
          ' хранить пары ключ-значение и выполнять три операции над ними: ' +
          'добавление новой пары, поиск значение по ключу и удаление пары по ключу.' +
          '3.Множества:Объект Set позволяет хранить уникальные значения любого типа, будь то примитивы или ссылки на объекты.',
        active: false,
      },
      {
        question: '  Кортежи',
        response:
          'Кортежи (tuples) в TypeScript представляют собой особый вид массивов,' +
          ' где порядок элементов фиксирован, и каждый элемент имеет заранее определенный тип.' +
          ' Это позволяет точно описывать структуры данных с известным количеством и типами элементов.',
        active: false,
      },
      {
        question: '  Изменяемость типов данных',
        response:
          'В JavaScript у нас есть примитивные типы и ссылочные типы.' +
          ' Примитивные типы включают числа, строки, boolean, null, undefined.' +
          ' И ссылочные типы включают объекты, массивы и функции. Разница между этими типами' +
          ' заключается в том, что примитивные типы неизменяемы (immutable), а ссылочные типы изменяемы (mutable)',
        active: false,
      },
      {
        question: '  Сложности операций вставки и поиска',
        response: 'Number,string,boolean,object,null,undefined,Symbol,BigInt',
        active: false,
      },
      {
        question:
          'Внутреннее устройство стандартных контейнеров (список, словарь)',
        response: 'Number,string,boolean,object,null,undefined,Symbol,BigInt',
        active: false,
      },
      {
        question: 'Графы',
        response: 'Number,string,boolean,object,null,undefined,Symbol,BigInt',
        active: false,
      },
      {
        question: '    Деревья',
        response: 'Number,string,boolean,object,null,undefined,Symbol,BigInt',
        active: false,
      },
      {
        question: ' Самобалансирующиеся деревья(АВЛ, красно-черное)',
        response: 'Number,string,boolean,object,null,undefined,Symbol,BigInt',
        active: false,
      },
      {
        question: 'Понимание вычислительной сложности поиска и вставки данных',
        response: 'Number,string,boolean,object,null,undefined,Symbol,BigInt',
        active: false,
      },
      {
        question: 'Совместимость структур данных и многопоточная обработка',
        response: 'Number,string,boolean,object,null,undefined,Symbol,BigInt',
        active: false,
      },
    ],
    active: false,
  },
  {
    name: 'JavaScript',
    questions: [
      {
        question: 'JavaScript',
        response:
          'Это язык программирования с ' +
          'динамической типизацией, однопоточный',
        active: false,
      },
      {
        question: 'Типы данных',
        response:
          '1.Строка\n' +
          '2.Число\n' +
          '3.BigInt(большое число)\n' +
          '4.Boolean(логическое)\n' +
          '5.Null\n' +
          '6.Undefined(не определено)\n' +
          '7.Symbol(символ)\n' +
          '8.Object(обьект)',
        active: false,
      },
      {
        question: 'Отличие null от undefined ',
        response: 'отсутствие значение, null - намеренное присвоение',
        active: false,
      },
      {
        question: 'Prototype ',
        response: 'реализация наследования в JS',
        active: false,
      },
      {
        question: 'this,call,apply,bind',
        response:
          'this - контекст, ссылка на обьект\n' +
          'call, apply  - методы функции (this, arguments) или (this, [...arguments]) сразу вызываются\n' +
          'bind - можно забиндить и вызвать после',
        active: false,
      },
      {
        question:
          'const, let, arrow fn, class, шаблонные строки, spread, rest, итератор, генератор ',
        response:
          'const и let - ключевые слова let - можно обьявить,присвоить значение позже, также можно переприсвоить\n' +
          'const - начальное значение нужно, переприсвоить не получится, только обьект или массив\n' +
          'const && let - блочной области видимости\n' +
          'arrow fn(стрелочная функция ) -  () => {} нет своего контекста ,запоминает где была обьявлена, нет методов функций, аргументс,\n' +
          'более короткая запись, анонимна\n' +
          'spread - не глубокое копирование [...spread] || {...spread}\n' +
          'rest  - когда мы не знаем сколько у нас аргументов - используем rest ( function(a, ...rest){} )' +
          '\n' +
          'Генератор - это функция, которая можно запустить приостановить и возобновить на разных стадиях выполнения. Первый вызов функции вызовет итератор,' +
          ' у этого обьекта есть next для возобновления функции. При каждом вызове функция возобновляет свою' +
          ' работу пока не наткнется на yield и опять станет на паузу ',
        active: false,
      },
      {
        question:
          'Два подхода к обработке событий в DOM(onevent,addEventListener).Пользовательские события.Стадии прохода события',
        response:
          'События в JS - погружение и всплытие\n' +
          '1.onEvent - можно на элемент накинуть событие onClick\n' +
          '2.addEventListener - вешаем на элемент, далее пока не отпишемся через removеEventListener\n' +
          "element.addEventListener('событие (click)', функция которая наблюдает за событием (() => {}))\n" +
          '\n' +
          'Пользовательские события - \n' +
          '\n' +
          'new Event(”клик”, [опции]) опции - bubbles - true/false всплытие \n' +
          '\n' +
          'eanaeleble true/false \n' +
          '\n' +
          'composed-соьытие будет вставать за пределы shadow DOM метод dispatchEvent запускает событ[ие на элементе](http://8.web/)\n' +
          '\n' +
          'Стадии события\n' +
          '\n' +
          ' 1.погружение только addEventListener\n' +
          '\n' +
          '2.целевая фаза-все\n' +
          '\n' +
          '3.фаза всплытие - с add по capture \n',
        active: false,
      },
      {
        question: 'Web Worker ',
        response:
          'aссинхронная система позволяет выполнять тяжелые в вычислительном плане и длительные задачи\n' +
          'без блокировки потока пользовательского интерфейса. При их использовании вычисления идут параллельно.\n' +
          'Это своего рода многопоточность. Web Workers - не являются частью JS, они представляют собой возможность браузера,\n' +
          'к которой можно получить доступ посредством JS - new Worker() - они должны быть в отдельном файле ,воркеры\n' +
          'выполняются в изолированных потоках  в браузере\n' +
          'Для запуска - worker.postMessage() для отправки в основной поток   (DOM && Window -  для них недоступны)\n' +
          '\n' +
          'onMessage слушатель в основном потоке для получения сообщений от воркера terminate() завершает работу воркера \n' +
          '\n',
        active: false,
      },
      {
        question: 'Новые типы данных',
        response:
          '.new Map() - коллекция ключ/значение  - ключ любого типа\n' +
          ".set(ключ, значение) - новое записать .get('ключ') - найти  clear() - очистить  .size() - размер  .delete('ключ') -  удалить\n" +
          'new Set() - коллекция уникальных значений, без ключей\n' +
          'WeakMap() - ключи обьекты, если мы запишем значение null - то будет удален автоматом сборщиком мусора\n' +
          'нет методов перебора keys(), values(), entries(), только get, set, delete\n' +
          'WeakSet() - коллекция уникальных обьектов',
        active: false,
      },
      {
        question: 'Манипуляции с DOM',
        response:
          'Dom - поиск через getElementById - по id, querySelector - по селектору, querySelectorAll\n' +
          'getElementByClassName - по имени класса  getElementByTagName - по тегу\n' +
          'создание элемента Dom - document.createElement(tag).className(класс).innerHtml(текст)\n' +
          'чтобы его вставить body.append - добавляем в конец, prepend - в начало, before -  до, after- после\n' +
          '\n' +
          'Изменение replaseWith, cloneNode\n' +
          'удаление через element.remove()\n' +
          'добавление классов - element.classList.add/remove/sidebar.component.ts\n',
        active: false,
      },
      {
        question: 'Какие способы реализации ООП есть в JS(ES6) ',
        response:
          'ООП в JS - наследование prototype,  у классов через new\n' +
          'Инкапсуляция  - через #приватные поля и методы в классе',
        active: false,
      },
      {
        question: 'Как устроена асинхронность в js',
        response:
          '\n' +
          '12.EventLoop-соьытийный цикл суть проста ожидает задачи, исполняет их потом снова исполняет задачи \n' +
          '\n' +
          'Бщий алгоритм - пока есть задачи, выполняет с самой старой \n' +
          '\n' +
          'Все задачи можно поделить на 3 синхронный код, микрозадачи, макрозадачи \n',
        active: false,
      },
      {
        question: 'Функциональные конструкции map,reduce,filter',
        response:
          ' Метод reduce() применяет функцию reducer к каждому элементу массива' +
          ' (слева-направо), возвращая одно результирующее значение.' +
          'Метод filter() создаёт новый массив со всеми элементами, ' +
          'прошедшими проверку, задаваемую в передаваемой функции.' +
          ' Метод map вызывает переданную функцию callback один раз ' +
          'для каждого элемента, в порядке их появления и конструирует новый массив из результатов функции',
        active: false,
      },
      {
        question: 'Работа с ассинхронностью',
        response:
          '' +
          'Promise - специальный обьект  в JS, для работы с ассинхронностью\n' +
          'у него есть состояние - pending(в процессе ), reject(ошибка), fullfield(успешно)\n' +
          'методы then(), catch(), finally()  чейнинг(цепочка вызовов) - then().then()\n' +
          'new Promise((res, rej) => {})  два колбека res, rej  он срабатывает один раз и неизменяем либо resolve или reject\n' +
          '.all([]) - ждет пока все пройдут, если один с ошибкой выдаст ошибку\n' +
          '.race() - выдаст результат первого промиса\n' +
          '.allSetled() - покажет результат всех и их статусы',
        active: false,
      },
      {
        question: 'Async/await',
        response:
          'async/await - специальный синтаксис над промисом\n' +
          'async function() {return } - зарезолвленный промис\n' +
          'await - аналог .then() - у промиса\n' +
          'обработчик ошибок try/catch внутри',
        active: false,
      },
      {
        question:
          'Способы оптимизации работы с Dom.  Список самых дорогих операций',
        response:
          'добавление в Dom после рендеринга  - нужно использовать  documentFragment\n' +
          'слишком частые события window.resize - использовать debounce()\n' +
          '\n' +
          'Узлы дом необходимо создавать только при их необходимости а как только в них отпала надобность, удаляем\n' +
          '\n' +
          'Подгружать узлы по мере необходимости пользователю\n' +
          '\n' +
          'Сокращение объёма  сложных вычислительных стилей',
        active: false,
      },
      {
        question: 'Modules, Proxy, Reflect,',
        response:
          'Модули - файл с use strict режимом, у них есть импорт и экспорт\n' +
          'Proxy - спец. обьект для перехвата и переопределения основных операций\n' +
          'new Proxy(obj, handler) reflect -часто используют вместе с proxy внутри надстройка',
        active: false,
      },
      {
        question: 'localStorage, sessionStorage, cookie',
        response:
          'localStorage - хранит данные без срока годности session- во время жизни вкладки, если дублировать вкладку создаст для каждой\n' +
          "setItem('key', содержимое) - закинуть, getItem('ключ') - забрать\n" +
          'coocki - хранит данные, которые должны быть отправлены обратно на сервер последующими запросами\n' +
          'Если установить флаг httpOnly -true - для файла то предотвратит доступ на стороне клиента, добавляется  через document.coockie',
        active: false,
      },
      {
        question: 'Сборщик мусора  ',
        response:
          'Сборщик мусора периодически находит ' +
          'объекты, которые больше не доступны в контексте ' +
          'выполнения программы, и автоматически освобождает связанную с ними память',
        active: false,
      },
      {
        question: 'repaint, reflow',
        response:
          'repain -перерисовка элементов стили визуальный слой, ' +
          'без изменения размеров\n' +
          'reflow - перерисовка макета страницы',
        active: false,
      },
      {
        question: 'Web Assembly',
        response:
          'язык программирования низкого уровня, призванный внести программируемость ' +
          'туда, где нужны кроссплатформенность,' +
          ' эффективность и безопасность, в первую очередь на клиентскую сторону Всемирной паутины.',
        active: false,
      },
    ],
    active: false,
  },
];
