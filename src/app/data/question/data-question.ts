import { IDataQuestion } from './type';
//Данные вопросов
export const dataQuestion: IDataQuestion[] = [
  {
    name: 'Обьектно-оринетированное программирование',
    questions: [
      {
        question: 'Что такое ООП?',
        response:
          'Методология программирования, основанная на представлении программы ' +
          'в виде совокупности взаимодействующих обьектов\n' +
          'каждый из который является экземпляром определенного класса,  а классы образуют иерархию наследования',
        active: false,
      },
      {
        question: 'Принципы ООП?',
        response:
          '  Инкапсуляция (сокрытие ) - принцип ооп который гласит что мы можем изолировать доступ к внутренним членам объекта\n' +
          '\n' +
          '    у нас в классе есть приватный поля, которые мы не можем изменить извне\n' +
          '\n' +
          '    Наследование - принцип ооп, он предоставляет доступ к внутренним членам, методам путем наследования  (extends)\n' +
          '\n' +
          '  Полиморфизм - способность обьекта использовать методы производного класса который не существует на момент создания базового\n' +
          '  Условно мы наследовались от базового и переопределили его метод',
        active: false,
      },
      {
        question: 'Расшифруй аббревиатуру SOLID',
        response:
          'S(single responsibility) - принцип единственной ответственности - для класса должно быть одно назначение.\n' +
          '  // O(open/close) - (принцип открытости/закрытости) - открыт для расширения, закрыт для модификации\n' +
          '  // L(liskov) - принцип подстановки Лисков - поведение наследующих классов не должно противоречить поведению, заданному базовым классом\n' +
          '  // I(separation interface) - разделение интерфейсов - много интерфейсов специально преджназначенных для клиентов лучше чем один интерфейс\n' +
          '  // общего назначения  - тогда некототорые поля нужно делать опциональными чтобы подходили для многих\n' +
          '  // D(dependency invercion) -\n' +
          '  //\n' +
          '  //   Модули верхних уровней не должны зависеть от модулей нижних, зависимость от абстракция. Абстракция не должна зависеть от деталей, детали должны зависеть от абстракций',
        active: false,
      },
      {
        question: 'Что такое абстрактный класс',
        response:
          'Базовый класс, который нужен не для создания экземпляров,а как образец или шаблон.Может содержать абстрактные методы и свойства',
        active: false,
      },
      {
        question: 'Отличие абстрактного класса и интерфейса',
        response:
          ' Интерфейс описывает шаблон описание поведения, у него нет состояния\n' +
          '            абстрактный класс имеет какое то состояние, у него могут быть приватные методы и свойства',
        active: false,
      },
      {
        question: 'Статические методы и свойства',
        response:
          'Кроме обычных полей и методов класс может иметь статические. Статические поля и методы относятся не к' +
          ' отдельным объектам, а в целом к классу. И для обащения к статическим полям и методам применяется имя класса.',
        active: false,
      },
      {
        question: 'Плюсы и минусы наследования',
        response:
          '  - ключевое слово (extends)\n' +
          '  - убираем дублирование\n' +
          '  - Расширяемость\n' +
          '  - Абстракция внесение общего в один класс\n' +
          '  - выстраиваемая иерархия наследования\n' +
          '  - полиморфизм\n' +
          '  -если что-то поменяется в родительском поменяется и в дочерних\n' +
          '  -ромбовидное наследование',
        active: false,
      },
      {
        question:
          'Как понимается  композиция в объектно-ориентированном программировании?',
        response:
          'Композиция — это процесс создания сложных функций или объектов путем комбинирования' +
          ' и объединения более простых функций или объектов. То есть, вместо того чтобы создавать' +
          ' новую функцию или объект с нуля, мы можем использовать уже существующие функции или объекты' +
          ' и комбинировать их в более сложные структуры.',
        active: false,
      },
      {
        question:
          'Как понимается  делегирование в объектно-ориентированном программировании?',
        response:
          'Делегирование - Агрегация(Делегирование) подразумевает связь, в которой потомок может' +
          'существовать независимо от родителя мы прописываем какой нам нужен интерфейс от этого обьекта и забираем точечно',
        active: false,
      },
    ],
    active: false,
  },
  {
    name: 'Angular',
    questions: [
      {
        question: 'Что такое Angular?',
        response:
          'Angular – это фреймворк для создания клиентских веб-приложений' +
          ', разработанный компанией Google. Он позволяет создавать динамические веб-приложения, обеспечивая ' +
          'высокую производительность и гибкость кода.',
        active: false,
      },
      {
        question: 'Виды директив в Angular',
        response:
          'Angular директивы используются для изменения внешнего вида или поведения DOM-элемента.Выделяют три типа директив:\n' +
          'С собственным шаблоном, или по-другому компоненты (компоненты являются директивами);\n' +
          'Структурные, которые изменяют структуру DOM-дерева;\n' +
          'Атрибуты, которые изменяют внешний вид или поведение по умолчанию элемента DOM-дерева.',
        active: false,
      },
      {
        question: 'Data binding (привязка к данным)',
        response:
          'В шаблоне Angular привязка создает живую связь между частью пользовательского интерфейса, созданной из шаблона (элемент DOM, директива или компонент), и моделью (экземпляр компонента, к которому принадлежит шаблон). Эту связь можно использовать для синхронизации представления с моделью, для уведомления модели о том, что в представлении происходит событие или действие пользователя, или для того и другого. Алгоритм обнаружения изменений Angular отвечает за поддержание синхронизации представления и модели.\n' +
          '\n' +
          'Примеры связывания включают в себя:\n' +
          '\n' +
          'интерполяции текста {{value}},\n' +
          'свойство связывание [value]\n' +
          'привязка событий (click)\n' +
          'двусторонняя привязка [{ngModel}]\n' +
          'Привязки всегда состоят из двух частей: цели , которая будет получать связанное значение, и шаблонного выражения , которое создает значение из модели.',
        active: false,
      },
      {
        question: 'Что такое @Pipe',
        response:
          ' функция которая преобразует разметку через | если есть доп свойства то через :\n' +
          '  есть pure и impure pipe - у него есть метод трансформ',
        active: false,
      },
      {
        question: 'Хуки жизненного цикла',
        response:
          ' 1.OnChanges - вызывается каждый раз, при установлении свойства\n' +
          '  2.OnInit - один раз при инициализации компонента\n' +
          '  3.DoCheck - при каждом проверки  изменении свойств\n' +
          '  4.AfterContentInit - после проецирования контента в компоненте, вставка в html\n' +
          '  5.AfterContentChecket - после проверки изменения проецируемого контент в шаблон\n' +
          '  6.AfterViewInit - после инициализации представления родительского или дочернего компонента\n' +
          '  7.AfterViewChecket - после проверки представления родительского или дочернего  компонента\n' +
          '  8.OnDestroy - один раз после уничтожения компонента',
        active: false,
      },
      {
        question: 'Модуль и его свойства',
        response:
          '6.Модуль - класс с декоратором @ngModule - обьединяющая структура  для компонент, сервисов, пайпов, директив\n' +
          '        свойства -\n' +
          '        1.Импорт - массив модулей нужных для нашего\n' +
          '        2.Экспорт - массив компонент, пайпов, директив для экспорта\n' +
          '        3.declaration - массив компонент, пайп, директив\n' +
          '        4.providers - сервисы',
        active: false,
      },
      {
        question: 'Lazy loading',
        response:
          'Асинхронная маршрутизация, позволяет не сразу создавать модуль, а когда пользователь переходит по определённому роутингу ',
        active: false,
      },
    ],
    active: false,
  },
  //8.Observable - поток, отличие от промиса можно несколько раз подписаться к стриму, отписаться,
  // а промис отработает один раз и все
  // 8.Subject - разновидность обьектов Observable - стрим где не нужно начальное значение и возвращает последнее
  // BehaviorSubject - есть начальное и возвращает последнее
  // ReplaceSubject - покажет все значения которые мы ему записывали
  // Service - @Injectable - в провайдерсы инжектится в компоненты, модули и идет от родителя к дочернему
  // @SkipSelf - локальный инжектор будет исключен и будет идти вверх до родительского
  // @Self - ищет только у себя
  // @Options - если отсутствует инжектор запишется null,
  // @Host - ищет у себя, если нет то выше
  // { provider: UserService, useClass: UserService }
  // можно переопределить useClass - подмена сервиса
  // свойства useClass - каждый раз будет создаваться новый экземпляр класса
  // useExisting - использоваться один и тоже экземпляр
  // useValue - обьект который укажем
  // useFactory - фабрика, функция, где можем логику прописать под условия
  {
    name: 'rxjs',
    questions: [
      {
        question: 'Observable и его отличие от промиса ',
        response:
          'Объекты RxJS Observable создаются либо с использованием операторов создания (of, from, fromEvent), либо через new Observable.' +
          'Каждый Observable может отправлять своим "потребителям" уведомления вызовом одного из трех методов:\n' +
          '\n' +
          'next() — отправка данных, количество вызовов не ограничено;\n' +
          'error() — генерация ошибки, параметром указываются данные любого формата (строка, объект, исключение) о причине ее возникновения;\n' +
          'complete() — завершение исполнения Observable, не принимает никаких параметров и не передает никакого значения.\n' +
          'Но исполнение RxJS Observable начнется только после вызова у него метода subscribe(), который принимает функцию с передаваемыми данными в качестве аргумента.' +
          'Отличие от промиса можно несколько раз подписаться к стриму, отписаться,\n' +
          ' а промис отработает один раз и все',
        active: false,
      },
      {
        question: 'Subject и его разновидности',
        response:
          'Разновидность обьектов Observable - стрим где не нужно начальное значение и возвращает последнее\n' +
          '        BehaviorSubject - есть начальное и возвращает последнее\n' +
          '         ReplaceSubject - покажет все значения которые мы ему записывали',
        active: false,
      },
      {
        question: 'Операторы forkJoin,combineLatest,take',
        response:
          'Оператор forkJoin принимает любой количество Observables, ожидает их завершения, а затем возвращает массив значений ' +
          'завешенных Observables. Оператор combineLatest() - это еще один полезный оператор RxJS, который позволяет ' +
          'объединить последние значения, отправленные несколькими потоками observable ' +
          ', в один поток.Take возвращает Observable, который выдает только первые count значения, выданные исходным Observable. ' +
          'Если источник выдает меньше count значений, то' +
          ' выдаются все его значения. После этого он завершается, независимо от того, завершается ли источник.',
        active: false,
      },
      {
        question: 'Операторы skip, tap, map, filter,',
        response:
          'Skip Пропускает значения до тех пор, пока отправленные уведомления не будут равны или меньше указанного количества пропусков. ' +
          'Вызывает ошибку, если количество пропусков равно или больше фактического количества эмиттов, и источник выдает ошибку.' +
          'Tap Используется, когда вы хотите повлиять на внешнее состояние с помощью уведомления, не изменяя само уведомление.' +
          'Map Как и Array.prototype.map() , он пропускает каждое исходное значение через функцию преобразования для получения соответствующих выходных значений.' +
          'Filter Как и Array.prototype.filter() , он выдает значение из источника только в том случае, если оно проходит функцию критерия.',
        active: false,
      },
      {
        question: 'Операторы takeuntil, switchmap, mergemap, cancatmap',
        response:
          ' TakeUntil Позволяет значениям передаваться до тех пор, пока второй Observable, не выдаст значение. Затем он завершается.' +
          'Switchmap Сопоставляет каждое значение с наблюдаемым, затем выравнивает все эти внутренние наблюдаемые с помощью switchAll(Сглаживает наблюдаемое из наблюдаемых.). ' +
          'MergeMap Сопоставляет каждое значение с наблюдаемым, затем выравнивает все эти внутренние наблюдаемые с помощью mergeAll(Сглаживает наблюдаемое из наблюдаемых.). ' +
          'concatMap Сопоставляет каждое значение с наблюдаемым, затем выравнивает все эти внутренние наблюдаемые с помощью concatAll(Выравнивает наблюдаемый из наблюдаемых, помещая один внутренний наблюдаемый за другим.).',
        active: false,
      },
      {
        question: 'Операторы exhaustMap,zip,pluck,iif',
        response:
          'exhaustMap Сопоставляет каждое значение с наблюдаемым, затем выравнивает все эти внутренние наблюдаемые с помощью exhaustAll' +
          '(Выравнивает Observable-of-Observables, отбрасывая следующий внутренний Observables, пока текущий внутренний Observable все еще выполняется).' +
          'zip Объединяет несколько наблюдаемых объектов для создания наблюдаемого объекта,' +
          ' значения которого вычисляются на основе значений (по порядку) каждого из его входных наблюдаемых объектов.' +
          'pluck Похож на map, но предназначен только для выбора одного из вложенных свойств каждого отправленного значения.' +
          'iif Проверяет логическое значение во время подписки и выбирает один из двух наблюдаемых источников',
        active: false,
      },
      {
        question: 'Операторы timer,interval,of,from,fromEvent',
        response:
          'timer Используется для отправки уведомления после задержки. ' +
          'interval Используется для отправки уведомления через отрезки времени.' +
          'of Преобразует аргументы в Observable последовательность.' +
          'from Преобразует практически все в Observable объект.' +
          'fromEvent Создает Observable, который генерирует события определенного типа, исходящие из заданной цели события.',
        active: false,
      },
      //startWith,catch,catchError,
      // retry,delay,debounce,destinctUntilChanged,destinctUntilKeyChanged,toPromise
      {
        question: 'Операторы startWith,catch,catchError,retry',
        response:
          'startWith Сначала по порядку выдает свои аргументы, а затем все выбросы из источника. ' +
          'debounce Выдает уведомление из исходного наблюдаемого только по истечении определенного промежутка времени,' +
          ' определенного другим наблюдаемым, без выброса другого источника.' +
          'catchError Он только слушает канал ошибок и игнорирует уведомления. Обрабатывает ошибки из исходного наблюдаемого' +
          ' и сопоставляет их с новым наблюдаемым. Ошибка также может быть повторно выдана,' +
          ' или может быть выдана новая ошибка для выдачи ошибки из результата.' +
          'retry Возвращает Observable, который является зеркальным отражением исходного Observable, за исключением error.' +
          'delay Задерживает выброс элементов из источника Observable на заданное время или до заданной даты.',
        active: false,
      },
      {
        question:
          'Операторы destinctUntilChanged,destinctUntilKeyChanged,toPromise',
        response:
          ' destinctUntilChanged Возвращает результат Observable, который выдает все значения, отправленные исходным ' +
          'наблюдаемым объектом, если они отличаются от последнего значения, отправленного результирующим наблюдаемым объектом.' +
          'destinctUntilKeyChanged Возвращает Observable, который выдает все элементы, выданные исходным Observable, которые отличаются' +
          ' от предыдущего элемента, используя свойство, ' +
          'доступ к которому осуществляется с помощью предоставленного ключа, для проверки того, являются ли два элемента различными.' +
          'toPromise',
        active: false,
      },
    ],
    active: false,
  },

  {
    name: 'Структуры данных',
    questions: [
      {
        question: 'Названия  типов данных',
        response: 'Number,string,boolean,object,null,undefined,Symbol,BigInt',
        active: false,
      },
      {
        question: 'Скалярные типы и строки',
        response:
          'Они же простые типы данных.' +
          ' Их ключевой особенностью является то, что при присвоении другим переменным,\n' +
          'значение копируется\n' +
          '\n' +
          'К скалярным типам данных относятся:string,number,boolean',
        active: false,
      },
      {
        question: 'Массивы',
        response:
          'Массив — это структура, в которой можно хранить' +
          ' коллекции элементов — чисел, строк, других массивов и так далее.' +
          ' Элементы нумеруются и хранятся в том порядке, в котором их поместили в массив.',
        active: false,
      },
      {
        question: 'Списки, словари (хэш-таблицы), множества',
        response:
          '1.В javascript в качестве списка выступает обычный массив.' +
          '2.Хэш-таблица это структура данных, которая позволяет' +
          ' хранить пары ключ-значение и выполнять три операции над ними: ' +
          'добавление новой пары, поиск значение по ключу и удаление пары по ключу.' +
          '3.Множества:Объект Set позволяет хранить уникальные значения любого типа, будь то примитивы или ссылки на объекты.',
        active: false,
      },
      {
        question: '  Кортежи',
        response:
          'Кортежи (tuples) в TypeScript представляют собой особый вид массивов,' +
          ' где порядок элементов фиксирован, и каждый элемент имеет заранее определенный тип.' +
          ' Это позволяет точно описывать структуры данных с известным количеством и типами элементов.',
        active: false,
      },
      {
        question: '  Изменяемость типов данных',
        response:
          'В JavaScript у нас есть примитивные типы и ссылочные типы.' +
          ' Примитивные типы включают числа, строки, boolean, null, undefined.' +
          ' И ссылочные типы включают объекты, массивы и функции. Разница между этими типами' +
          ' заключается в том, что примитивные типы неизменяемы (immutable), а ссылочные типы изменяемы (mutable)',
        active: false,
      },
      {
        question: '  Сложности операций вставки и поиска',
        response: 'Number,string,boolean,object,null,undefined,Symbol,BigInt',
        active: false,
      },
      {
        question:
          'Внутреннее устройство стандартных контейнеров (список, словарь)',
        response: 'Number,string,boolean,object,null,undefined,Symbol,BigInt',
        active: false,
      },
      {
        question: 'Графы',
        response: 'Number,string,boolean,object,null,undefined,Symbol,BigInt',
        active: false,
      },
      {
        question: '    Деревья',
        response: 'Number,string,boolean,object,null,undefined,Symbol,BigInt',
        active: false,
      },
      {
        question: ' Самобалансирующиеся деревья(АВЛ, красно-черное)',
        response: 'Number,string,boolean,object,null,undefined,Symbol,BigInt',
        active: false,
      },
      {
        question: 'Понимание вычислительной сложности поиска и вставки данных',
        response: 'Number,string,boolean,object,null,undefined,Symbol,BigInt',
        active: false,
      },
      {
        question: 'Совместимость структур данных и многопоточная обработка',
        response: 'Number,string,boolean,object,null,undefined,Symbol,BigInt',
        active: false,
      },
    ],
    active: false,
  },
  {
    name: 'JavaScript',
    questions: [
      {
        question: 'JavaScript',
        response:
          'Это язык программирования с ' +
          'динамической типизацией, однопоточный',
        active: false,
      },
      {
        question: 'Типы данных',
        response:
          '1.Строка\n' +
          '2.Число\n' +
          '3.BigInt(большое число)\n' +
          '4.Boolean(логическое)\n' +
          '5.Null\n' +
          '6.Undefined(не определено)\n' +
          '7.Symbol(символ)\n' +
          '8.Object(обьект)',
        active: false,
      },
      {
        question: 'Отличие null от undefined ',
        response: 'отсутствие значение, null - намеренное присвоение',
        active: false,
      },
      {
        question: 'Prototype ',
        response: 'реализация наследования в JS',
        active: false,
      },
      {
        question: 'this,call,apply,bind',
        response:
          'this - контекст, ссылка на обьект\n' +
          'call, apply  - методы функции (this, arguments) или (this, [...arguments]) сразу вызываются\n' +
          'bind - можно забиндить и вызвать после',
        active: false,
      },
      {
        question:
          'const, let, arrow fn, class, шаблонные строки, spread, rest, итератор, генератор ',
        response:
          'const и let - ключевые слова let - можно обьявить,присвоить значение позже, также можно переприсвоить\n' +
          'const - начальное значение нужно, переприсвоить не получится, только обьект или массив\n' +
          'const && let - блочной области видимости\n' +
          'arrow fn(стрелочная функция ) -  () => {} нет своего контекста ,запоминает где была обьявлена, нет методов функций, аргументс,\n' +
          'более короткая запись, анонимна\n' +
          'spread - не глубокое копирование [...spread] || {...spread}\n' +
          'rest  - когда мы не знаем сколько у нас аргументов - используем rest ( function(a, ...rest){} )' +
          '\n' +
          'Генератор - это функция, которая можно запустить приостановить и возобновить на разных стадиях выполнения. Первый вызов функции вызовет итератор,' +
          ' у этого обьекта есть next для возобновления функции. При каждом вызове функция возобновляет свою' +
          ' работу пока не наткнется на yield и опять станет на паузу ',
        active: false,
      },
      {
        question:
          'Два подхода к обработке событий в DOM(onevent,addEventListener).Пользовательские события.Стадии прохода события',
        response:
          'События в JS - погружение и всплытие\n' +
          '1.onEvent - можно на элемент накинуть событие onClick\n' +
          '2.addEventListener - вешаем на элемент, далее пока не отпишемся через removеEventListener\n' +
          "element.addEventListener('событие (click)', функция которая наблюдает за событием (() => {}))\n" +
          '\n' +
          'Пользовательские события - \n' +
          '\n' +
          'new Event(”клик”, [опции]) опции - bubbles - true/false всплытие \n' +
          '\n' +
          'eanaeleble true/false \n' +
          '\n' +
          'composed-соьытие будет вставать за пределы shadow DOM метод dispatchEvent запускает событ[ие на элементе](http://8.web/)\n' +
          '\n' +
          'Стадии события\n' +
          '\n' +
          ' 1.погружение только addEventListener\n' +
          '\n' +
          '2.целевая фаза-все\n' +
          '\n' +
          '3.фаза всплытие - с add по capture \n',
        active: false,
      },
      {
        question: 'Web Worker ',
        response:
          'aссинхронная система позволяет выполнять тяжелые в вычислительном плане и длительные задачи\n' +
          'без блокировки потока пользовательского интерфейса. При их использовании вычисления идут параллельно.\n' +
          'Это своего рода многопоточность. Web Workers - не являются частью JS, они представляют собой возможность браузера,\n' +
          'к которой можно получить доступ посредством JS - new Worker() - они должны быть в отдельном файле ,воркеры\n' +
          'выполняются в изолированных потоках  в браузере\n' +
          'Для запуска - worker.postMessage() для отправки в основной поток   (DOM && Window -  для них недоступны)\n' +
          '\n' +
          'onMessage слушатель в основном потоке для получения сообщений от воркера terminate() завершает работу воркера \n' +
          '\n',
        active: false,
      },
      {
        question: 'Новые типы данных',
        response:
          '.new Map() - коллекция ключ/значение  - ключ любого типа\n' +
          ".set(ключ, значение) - новое записать .get('ключ') - найти  clear() - очистить  .size() - размер  .delete('ключ') -  удалить\n" +
          'new Set() - коллекция уникальных значений, без ключей\n' +
          'WeakMap() - ключи обьекты, если мы запишем значение null - то будет удален автоматом сборщиком мусора\n' +
          'нет методов перебора keys(), values(), entries(), только get, set, delete\n' +
          'WeakSet() - коллекция уникальных обьектов',
        active: false,
      },
      {
        question: 'Манипуляции с DOM',
        response:
          'Dom - поиск через getElementById - по id, querySelector - по селектору, querySelectorAll\n' +
          'getElementByClassName - по имени класса  getElementByTagName - по тегу\n' +
          'создание элемента Dom - document.createElement(tag).className(класс).innerHtml(текст)\n' +
          'чтобы его вставить body.append - добавляем в конец, prepend - в начало, before -  до, after- после\n' +
          '\n' +
          'Изменение replaseWith, cloneNode\n' +
          'удаление через element.remove()\n' +
          'добавление классов - element.classList.add/remove/sidebar.component.ts\n',
        active: false,
      },
      {
        question: 'Какие способы реализации ООП есть в JS(ES6) ',
        response:
          'ООП в JS - наследование prototype,  у классов через new\n' +
          'Инкапсуляция  - через #приватные поля и методы в классе',
        active: false,
      },
      {
        question: 'Как устроена асинхронность в js',
        response:
          '\n' +
          '12.EventLoop-соьытийный цикл суть проста ожидает задачи, исполняет их потом снова исполняет задачи \n' +
          '\n' +
          'Бщий алгоритм - пока есть задачи, выполняет с самой старой \n' +
          '\n' +
          'Все задачи можно поделить на 3 синхронный код, микрозадачи, макрозадачи \n',
        active: false,
      },
      {
        question: 'Функциональные конструкции map,reduce,filter',
        response:
          ' Метод reduce() применяет функцию reducer к каждому элементу массива' +
          ' (слева-направо), возвращая одно результирующее значение.' +
          'Метод filter() создаёт новый массив со всеми элементами, ' +
          'прошедшими проверку, задаваемую в передаваемой функции.' +
          ' Метод map вызывает переданную функцию callback один раз ' +
          'для каждого элемента, в порядке их появления и конструирует новый массив из результатов функции',
        active: false,
      },
      {
        question: 'Работа с ассинхронностью',
        response:
          '' +
          'Promise - специальный обьект  в JS, для работы с ассинхронностью\n' +
          'у него есть состояние - pending(в процессе ), reject(ошибка), fullfield(успешно)\n' +
          'методы then(), catch(), finally()  чейнинг(цепочка вызовов) - then().then()\n' +
          'new Promise((res, rej) => {})  два колбека res, rej  он срабатывает один раз и неизменяем либо resolve или reject\n' +
          '.all([]) - ждет пока все пройдут, если один с ошибкой выдаст ошибку\n' +
          '.race() - выдаст результат первого промиса\n' +
          '.allSetled() - покажет результат всех и их статусы',
        active: false,
      },
      {
        question: 'Async/await',
        response:
          'async/await - специальный синтаксис над промисом\n' +
          'async function() {return } - зарезолвленный промис\n' +
          'await - аналог .then() - у промиса\n' +
          'обработчик ошибок try/catch внутри',
        active: false,
      },
      {
        question:
          'Способы оптимизации работы с Dom.  Список самых дорогих операций',
        response:
          'добавление в Dom после рендеринга  - нужно использовать  documentFragment\n' +
          'слишком частые события window.resize - использовать debounce()\n' +
          '\n' +
          'Узлы дом необходимо создавать только при их необходимости а как только в них отпала надобность, удаляем\n' +
          '\n' +
          'Подгружать узлы по мере необходимости пользователю\n' +
          '\n' +
          'Сокращение объёма  сложных вычислительных стилей',
        active: false,
      },
      {
        question: 'Modules, Proxy, Reflect,',
        response:
          'Модули - файл с use strict режимом, у них есть импорт и экспорт\n' +
          'Proxy - спец. обьект для перехвата и переопределения основных операций\n' +
          'new Proxy(obj, handler) reflect -часто используют вместе с proxy внутри надстройка',
        active: false,
      },
      {
        question: 'localStorage, sessionStorage, cookie',
        response:
          'localStorage - хранит данные без срока годности session- во время жизни вкладки, если дублировать вкладку создаст для каждой\n' +
          "setItem('key', содержимое) - закинуть, getItem('ключ') - забрать\n" +
          'coocki - хранит данные, которые должны быть отправлены обратно на сервер последующими запросами\n' +
          'Если установить флаг httpOnly -true - для файла то предотвратит доступ на стороне клиента, добавляется  через document.coockie',
        active: false,
      },
      {
        question: 'Сборщик мусора  ',
        response:
          'Сборщик мусора периодически находит ' +
          'объекты, которые больше не доступны в контексте ' +
          'выполнения программы, и автоматически освобождает связанную с ними память',
        active: false,
      },
      {
        question: 'repaint, reflow',
        response:
          'repain -перерисовка элементов стили визуальный слой, ' +
          'без изменения размеров\n' +
          'reflow - перерисовка макета страницы',
        active: false,
      },
      {
        question: 'Web Assembly',
        response:
          'язык программирования низкого уровня, призванный внести программируемость ' +
          'туда, где нужны кроссплатформенность,' +
          ' эффективность и безопасность, в первую очередь на клиентскую сторону Всемирной паутины.',
        active: false,
      },
    ],
    active: false,
  },
];
