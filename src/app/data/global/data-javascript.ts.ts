import { IDataQuestion } from '../question/type';

export const dataJS: IDataQuestion = {
  name: 'JavaScript',
  questions: [
    {
      question: 'Что такое JavaScript?',
      response:
        'Это язык программирования с ' +
        'динамической типизацией, однопоточный',
      active: false,
    },
    {
      question: 'Типы данных',
      response:
        '1.Строка\n' +
        '2.Число\n' +
        '3.BigInt(большое число)\n' +
        '4.Boolean(логическое)\n' +
        '5.Null\n' +
        '6.Undefined(не определено)\n' +
        '7.Symbol(символ)\n' +
        '8.Object(обьект)',
      active: false,
    },
    {
      question: 'Отличие null от undefined ',
      response:
        'undefined - отсутствие значение, null - намеренное присвоение' +
        'undefined:\n' +
        '- Обычно используется системой или движком JavaScript, чтобы указать, что что-то не было инициализировано или не было установлено.\n' +
        '- Это может происходить, когда функция не возвращает значение (в этом случае возвращается undefined по умолчанию).\n' +
        '\n' +
        '- null:\n' +
        '- Используется программистами для указания на отсутствие значения.\n' +
        '- Чаще всего применяется в логике программы, чтобы обозначить, что значение было удалено или не установлено по какой-то причине.',
      active: false,
    },
    {
      question:
        'Какие из типов данных являются ссылочными типами в JavaScript? ',
      response:
        '1. Объекты (Objects)\n' +
        '- Объекты являются основным типом данных и могут содержать множество значений в виде ' +
        'пар ключ-значение. Каждый объект является ссылочным типом.' +
        '2. Массивы (Arrays)\n' +
        '- Массивы являются специализированным типом объектов и могут содержать упорядоченные коллекции значений. Массивы также являются ссылочными.' +
        '' +
        '3. Функции (Functions)\n' +
        '- Функции в JavaScript также являются объектами, и их можно рассматривать как ссылочные типы данных. Это означает, что функции могут быть присвоены переменным, переданы в другие функции и возвращены из других функций.' +
        'Даты (Dates)\n' +
        '- Объект Date используется для работы с датами и временем, и он также является ссылочным типом данных.' +
        'Регулярные выражения (Regular Expressions)\n' +
        '- Регулярные выражения используются для работы с текстом и также являются объектами, следовательно, они относятся к ссылочным типам данных.' +
        'Классы (Classes)\n' +
        '- Классы в JavaScript являются конструкторами, которые можно использовать для создания объектов. При создании экземпляра класса создается ссылочный тип.' +
        'Особенности ссылочных типов данных\n' +
        '\n' +
        '- Ссылки vs. Значения: При присвоении или передаче ссылочных типов данных, передается не само значение, а ссылка на объект. Это означает, что изменения в одном месте могут повлиять на объект в другом месте, где используется эта ссылка.\n' +
        '- Проверка на равенство: При использовании оператора строгого равенства === для сравнения двух объектов, будет возвращено true только если оба объекта ссылаются на один и тот же экземпляр в памяти.' +
        'В заключение, ссылочные типы данных в JavaScript включают объекты, массивы, функции, даты, регулярные выражения и классы. Они позволяют более гибко управлять данными и делают JavaScript мощным инструментом для разработки.',
      active: false,
    },
    {
      question: 'Symbol, что такое, когда и для чего используется?  ',
      response:
        'Symbol — это примитивный тип данных в JavaScript, который был введен в ECMAScript 2015 (ES6). ' +
        'Он представляет уникальные и неизменяемые идентификаторы, которые могут быть использованы как' +
        ' ключи для свойств объектов. Вот основные аспекты использования Symbol:\n' +
        '\n' +
        '### 1. Уникальность\n' +
        '\n' +
        'Каждый символ создается с помощью функции Symbol(), и каждый раз, когда вы вызываете эту функцию' +
        ', создается новый символ. Даже если вы создаете символы с одинаковыми описаниями, они все равно будут уникальными.' +
        '2. Использование в качестве ключей свойств объектов\n' +
        '\n' +
        'Символы часто используются в качестве уникальных ключей для свойств объектов. Это помогает избежать конфликтов имен, особенно ' +
        'если вы работаете с объектами, расширяемыми другими библиотеками или кодом.\n' +
        '3. Для создания приватных свойств\n' +
        '\n' +
        'Символы создают свойства, которые труднее случайно перезаписать или переопределить, что делает их хорошими для создания приватных свойств внутри объектов.' +
        ' Однако следует отметить, что символы не являются полностью приватными; они могут быть доступны через рефлексию.' +
        '4. Символы и встроенные методы\n' +
        '\n' +
        'В JavaScript существуют несколько встроенных символов (например, Symbol.iterator, Symbol.asyncIterator, Symbol.toStringTag и других), которые предоставляют специальные функции для встроенных объектов.\n' +
        '\n' +
        'Например, Symbol.iterator позволяет определить, как объект должен быть итерирован с использованием конструкций, таких как for...of.' +
        '5. Применение в библиотеках\n' +
        '\n' +
        'Символы также используются в современных библиотеках и фреймворках для реализации таких функций, как "переопределение методов" и "расширение интерфейсов".\n' +
        '\n' +
        '### Заключение\n' +
        '\n' +
        'Символы в JavaScript предоставляют способ создания уникальных идентификаторов и помогают избегать конфликтов имен в объектах.' +
        ' Они особенно полезны для создания приватных свойств и методов, а также для определения собственного поведения объектов в конструкциях итерирования.',
      active: false,
    },
    {
      question: 'Генераторы/итераторы?',
      response:
        'Генераторы и итераторы — это понятия, связанные с обходом коллекций данных в JavaScript, но они представляют разные концепции.\n' +
        '\n' +
        '### Итераторы\n' +
        '\n' +
        'Итератор — это объект, который позволяет последовательно обходить коллекцию данных (например, массивы, строки и другие структуры данных). Итераторы реализуют метод next(), который возвращает объект с двумя свойствами:\n' +
        '\n' +
        '1. value: текущее значение, которое возвращается итератором.\n' +
        '2. done: логическое значение, которое указывает, завершен ли обход коллекции (если true, это означает, что итерация завершена).' +
        'Генераторы\n' +
        '\n' +
        'Генераторы — это специальный вид функций, который упрощает создание итераторов. Генераторы объявляются с использованием ' +
        'синтаксиса function* (обратите внимание на звёздочку после function). Генераторы могут использовать ключевое слово yield' +
        ' для возврата значения. После каждого вызова yield функция приостанавливается, сохраняя свое состояние, и возобновляется ' +
        'при следующем вызове.' +
        'Преимущества генераторов\n' +
        '\n' +
        '1. Состояние: Генераторы сами управляют своим состоянием, приостанавливая выполнение и продолжая его при каждом вызове next().\n' +
        '\n' +
        '2. Упрощение кода: С помощью генераторов можно легко создавать итераторы без необходимости явно реализовывать интерфейс итератора.\n' +
        '\n' +
        '3. Ленивая оценка (Lazy Evaluation): Генераторы могут производить значения по мере необходимости, что позволяет экономить память и время.\n' +
        '\n' +
        '### Итераторы и протокол итерации\n' +
        '\n' +
        'Протокол итерации определяет стандартный способ обхода объектов в JavaScript. Каждый объект, который реализует протокол итерации, должен иметь метод ' +
        'Symbol.iterator, который возвращает объект-итератор. Это позволяет использовать конструкции типа for...of.',
      active: false,
    },
    {
      question: 'Как работает наследование в JS?',
      response:
        'Наследование в JavaScript представляет собой механизм, позволяющий создавать новые объекты на основе существующих,' +
        ' унаследуя их свойства и методы. Этот подход широко используется для организации кода и повторного использования его частей.\n' +
        '\n' +
        '### 1. Прототипное наследование\n' +
        '\n' +
        'JavaScript использует прототипное наследование. Каждой функции (включая функции-конструкторы) в JavaScript ' +
        'присваивается свойство prototype, которое указывает на объект, из которого будут унаследованы свойства и методы новых объектов.' +
        ' Когда вы обращаетесь к свойству объекта, JavaScript сначала ищет его в самом объекте, а затем в его прототипах.\n' +
        '2. Классы и наследование\n' +
        '\n' +
        'С введением ES6 (ECMAScript 2015) в JavaScript был добавлен синтаксис классов, который позволяет более удобно и понятно создавать классы и наследование. ' +
        'Классы являются синтаксическим сахаром над прототипным наследованием.' +
        '3. Прототип и Object.create()\n' +
        '\n' +
        'Наследование также можно реализовать с помощью функции Object.create(), которая позволяет создавать объект с указанным прототипом.' +
        '3. Прототип и Object.create()\n' +
        '\n' +
        'Наследование также можно реализовать с помощью функции Object.create(), которая позволяет создавать объект с указанным прототипом.' +
        '4. Наследование свойств\n' +
        '\n' +
        'Наследование в JavaScript также позволяет передавать не только методы, но и свойства:\n' +
        '\n' +
        '- При создании объекта на основе другого объекта, новый объект может добавлять свои собственные методы и свойства, а также переопределять унаследованные.\n' +
        '\n' +
        '### 5. Ограничения и нюансы\n' +
        '\n' +
        '- В JavaScript можно создать объект из другого объекта с помощью прототипного наследования, но все свойства и методы передаются по ссылке. Это означает, что если вы измените метод в родительском объекте, все потомки также получат это изменение.\n' +
        '\n' +
        '- Если свойство переопределено в дочернем объекте, оно будет скрывать унаследованное свойство (собственное свойство имеет приоритет).',
      active: false,
    },
    {
      question:
        'Прототипная модель. Что это? Как организуется родительская цепочка? ',
      response:
        '\n' +
        '### 1. Прототипы и прототипная цепочка\n' +
        '\n' +
        'Кажкий объект в JavaScript имеет внутреннее свойство [[Prototype]], которое ссылается на другой объект (прототип). Это позволяет создавать цепочку объектов, называемую прототипной цепочкой.\n' +
        '\n' +
        '- Когда вы обращаетесь к свойству или методу объекта, JavaScript сначала ищет это свойство в самом объекте. Если оно не найдено, JavaScript следует прототипной цепочке, проверяя каждый объект, пока не найдет свойство или не дойдет до конца цепочки (где [[Prototype]] равен null).\n' +
        '\n' +
        '### 2. Создание объектов и прототипов\n' +
        '\n' +
        'Существует несколько методов создания объектов, которые инициализируют прототипный механизм:\n' +
        '\n' +
        '#### 2.1. Создание объекта через литерал' +
        '2.2. Конструкторы и new\n' +
        '\n' +
        'Вы можете создавать объекты с помощью функции-конструктора' +
        ' 3. Классовый синтаксис.С введением ECMAScript 2015 (ES6) был введен синтаксис классов, который обеспечивает более удобный способ работы с прототипным наследованием' +
        '4. Организация родительской цепочки\n' +
        '\n' +
        'Цепочка наследования организуется через свойство prototype. Каждый раз, когда вы создаете объект через конструктор, JavaScript создает внутреннее свойство [[Prototype]], указывающее на prototype конструктора.\n' +
        '\n' +
        'При использовании Object.create() вы явно задаете прототип для нового объекта, в то время как при использовании синтаксиса классов и конструкторов это делается автоматически через prototype.' +
        'Прототипное наследование позволяет:\n' +
        '\n' +
        '- Разделять память: При использовании методов, определенных на прототипе, вы экономите память, не создавая копию методов в каждом экземпляре.\n' +
        '\n' +
        '- Гибкость: Если вы измените метод на прототипе, все экземпляры объектов автоматически получат новое поведение.\n' +
        '\n' +
        '- Динамическое добавление свойств и методов: Вы можете добавлять свойства и методы к прототипу после создания объектов, и все существующие экземпляры будут иметь доступ к ним.',
      active: false,
    },
    {
      question: 'Чем отличается __proto__ от prototype?',
      response:
        'В JavaScript __proto__ и prototype — это два разных, но связанных понятия, которые касаются прототипного наследования. ' +
        'Давайте рассмотрим их подробнее:\n' +
        '\n' +
        '### 1. prototype\n' +
        '\n' +
        '- Что это?\n' +
        'prototype — это специальное свойство, которое существует на функциях-конструкторах. Каждый раз, ' +
        'когда вы создаете объект с помощью конструкции new, объекту будет автоматически присвоено свойство' +
        ' prototype конструктора,' +
        ' из которого он был создан. Это свойство определяет, какие методы и свойства должны быть доступны для экземпляров ' +
        'этого конструктора.\n' +
        '- Когда используется?\n' +
        'Используется для добавления методов и свойств, которые будут доступны всем экземплярам, созданным с помощью данного конструктора.\n' +
        '\n' +
        '### 2. __proto__\n' +
        '\n' +
        '- Что это?\n' +
        '__proto__ — это свойство объекта, которое указывает на его прототип. Каждое создаваемое в JavaScript' +
        ' значение (объект) имеет внутреннее свойство [[Prototype]], к которому вы можете получить доступ через ' +
        '__proto__. Это свойство ссылается на объект, из которого были унаследованы' +
        ' его свойства и методы. Доступ к __proto__ обычно используется для проверки или изменения прототипа объекта во время выполнения.' +
        '- Когда используется?\n' +
        'Используется для получения доступа к прототипу объекта, чтобы проверить, какие методы и свойства объект унаследовал от своего прототипа.\n' +
        '\n' +
        '### Основные отличия:\n' +
        '\n' +
        '- prototype существует только у функций-конструкторов, а __proto__ существует у всех объектов.\n' +
        '- prototype используется для определения свойств и методов, которые будут унаследованы экземплярами, в то время как __proto__ используется для доступа к прототипу существующего объекта.\n' +
        '- Придерживайтесь использования prototype для добавления методов к конструкторам, а __proto__ — в основном для поиска или изменения цепочки прототипов (хотя рекомендуется использовать метод ' +
        'Object.getPrototypeOf() и Object.setPrototypeOf() вместо __proto__).',
      active: false,
    },
    {
      question:
        'Как узнать есть ли св-во у объекта или оно находится в цепочке прототипов?',
      response:
        'В JavaScript для проверки наличия свойства у объекта и его прототипов есть несколько подходов. Основными методами являются использование оператора in, метода hasOwnProperty, а также метода Object.getOwnPropertyDescriptor. Рассмотрим каждый из них.\n' +
        '\n' +
        '### 1. Оператор in\n' +
        '\n' +
        'Оператор in проверяет, существует ли указанное свойство в объекте или в его цепочке прототипов.' +
        ' Он возвращает true, если свойство найдено, и false, если нет.\n' +
        '2. Метод hasOwnProperty\n' +
        '\n' +
        'Метод hasOwnProperty проверяет, принадлежит ли данное свойство непосредственно объекту, не обращая внимания на свойства в цепочке прототипов.' +
        ' Он возвращает true, если свойство принадлежит объекту.' +
        '3. Метод Object.getOwnPropertyDescriptor\n' +
        '\n' +
        'Этот метод позволяет получить дескриптор свойства для объекта, и его использование может быть полезным для последних проверок свойств. Если свойство не существует, он вернет undefined.' +
        '4. Сравнение методов\n' +
        '\n' +
        '- Используйте in, если хотите проверить, существует ли свойство в объекте или его прототипах.\n' +
        '- Используйте hasOwnProperty, если вам нужно знать, принадлежит ли свойство непосредственно объекту.\n' +
        '- Используйте Object.getOwnPropertyDescriptor, если вам нужно получить информацию о конкретном свойстве.',
      active: false,
    },
    {
      question:
        'Сколько может быть прототипов у одного объекта? Какой существует подход для\n' +
        'реализации двух прототипов у объекта?',
      response:
        'В JavaScript каждый объект имеет свойство [[Prototype]], которое указывает на его прототип, и образует цепочку прототипов.' +
        ' Однако, в JavaScript не существует множественного наследования, поэтому у одного объекта может быть только один прототип.' +
        ' Это свойство родительской цепочки и называется "прототипное наследование" (prototypal inheritance).\n' +
        '\n' +
        'Тем не менее, есть несколько способов реализации поведения, похожего на многопрототипное наследование, хотя ' +
        'на самом деле это не предполагает истинного множественного наследования, а скорее комбинирование свойств или ' +
        'методик. Вот основные подходы:\n' +
        '\n' +
        '### 1. Композиция объектов\n' +
        '\n' +
        'Вы можете создать несколько объектов с необходимыми свойствами и методами и затем комбинировать их в одном объекте.' +
        ' Например, вы можете использовать функции для создания объектов и добавления методов:\n' +
        '2. Использование классов и миксинов\n' +
        '\n' +
        'В ES6 можно использовать классы и методы, которые можно объединять с помощью простых миксинов.\n' +
        '3. Создание объектов с помощью конструкций Object.create()\n' +
        '\n' +
        'При создании объекта с помощью Object.create() вы можете создать новую цепочку прототипов сверху на старом объекте',
      active: false,
    },
    {
      question: 'Что делает instanceof? Когда он может быть полезен?',
      response:
        'Оператор instanceof в JavaScript используется для проверки, является ли объект экземпляром определённого класса или конструктора. Он возвращает логическое значение' +
        ' (true или false), указывающее, находится ли объект в цепочке прототипов функции-конструктора.' +
        '1. Проверка типа объектов:\n' +
        '- Оператор instanceof позволяет определить, к какому классу или родительскому классу принадлежит объект, что полезно, когда вы работаете с множеством типов объектов.\n' +
        '- Например, вы можете использовать его в функциях для проверки, передан ли правильный тип данных.\n' +
        '\n' +
        '2. Реализация полиморфизма:\n' +
        '- При создании объектов, расширяющих другие классы, instanceof может помочь стилю полиморфного поведения, обеспечивая возможность обработки объектов по их классам.\n' +
        '\n' +
        '3. Проверка пользовательских событий:\n' +
        '- В приложениях, работающих с пользовательскими событиями или кастомными объектами, instanceof может помочь в идентификации и обработке этих событий в зависимости от их типа.',
      active: false,
    },
    {
      question: 'Какие типы копируются по ссылке, а какие по значению? ',
      response:
        '- Примитивные типы (string, number, boolean, undefined, null, symbol и bigint) копируются по значению.\n' +
        '- Объекты (включая массивы и функции) копируются по ссылке.' +
        'Объекты могут быть:\n' +
        '1. Object (обычные объекты)\n' +
        '2. Array (массивы)\n' +
        '3. Function (функции)\n' +
        '4. Date (даты)\n' +
        '5. RegExp (регулярные выражения)',
      active: false,
    },
    {
      question: 'Разница между == и ===? ',
      response:
        '1. Нестрогое равенство (==)\n' +
        '\n' +
        'Оператор == сравнивает значения, выполняя неявное преобразование типов, если типы значений не совпадают.' +
        ' Это означает, что JavaScript попытается привести типы операндов к одному и тому же типу перед сравнением.\n' +
        '2. Строгое равенство (===)\n' +
        '\n' +
        'Оператор === сравнивает значения без выполнения неявного преобразования типов. ' +
        'Это означает, что если типы операндов не совпадают, результат всегда будет false.' +
        ' Всегда используйте ===: В большинстве случаев рекомендуется использовать строгое равенство (===), поскольку оно более предсказуемо и безопасно. Оно поможет избежать неожиданных результатов, которые могут возникнуть из-за неявного преобразования типов.\n' +
        '- Оператор == можно использовать в специфических ситуациях, когда нужно учитывать преобразование типов, но такие случаи обычно редки.\n',
      active: false,
    },
    {
      question:
        'Как изменить свойство объекта возвращая новый объект? (Object.DefineProperty) ',
      response:
        ' В JavaScript вы можете использовать метод Object.defineProperty() для изменения или создания' +
        ' свойств объекта. Этот метод позволяет вам определять,' +
        ' как свойства работают, в том числе, делают ли они доступными для записи, перечисления и конфиденциальности.\n' +
        'Примечания:\n' +
        '- Object.defineProperty() может быть использован для создания свойств, которые могут быть скрыты от ' +
        'перечисления (если установить enumerable: false), или настроены как нерекомендуемые в будущем (если установить configurable: false).\n' +
        '- Если вы хотите просто создать новый объект с изменёнными значениями и без необходимости контроля ' +
        'над свойством, более удобным может быть использование стандартного оператора распространения (...) без Object.defineProperty(). Использование Object.defineProperty() нужно, если у вас есть особые требования во время создания или изменения свойств.\n' +
        '\n' +
        '### Альтернативный подход:\n' +
        'Если вам не нужно устанавливать специальные параметры для свойства, вы также можете просто создать новый ' +
        'объект, используя оператор распространения',
      active: false,
    },
    {
      question: 'Сколько потоков в JavaScript?',
      response:
        'JavaScript является однопоточным языком программирования, что означает, что он выполняет операции' +
        ' последовательно в одном потоке. Это позволяет избежать проблем, связанных с многопоточностью, такими как гонки данных и состояние гонки. Однако, несмотря на однопоточную природу, JavaScript имеет' +
        ' механизмы для асинхронного выполнения кода, что позволяет эффективно обрабатывать операции ввода/вывода ' +
        'без блокировки выполнения.\n' +
        '\n' +
        '### Основные аспекты однопоточности JavaScript:\n' +
        '\n' +
        '1. Основной поток: В JavaScript всё выполняется в едином основном потоке, и этот поток отвечает за выполнение' +
        ' всех скриптов, обработку событий и работу с DOM. Это означает, что операции выполняются последовательно, одна за другой.\n' +
        '\n' +
        '2. Асинхронность через колбэки и промисы: JavaScript позволяет выполнять асинхронные операции, такие как ' +
        'HTTP-запросы или таймеры, через колбэк-функции, промисы и async/await. Хотя сам JavaScript остаётся однопоточным, асинхронное выполнение позволяет эффективно управлять задачами, ожидая завершения операций без блокировки основного потока.\n' +
        '\n' +
        '3. Event Loop: Этот механизм управляет очередями задач и синхронизацией между асинхронными операциями. ' +
        'Он позволяет JavaScript обрабатывать множество операций, таких как ввод/вывод, события пользователей и таймеры, более эффективно, чем если бы подавляющее большинство операций выполнялось синхронно.\n' +
        '\n' +
        '4. Web Workers: Хотя JavaScript является однопоточным, есть возможность использовать Web Workers для выполнения операций в фоновом режиме. Web Workers позволяют запускать скрипты в отдельных потоках, что даёт возможность выполнять ресурсоёмкие задачи, не блокируя основной поток. Однако Web Workers имеют свои собственные контексты и не могут напрямую взаимодействовать с DOM.',
      active: false,
    },
    {
      question:
        'Как реализована и работает асинхронность? (В браузере и под капотом)\n',
      response:
        '1. Основные механизмы асинхронности\n' +
        '\n' +
        '#### a. Callbacks (колбек-функции)\n' +
        'Это самый базовый способ работы с асинхронными операциями. Во время выполнения асинхронного кода вы передаёте' +
        ' функцию (колбек), которая будет вызвана после завершения операции. Когда операция завершена, вызывается колбек с результатами.' +
        'Promises (промисы)\n' +
        'Промисы представляют собой более современный и удобный способ работы с асинхронным кодом, позволяя избавиться от "адских колбеков" (callback hell). ' +
        'Промисы могут находиться в одном из трёх состояний: разрешён (fulfilled), отклонён (rejected) или ожидающий (pending).' +
        'Async/Await\n' +
        'В синтаксисе async/await основан на промисах, но делает код более читаемым и похожим на синхронный. Объявляя функцию как async, вы можете использовать await, чтобы подождать завершения промиса.' +
        ' 2. Event Loop (событийный цикл)\n' +
        '\n' +
        '#### a. Как работает Event Loop\n' +
        'Event Loop — арбитр между основным потоком, очередями задач (callback queue) и очередями микротасков (microtask queue). Он контролирует выполнение JavaScript, гарантируя, что всё выполняется корректно, не блокируя UI.\n' +
        '\n' +
        '1. Стек вызовов (Call Stack): Это структура данных, которая хранит функции для выполнения. Когда функция вызывается, она помещается в стек, а когда выполнение заканчивается, она удаляется из стека.\n' +
        '\n' +
        '2. Очередь колбеков (Callback Queue): Когда асинхронная операция завершена, её колбек помещается в эту очередь. Как только стек вызовов пуст, Event Loop извлекает колбек из очереди и помещает его в стек для выполнения.\n' +
        '\n' +
        '3. Очередь микротасков (Microtask Queue): Это специальная очередь для промисов и других микротасков. Все задачи в этой очереди выполняются перед следующей задачей из очереди колбеков. Это означает, что если в процессе выполнения строки кода вы создаёте промис, его колбек будет выполнен до того, как будут обработаны события из очереди колбеков.\n' +
        '\n' +
        '### 3. Под капотом (инфраструктура)\n' +
        '\n' +
        'В основном, асинхронные операции обрабатываются браузером и его внутренним API, которые взаимодействуют с JavaScript:\n' +
        '\n' +
        '- API браузера: Многие асинхронные операции (например, HTTP-запросы через fetch, таймеры через setTimeout, работа с событиями) обрабатываются не самим JavaScript, а браузером. Когда вы вызываете fetch, браузер выполняет HTTP-запрос, а JavaScript продолжает выполнение.\n' +
        '\n' +
        '- Web APIs: Браузеры реализуют такие API, как XMLHttpRequest, fetch, setTimeout и многие другие, которые могут выполнять операции вне основного потока JavaScript.\n' +
        '\n' +
        '- Программное взаимодействие: Когда завершается асинхронная операция, браузер помещает соответствующий колбек в очередь задач, оповещая Event Loop о необходимости выполнения.',
      active: false,
    },
    {
      question: 'Чем отличается асинхронность от многопоточности? ',
      response:
        'Асинхронность:\n' +
        '- Асинхронный подход позволяет программе выполнять операции, не блокируя основной поток выполнения. ' +
        'Например, в JavaScript, когда идет выполнение долгой асинхронной операции (например, HTTP-запрос или таймер),' +
        ' основной поток не останавливается, и код продолжает выполняться.\n' +
        '- При завершении асинхронной операции (например, получение ответа от сервера) результат передаётся' +
        ' обратно (например, через колбек функцию, промис или async/await).\n' +
        '\n' +
        '- Многопоточность:\n' +
        '- Многопоточность предполагает наличие нескольких потоков, которые могут выполняться одновременно.' +
        ' Каждый поток может выполнять свою собственную задачу, что позволяет использовать ресурсы системы ' +
        'более эффективно, особенно на многоядерных процессорах.\n' +
        '- Многопоточность позволяет одновременно обрабатывать несколько задач в разных потоках, каждый из ' +
        'которых может взаимодействовать с общим состоянием программы, что приводит к необходимости управления ' +
        'поведением потоков и синхронизации.\n' +
        ' Асинхронный подход позволит обрабатывать операции без блокировки потока, в то время как многопоточность позволяет ' +
        'выполнять несколько операций ' +
        'одновременно с помощью разных потоков. Важно выбирать подход в зависимости от задачи, размера и требований приложения.',
      active: false,
    },
    {
      question: 'Что такое promise? Когда и для чего используется?',
      response:
        'Promise (промис) в JavaScript — это объект, представляющий промежуточный результат асинхронной операции. Промисы позволяют работать с асинхронным кодом более структурированно и упрощают обработку успеха или ошибки выполнения операции. Давайте рассмотрим подробнее, что такое промисы, как они работают и когда их использовать.\n' +
        '\n' +
        '### Основные характеристики промисов\n' +
        '\n' +
        '1. Состояния:\n' +
        '- Ожидающее (Pending): начальное состояние, промис ещё не выполнен и не отклонён.\n' +
        '- Разрешённое (Fulfilled): операция завершена успешно. Промис теперь содержит результат выполнения.\n' +
        '- Отклонённое (Rejected): операция завершена с ошибкой. Промис содержит причину ошибки.\n' +
        '\n' +
        '2. Методы:\n' +
        '- then(): используется для обработки успешного завершения. Принимает до двух функций: первая выполняется, если промис будет разрешён, вторая — если он будет отклонён (второй обработчик является необязательным).\n' +
        '- catch(): используется для обработки ошибок. Вызывается, если промис был отклонён.\n' +
        '- finally(): вызывается независимо от результата — как при успешном завершении, так и при ошибке.' +
        'Когда и для чего используются промисы\n' +
        '\n' +
        '1. Асинхронные операции: Промисы особенно полезны для работы с асинхронными вызовами, такими как запросы к API, работа с файловой системой, таймеры и т. д. Они помогают лучше организовать код, избегая "адов колбеков".\n' +
        '\n' +
        '2. Упрощение обработки ошибок: Промисы упрощают обработку ошибок. Ошибки можно перехватывать и обрабатывать централизованно, используя метод catch().\n' +
        '\n' +
        '3. Цепочка промисов: Промисы позволяют создавать цепочки вызовов через метод then(). Это особенно полезно, если нужно выполнить несколько связанных асинхронных операций последовательно.\n' +
        '\n' +
        '4. Конкуррентное выполнение: Промисы могут выполняться параллельно с помощью методов, таких как Promise.all(), Promise.race(), что упрощает выполнение нескольких асинхронных операций одновременно.',
      active: false,
    },
    {
      question:
        'В чём разница между стеком вызовов (call stack) и очередью событий (task queue)?',
      response:
        ' Стек вызовов (call stack) и очередь событий (task queue, также известная как очередь колбеков) — это две ключевые структуры данных в модели выполнения JavaScript, определяющие, как и в каком порядке выполняются функции и обрабатываются события. Давайте рассмотрим их основные различия и функции более подробно.\n' +
        '\n' +
        '### 1. Основные понятия\n' +
        '\n' +
        '#### a. Стек вызовов (Call Stack)\n' +
        '- Описание: Стек вызовов — это структура данных, которая отслеживает текущие выполняемые функции. Он работает по принципу LIFO (Last In, First Out), что означает, что последняя добавленная функция будет выполнена первой.\n' +
        '- Что происходит: Когда функция вызывается, она помещается на вершину стека. Когда выполнение функции завершается, она удаляется из стека, и управление передаётся функции, которая была перед ней в стеке.\n' +
        '- Использование: Стек используется для управления текущими функциями, их вызовами и возвратами. Он обрабатывает синхронные вызовы и их возвращение.\n' +
        '\n' +
        '#### b. Очередь событий (Task Queue)\n' +
        '- Описание: Очередь событий — это структура данных, которая хранит функции обратного вызова (callback-функции), ожидающие выполнения. Эти функции обычно связаны с асинхронными событиями, такими как обработка событий, таймеров и результатов API-запросов.\n' +
        '- Что происходит: Когда возникает событие (например, завершение промиса или истечение времени таймера), соответствующая колбек-функция помещается в очередь событий. Функции из этой очереди выполняются после того, как стек вызовов станет пустым.\n' +
        '- Использование: Очередь событий позволяет осуществлять выполнение асинхронных задач, не блокируя основной поток выполнения. Она гарантирует, что колбеки будут вызываться после завершения текущего синхронного кода.\n' +
        '\n' +
        '### 2. Рабочий процесс\n' +
        '\n' +
        '- Стек вызовов:\n' +
        '- Содержит текущие вызовы функций.\n' +
        '- Когда стек пуст, JavaScript начинает извлекать функции из очереди событий.\n' +
        '\n' +
        '- Очередь событий:\n' +
        '- Содержит функции обратного вызова, которые будут выполнены позже.\n' +
        '- Когда стек вызовов пуст, JavaScript начинает выполнять функции из очереди событий, перемещая их на верхушку стека вызовов.\n' +
        ' Как это работает вместе' +
        'Предположим, у нас есть следующий код:\n' +
        '\n' +
        '\n' +
        'console.log("Start");\n' +
        '\n' +
        'setTimeout(() => {\n' +
        '    console.log("Timeout 1");\n' +
        '}, 0);\n' +
        '\n' +
        'setTimeout(() => {\n' +
        '    console.log("Timeout 2");\n' +
        '}, 0);\n' +
        '\n' +
        'console.log("End");\n' +
        '\n' +
        '\n' +
        '#### Исполнение:\n' +
        '1. Выполняется console.log("Start");: помещается в стек вызовов, затем выполняется и удаляется.\n' +
        '2. Вызывается setTimeout(...), добавляя колбек в очередь событий (колбек помещается в очередь, но сам таймер не блокирует выполнение).\n' +
        '3. Выполняется console.log("End");: помещается в стек вызовов, затем выполняется и удаляется.\n' +
        '4. Стек вызовов пуст, и JavaScript начинает извлекать колбеки из очереди событий. Сначала выполняется первый колбек из setTimeout(...), выводя "Timeout 1", затем "Timeout 2".' +
        'Вывод:\n' +
        '\n' +
        'Start\n' +
        'End\n' +
        'Timeout 1\n' +
        'Timeout 2' +
        '4. Важно помнить\n' +
        '- Синхронные операции: выполняются в стекe вызовов.\n' +
        '- Асинхронные операции: помещают свои колбеки в очередь событий.\n' +
        '- Очередь событий обрабатывается только после завершения всех синхронных операций в стеке вызовов.',
      active: false,
    },
    {
      question:
        'Какие паттерны проектирования вы знаете? Какие из них использовали? Расскажите\n' +
        'поподробнее про один из них? (такое синглтон, фабрика, модуль, декоратор,\n' +
        'publisher/subscriber)',
      response:
        ' Паттерны проектирования (или шаблоны проектирования) — это проверенные решения для часто встречающихся проблем в разработке программного обеспечения. Они помогают создавать гибкие, поддерживаемые и легко расширяемые системы. Вот некоторые из наиболее известных паттернов проектирования:\n' +
        '\n' +
        '### 1. Одиночка (Singleton)\n' +
        '- Обеспечивает наличие только одного экземпляра класса и предоставляет глобальную точку доступа к этому экземпляру.\n' +
        '\n' +
        '### 2. Фабрика (Factory)\n' +
        '- Определяет интерфейс для создания объектов, но позволяет подклассам изменять тип создаваемых объектов. Существует несколько вариаций, таких как "Фабричный метод" и "Абстрактная фабрика".\n' +
        '\n' +
        '### 3. Модуль (Module)\n' +
        '- Группирует полезные функции и переменные в одном объекте, скрывая детали реализации и предоставляя только необходимый интерфейс.\n' +
        '\n' +
        '### 4. Декоратор (Decorator)\n' +
        '- Позволяет динамически добавлять функциональность объекту, не изменяя его структуру. Это достигается путем обертывания объекта в другой объект.\n' +
        '\n' +
        '### 5. Издатель/Подписчик (Publisher/Subscriber)\n' +
        '- Определяет взаимосвязь между объектами в виде подписки и уведомления, позволяя объектам взаимодействовать косвенно через события.\n' +
        '\n' +
        '### Пример паттерна: Singleton\n' +
        '\n' +
        '#### Описание\n' +
        'Паттерн "Одиночка" используется, когда необходимо гарантировать, что в системе будет только один экземпляр класса. Это может быть полезно для управления ресурсами, такими как конфигурации, подключение к базе данных или логгирование.\n' +
        'Пример паттерна: Singleton\n' +
        '\n' +
        '#### Описание\n' +
        'Паттерн "Одиночка" используется, когда необходимо гарантировать, что в системе будет только один экземпляр класса. Это может быть полезно для управления ресурсами, такими как конфигурации, подключение к базе данных или логгирование.\n' +
        'Этот паттерн часто используется в ситуациях, когда необходимо управлять доступом к общему ресурсу — например, в настройках приложения, настраиваемых через конфигурационные файлы, или при работе с единственным кадровым объектом, который отвечает за управление определенными аспектами приложения.\n',
      active: false,
    },
    {
      question: 'Какие типы модулей вы знаете? (AMD, UMD, CommonJs)\n',
      response:
        'Существует несколько типов модульных систем, которые используются для организации кода в JavaScript. Они обеспечивают решение проблемы "глобального пространства имен" и позволяют разделять код на части, чтобы улучшить его структуру и повторное использование. Вот краткий обзор трех основных типов модулей: AMD, UMD и CommonJS.\n' +
        '\n' +
        '### 1. AMD (Asynchronous Module Definition)\n' +
        '\n' +
        '- Описание: AMD - это спецификация, позволяющая загружать модули асинхронно. Эта система часто используется в браузерах.\n' +
        '- Преимущества:\n' +
        '- Позволяет загружать модули параллельно, что улучшает производительность.\n' +
        '- Инъекция зависимостей происходит во время загрузки скриптов.' +
        'спользование: Часто используется в сочетании с библиотеками, такими как RequireJS.\n' +
        '\n' +
        '### 2. CommonJS\n' +
        '\n' +
        '- Описание: CommonJS - это модульная система, разработанная для серверной среды (например, Node.js). Она использует синхронные вызовы для загрузки модулей.\n' +
        '- Преимущества:\n' +
        '- Простота работы с модулями, так как код может быть написан на сервере и немедленно загружен.\n' +
        '- Возможность использования модулей в Node.js и в некоторых сборщиках (например, Webpack).' +
        '- Использование: Широко используется в Node.js для создания серверных приложений.\n' +
        '\n' +
        '### 3. UMD (Universal Module Definition)\n' +
        '\n' +
        '- Описание: UMD - это гибридное решение, которое поддерживает как CommonJS, так и AMD, что позволяет модулю работать в разных средах (как в браузере, так и на сервере).\n' +
        '- Преимущества:\n' +
        '- Совместимость с различными окружениями: может использоваться как в Node.js (или другой среде, поддерживающей CommonJS), так и в браузерах (с поддержкой AMD).\n' +
        '- Упрощает написание универсальных модулей.' +
        '- Использование: Удобно для библиотек, которые хотят быть использованы в разных средах.\n' +
        '\n' +
        '### Заключение\n' +
        '\n' +
        'Каждая из этих модульных систем имеет свои преимущества и области применения. CommonJS обычно используется на стороне сервера (например, в Node.js), AMD — на стороне клиента (в браузерах), а UMD позволяет разработчикам создавать универсальные модули, которые могут работать в обоих окружениях. В последние годы с развитием ES-модулей (ES6)' +
        ' разработчики начали использовать стандартные модули как новую альтернативу, которая обеспечивает лучшую совместимость и простоту использования.',
      active: false,
    },
    {
      question: 'Use strict? ',
      response:
        '«use strict» — это директива в JavaScript, которая включает строгий режим. Этот режим позволяет выбрать ограниченный вариант JavaScript, который помогает выявить типичные ошибки кодирования и «небезопасные» действия.\n' +
        '\n' +
        '### Ключевые особенности строгого режима:\n' +
        '\n' +
        '1. Устраняет «тихие» ошибки: в строгом режиме ошибки, которые в противном случае были бы проигнорированы, будут вызывать ошибку. Это помогает разработчикам выявлять проблемы на ранних этапах процесса разработки.\n' +
        '\n' +
        '2. Запрещает необъявленные переменные. Переменные должны быть объявлены с помощью let, const или var. Присвоение значения необъявленной переменной приведет к ошибке' +
        '3. Предотвращает дублирование имен параметров. Функции не могут иметь повторяющиеся имена параметров. Это помогает избежать двусмысленности в аргументах функции.' +
        'Запрещает эту привязку: в строгом режиме это не определено в функциях, которые вызываются без контекста (т. е. без явного вызывающего объекта). В нестрогом режиме по умолчанию это глобальный объект (в браузерах это окно).' +
        '5. Устраняет с помощью оператора: оператор with не допускается в строгом режиме. Это связано с тем, что это может затруднить понимание и поддержку кода.' +
        'Предотвращает использование определенных зарезервированных ключевых слов. Некоторые имена зарезервированы в строгом режиме, чтобы будущие версии JavaScript не могли использовать эти имена в качестве ключевых слов.\n' +
        '\n' +
        '### Как включить строгий режим:\n' +
        '\n' +
        '— Вы можете включить строгий режим, добавив «use strict» в начале скрипта или функции.ачем использовать строгий режим?\n' +
        '\n' +
        '- Предотвращение ошибок: помогает выявить распространенные ошибки и предотвратить потенциальные проблемы в вашем коде.\n' +
        '- Улучшена производительность: некоторые механизмы JavaScript могут лучше оптимизировать код в строгом режиме.\n' +
        '- Качество кода: способствует улучшению практики кодирования, делая ваш код более чистым и предсказуемым.',
      active: false,
    },
    {
      question: 'Что такое рекурсия и для чего используется?',
      response:
        'Рекурсия — это метод, при котором функция вызывает саму себя с целью решения задачи. В рекурсивном подходе задача разбивается на меньшие подзадачи, которые имеют ту же структуру, что и оригинальная проблема, и решаются последовательно. Каждый рекурсивный вызов стремится к достижению базового случая, который завершает рекурсию и возвращает результат.\n' +
        '\n' +
        '### Принципы рекурсии:\n' +
        '\n' +
        '1. Базовый случай (base case): Это условие, при котором рекурсия завершится. Базовый случай предотвращает бесконечные вызовы функции.\n' +
        '2. Рекурсивный случай (recursive case): Это часть кода, в которой функция вызывает саму себя с изменёнными аргументами, приближая её к базовому случаю.\n' +
        '\n' +
        '### Применение рекурсии:\n' +
        '\n' +
        '1. Решение задач на деление и завоевание: Многие алгоритмы, такие как сортировка слиянием и быстрая сортировка, используют рекурсию для разделения задач на более мелкие подзадачи.\n' +
        '2. Поиск и прохождение по структурам данных: Рекурсия часто используется для работы с деревьями и графами (например, для обхода узлов дерева в глубину).\n' +
        '3. Математические расчёты: Рекурсия применяется для вычисления чисел Фибоначчи, факториалов и других математических последовательностей.\n' +
        '4. Генерация комбинаций и перестановок: Рекурсивные функции могут использоваться для генерации всех возможных комбинаций и перестановок элементов в коллекциях.' +
        ' Преимущества рекурсии:\n' +
        '\n' +
        '- Структурированность: Рекурсия упрощает код, делая его более читабельным и понятным, особенно при работе со сложными структурами данных.\n' +
        '- Упрощение задач: Рекурсия позволяет разбить задачу на подзадачи, что делает её проще для понимания.\n' +
        '\n' +
        '### Недостатки рекурсии:\n' +
        '\n' +
        '- Производительность: Рекурсивные функции могут потреблять больше памяти и времени, так как каждый вызов функции добавляет новый кадр на стек вызовов.\n' +
        '- Глубина стека: Если рекурсия слишком глубока, это может привести к переполнению стека (stack overflow). В таких случаях можно рассмотреть использование итеративных подходов.',
      active: false,
    },
    {
      question: 'Что такое замыкания и для чего они используются? ',
      response:
        'Замыкание — это функция, которая "запоминает" окружающий её контекст (лексическую область видимости), даже после того, как функция была вызвана вне этого контекста. Замыкания позволяют функции иметь доступ к внешним переменным, даже если они находятся вне её текущего контекста выполнения. В JavaScript замыкания создаются всякий раз, когда функция создаётся внутри другой функции.\n' +
        '\n' +
        '### Принципы замыкания:\n' +
        '\n' +
        '1. Лексическая область видимости: В JavaScript функции создают новую область видимости. Замыкания позволяют доступ к переменным из внешней функции, даже после завершения её выполнения.\n' +
        '2. Сохранение состояния: Замыкание можно использовать для хранения состояния, которое доступно только при помощи определённого интерфейса.\n' +
        'Применение замыканий:\n' +
        '\n' +
        '1. Инкапсуляция данных: Замыкания позволяют скрывать переменные, избегая их глобального доступа. Это помогает создавать защищённые компоненты или модули.\n' +
        '2. Функции-генераторы: Замыкания можно использовать для создания функций, которые хранят и возвращают состояния между вызовами.\n' +
        '3. Кэширование результатов: При помощи замыканий можно создать функции, которые запоминают результаты предыдущих вычислений для оптимизации.\n' +
        '4. Обработка событий: Замыкания помогают захватывать контекст во время работы с обработчиками событий, сохраняя доступ к переменным.' +
        'Преимущества замыканий:\n' +
        '\n' +
        '- Скрытие реализации: Переменные могут быть скрыты от внешнего доступа, предоставляя только определённый интерфейс.\n' +
        '- Динамическое создание функций: Замыкания позволяют создавать функции на лету с сохранением контекста, что удобно для обработки данных.\n' +
        '\n' +
        '### Недостатки замыканий:\n' +
        '\n' +
        '- Потребление памяти: Из-за сохранённых ссылок на внешние переменные замыкания могут потреблять больше памяти, чем ожидается, что может привести к утечкам памяти, если они не освобождаются.\n' +
        '- Сложность отладки: Замыкания могут усложнить понимание логики программы, если используются неаккуратно, что делает код менее',
      active: false,
    },
    {
      question: 'Блочная видимость переменных ',
      response:
        'Блочная видимость переменных в JavaScript относится к области видимости, которая ограничена определённым блоком кода, например, внутри фигурных скобок {}. С введением ключевых слов let и const в ES6 (ECMAScript 2015) была добавлена поддержка блочной видимости, которая отличается от функциональной и глобальной видимости, используемой с ключевым словом var.\n' +
        '\n' +
        '### Основные аспекты блочной видимости:\n' +
        '\n' +
        '1. Определение блочной видимости:\n' +
        '- Переменные, объявленные с помощью let или const внутри блока ({}), доступны только внутри этого блока. Попытка обратиться к таким переменным вне их блока вызовет ошибку ReferenceError.' +
        '2. Область видимости:\n' +
        '- Если переменная объявлена с помощью var, она имеет функциональную или глобальную видимость, что означает, что она доступна не только внутри блока, но и вне его, если используется внутри функции.\n' +
        '3. Переопределение переменных:\n' +
        '- Внутри одного и того же блока переменные с одинаковыми именами, объявленные с let или const, не могут быть повторно объявлены. Это позволяет избежать конфликтов переменных.' +
        '4. Циклы и блочная видимость:\n' +
        '- При использовании переменных, объявленных с let или const, внутри циклов, таких как for, каждая итерация цикла создаёт новую область видимости. Это позволяет избежать общих проблем с замыканиями в циклах.\n' +
        'С var код показал бы 5, поскольку var не создаёт блоковых областей видимости.\n' +
        '\n' +
        '### Применение блочной видимости:\n' +
        '\n' +
        '- Избегание конфликтов переменных: Блочная видимость помогает локализовать переменные и предотвращать их конфликты, особенно в больших кодовых базах или при использовании библиотек.\n' +
        '- Ясность и читаемость кода: Использование let и const способствует более чёткой структуре кода, облегчая понимание того, где переменные могут использоваться и изменяться.\n' +
        '- Сохранение состояния: Замыкания, использующие блочную видимость, полезны для сохранения состояния в функциях и использования переменных в пределах ограниченного контекста.',
      active: false,
    },
    {
      question: 'Что такое лексическое окружение? ',
      response:
        'Лексическое окружение (или лексическая область видимости) — это концепция в JavaScript (и в других языках программирования), которая определяет, как и где функции имеют доступ к переменным. Лексическое окружение создаётся всякий раз, когда создаётся контекст исполнения, и оно хранит ссылки на переменные, доступные в момент создания функции. Эта концепция важна для понимания работы замыканий и области видимости переменных.\n' +
        '\n' +
        '### Структура лексического окружения\n' +
        '\n' +
        'Каждое лексическое окружение состоит из двух компонентов:\n' +
        '\n' +
        '1. Объект состояния (environment record): Этот объект содержит все переменные и функции, доступные в данной области видимости. В случае функции это будут локальные переменные и параметры.\n' +
        '2. Ссылка на внешнее окружение: Это ссылка на лексическое окружение, в котором была создана текущая функция. Эта ссылка позволяет функциям иметь доступ к переменным из внешних областей видимости.\n' +
        'Использование лексического окружения\n' +
        '\n' +
        '- Замыкания: Лексическое окружение позволяет создавать замыкания, которые сохраняют доступ к внешним переменным даже после завершения их функции-родителя. Это является основой многих паттернов программирования в JavaScript, включая инкапсуляцию данных и функции-генераторы.\n' +
        '\n' +
        '- Область видимости: Понимание лексического окружения помогает объяснить, как работает область видимости переменных, когда мы используем различные способы объявления (например, var, let, const).',
      active: false,
    },
    {
      question: 'Чем отличается push от unshift? Какой из них быстрее?',
      response:
        ' В большинстве случаев push будет быстрее, чем unshift, особенно для больших массивов. Это связано с тем, что push добавляет элементы в конец массива, что обычно требует меньше операций с памятью,' +
        ' чем unshift, который может потребовать перемещения всех существующих элементов в массиве, чтобы освободить место в начале.',
      active: false,
    },
    {
      question: 'Отличия function expression и function declaration ',
      response:
        '\n' +
        '### 2. Подъем (Hoisting)\n' +
        '\n' +
        '- Function Declaration:\n' +
        '- Объявления функций поднимаются в коде, что означает, что вы можете вызывать функцию до того, как она была объявлена.' +
        '- Function Expression:\n' +
        '- Функциональные выражения не поднимаются. Если вы попытаетесь вызвать функцию, определённую как выражение, до её объявления, вы получите ошибку.' +
        '3. Область видимости\n' +
        '\n' +
        '- Function Declaration:\n' +
        '- Объявление функции создаёт функцию, доступную в области видимости, в которой оно было определено. Если объявление функции находится внутри другого блока, то функция будет доступна в пределах этого блока.\n' +
        '\n' +
        '- Function Expression:\n' +
        '- Выражение функции обычно используется для создания анонимных функций или функций, присваиваемых переменным. Если функция присваивается переменной, она доступна в пределах этой переменной.\n' +
        '\n' +
        '### 4. Анонимные функции\n' +
        '\n' +
        '- Function Expression:\n' +
        '- Позволяет создавать анонимные функции, которые не имеют имени.' +
        ' Function Declaration:\n' +
        '- Не поддерживает создание анонимных функций. Имя функции всегда должно быть указано.\n' +
        '\n' +
        '### 5. Использование в контексте\n' +
        '\n' +
        '- Function Declaration:\n' +
        '- Часто используется для определения функций, которые будут вызываться в разных местах программы, координируя поведение.\n' +
        '\n' +
        '- Function Expression:\n' +
        '- Часто применяется, когда функцией можно передать как аргумент, например, в методах массивов (например, map, filter), при создании коллбеков.\n',
      active: false,
    },
    {
      question: 'try/catch и finally? ',
      response:
        'В JavaScript блоки try, catch, и finally служат для обработки исключений и управления ошибками в коде. Позволяют вам обрабатывать ошибки и гарантируют выполнение определенного кода, независимо от того, возникли ли ошибки или нет. Давайте подробнее рассмотрим их назначение и синтаксис.\n' +
        '\n' +
        '### 1. Блок try\n' +
        '- Описание: Блок try содержит код, который может вызвать исключение. Если в этом блоке происходит ошибка, выполнение переходит к блоку catch.' +
        '2. Блок catch\n' +
        '- Описание: Блок catch используется для обработки исключений, которые могут возникнуть в блоке try. Он принимает аргумент, который обычно используется для доступа к объекту ошибки.' +
        '3. Блок finally\n' +
        '- Описание: Блок finally выполняется после блоков try и catch, независимо от того, произошла ошибка или нет. Это полезно для выполнения завершающих операций, таких как освобождение ресурсов (например, закрытие файлов, соединений и т.д.).' +
        'Важные моменты\n' +
        '1. Обработка ошибок: Использование блоков try и catch позволяет управлять ошибками без остановки выполнения всего скрипта. Это особенно полезно в случаях, когда ошибки могут возникать из-за внешних факторов (например, сетевые запросы).\n' +
        '\n' +
        '2. Гарантия выполнения: Блок finally гарантирует выполнение кода, даже если в блоке try происходит ошибка или если код завершает выполнение с помощью return или throw.\n' +
        '\n' +
        '3. Отсутствие необходимости: Блоки catch и finally не являются обязательными. Вы можете использовать блок try без блока catch и только с блоком finally',
      active: false,
    },
    {
      question:
        'Что такое всплытие в JavaScript? Погружение событий? (бамблинг)\n',
      response:
        'В JavaScript обработка событий включает две основные концепции: *всплытие* (event bubbling) и *погружение* (event capturing). Оба этих механизма связаны с тем, как события распространяются через иерархию DOM (Document Object Model).\n' +
        '\n' +
        '### 1. Всплытие событий (Event Bubbling)\n' +
        '\n' +
        '*Всплытие* – это механизм, при котором событие начинается от целевого элемента и постепенно "всплывает" вверх' +
        ' по иерархии DOM, вызывая обработчики событий у родительских элементов.' +
        '2. Погружение событий (Event Capturing)\n' +
        '\n' +
        '*Погружение* – это противоположный механизм, при котором событие сначала "погружается" вниз, начиная с самого верхнего элемента и проходя через все родительские элементы, пока не достигнет целевого элемента.\n' +
        '\n' +
        '- В JavaScript это поведение не является стандартным, но его можно активировать при добавлении обработчика события, указав третий аргумент true или передав объект с capture: true.' +
        'Принцип работы событий\n' +
        '\n' +
        '1. Сначала происходит погружение (если установлено): Обработчики событий на родительских элементах запускаются перед обработчиком на целевом элементе.\n' +
        '2. Целевой элемент: Обработчик на целевом элементе запускается.\n' +
        '3. Всплытие: Сначала обрабатываются события на целевом элементе, затем события на его родительских элементах по порядку.',
      active: false,
    },
    {
      question: 'Что нового принес последний стандарт ES? (сейчас ES9)\n',
      response:
        'Стандарт ECMAScript 2018, также известный как ES9, был выпущен в июне 2018 года и внёс несколько интересных новых возможностей в JavaScript. Вот основные новшества, которые были добавлены в ES9:\n' +
        '\n' +
        '### 1. Rest/Spread Properties\n' +
        '- В ES9 были добавлены возможности для использования rest и spread операторов с объектами.\n' +
        '- Spread позволяет вам копировать, объединять или расширять объекты.\n' +
        '- Rest позволяет собирать оставшиеся свойства объекта в новый объект.' +
        '2. Asynchronous Iteration\n' +
        '- ES9 добавил возможность использовать синтаксис for await...of для работы с асинхронными итераторами. Это позволяет итерировать по объектам, которые используют AsyncIterable.' +
        '3. Promise.prototype.finally()\n' +
        '- Метод finally() для объектов Promise был добавлен, что позволяет вам обеспечить выполнение кода после завершения промиса, независимо от того, был ли он выполнен успешно или завершился с ошибкой.' +
        '4. Пробелы между символами в регулярных выражениях (s Flag)\n' +
        '- Новый флаг s (dotAll) позволяет методу . в регулярных выражениях соответствовать символам новой строки.' +
        '5. Обновления в JSON.stringify\n' +
        '- В ES9 была улучшена поддержка указания функций для сериализации объектов, что повышает гибкость работы с JSON.stringify.\n' +
        '\n' +
        '### 6. Обработка ошибок с try/catch без указания переменной\n' +
        '- Можно использовать try/catch без указания переменной для ошибки',
      active: false,
    },
    {
      question:
        'В чем суть стрелочной функции? Ее отличия от обычной функции? ',
      response:
        '1. Лексическое this' +
        '- Стрелочные функции:\n' +
        '- Не имеют своего собственного значения this. Вместо этого они унаследуют значение this от родительского контекста, в котором ' +
        'они были определены. Это особенно полезно, когда вы используете функции обратного вызова (callback functions).\n' +
        '- Обычные функции:\n' +
        '- Имеют свое собственное значение this, которое зависит от того, как функция была вызвана.' +
        '2. Использование arguments\n' +
        '- Стрелочные функции:\n' +
        '- Не имеют своего собственного объекта arguments. Вместо этого, если вам нужно обратиться к аргументам, вы должны использовать параметры функции или остальную часть оператора (...args).' +
        ' Обычные функции:\n' +
        '- Имеют собственный объект arguments, который позволяет получить доступ ко всем переданным аргументам.' +
        '3.Не могут быть конструкторами\n' +
        '- Стрелочные функции:\n' +
        '- Нельзя использовать в качестве конструктора — они не поддерживают new, и попытка сделать так вызовет ошибку.' +
        ' Обычные функции:\n' +
        '- Можно использовать в качестве конструктора и создавать экземпляры с помощью new.' +
        ' 4. Нет super и this\n' +
        '- Стрелочные функции:\n' +
        '- Не могут использоваться в методах классов для вызова родительских методов, потому что они не имеют собственного контекста.\n' +
        '- Если вам нужно использовать super, лучше воспользоваться обычной функцией.\n' +
        '\n' +
        '### 5. Синтаксис\n' +
        '- Стрелочные функции часто имеют менее громоздкий синтаксис. Если функция принимает один аргумент, скобки можно опустить' +
        '- Для обычных функций необходимо указывать скобки, даже если аргумент один.',
      active: false,
    },
    {
      question: 'Spread/rest операторы? ',
      response:
        'Spread и Rest операторы в JavaScript имеют схожий синтаксис, но служат разным целям. Они оба обозначаются тремя точками (...). Давайте рассмотрим их более подробно.\n' +
        '\n' +
        '### Spread оператор (оператор распространения)\n' +
        '\n' +
        'Spread оператор используется для "распространения" элементов массива или объекта на более глубокий уровень. Это позволяет вам развернуть массив или объект, чтобы использовать их элементы или свойства в другом контексте.' +
        '1. Слияние массивов:\n' +
        '\n' +
        '   const array1 = [1, 2, 3];\n' +
        '   const array2 = [4, 5, 6];\n' +
        '   const newArray = [...array1, ...array2]; // [1, 2, 3, 4, 5, 6]\n' +
        '\n' +
        '\n' +
        '2. Копирование массива:\n' +
        '\n' +
        '   const originalArray = [1, 2, 3];\n' +
        '   const copiedArray = [...originalArray]; // [1, 2, 3]\n' +
        '\n' +
        '\n' +
        '3. Передача аргументов в функции:\n' +
        '\n' +
        '   const numbers = [1, 2, 3];\n' +
        '   const max = Math.max(...numbers); // 3\n' +
        '\n' +
        '\n' +
        '4. Копирование объектов:\n' +
        '\n' +
        '   const obj1 = { a: 1, b: 2 };\n' +
        '   const obj2 = { ...obj1, c: 3 }; // { a: 1, b: 2, c: 3 }\n' +
        '\n' +
        '\n' +
        '5. Объединение объектов:\n' +
        '\n' +
        '   const objA = { a: 1, b: 2 };\n' +
        '   const objB = { b: 3, c: 4 };\n' +
        '   const merged = { ...objA, ...objB }; // { a: 1, b: 3, c: 4 }\n' +
        '\n' +
        '\n' +
        '### Rest оператор (оператор остатка)\n' +
        '\n' +
        'Rest оператор позволяет собирать оставшиеся параметры функции в массив. Это полезно, когда вы не знаете заранее, сколько аргументов будет передано функции.' +
        '1. Сбор аргументов в функцию:\n' +
        '\n' +
        '   function sum(...args) {\n' +
        '       return args.reduce((a, b) => a + b, 0);\n' +
        '   }\n' +
        '   console.log(sum(1, 2, 3, 4)); // 10\n' +
        '\n' +
        '\n' +
        '2. Сбор остальных параметров при деструктуризации:\n' +
        '\n' +
        "   const person = { name: 'Alice', age: 25, location: 'Wonderland' };\n" +
        "   const { name, ...rest } = person; // name = 'Alice', rest = { age: 25, location: 'Wonderland' }\n" +
        '\n' +
        '\n' +
        '3. Использование в методах классов:\n' +
        '\n' +
        '   class Numbers {\n' +
        '       constructor(...numbers) {\n' +
        '           this.numbers = numbers;\n' +
        '       }\n' +
        '   }\n' +
        '   const myNumbers = new Numbers(1, 2, 3, 4, 5); // numbers = [1, 2, 3, 4, 5]' +
        'Заключение\n' +
        '\n' +
        '- Spread оператор (...) используется для развертывания элементов массивов и объектных свойств.\n' +
        '- Rest оператор (...) позволяет собрать несколько аргументов функции в массив, а также используется в деструктуризации для сбора оставшихся свойств объекта.\n' +
        '\n' +
        'Оба оператора значительно упрощают работу с массивами и объектами в JavaScript, делая код более лаконичным и понятным',
      active: false,
    },
    {
      question: 'Деструктивное присваивание? (...arguments)',
      response:
        'Деструктивное присваивание (или деструктуризация) — это удобная синтаксическая конструкция в JavaScript, добавленная в ES6 (ECMAScript 2015), которая позволяет извлекать значения из массивов или объектов и присваивать их переменным. Это упрощает процесс работы с данными и делает код более читабельным.\n' +
        '\n' +
        '### Деструктивное присваивание массивов\n' +
        '\n' +
        'С помощью деструктивного присваивания можно извлекать элементы из массива' +
        'const arr = [1, 2, 3, 4, 5];\n' +
        'const [first, second] = arr;' +
        '### Деструктивное присваивание объектов\n' +
        '\n' +
        'Для объектов деструктивное присваивание используется несколько иначе:\n' +
        '\n' +
        '\n' +
        "const obj = { name: 'Alice', age: 25 };\n" +
        'const { name, age } = obj;\n' +
        '\n' +
        "console.log(name); // 'Alice'\n" +
        'console.log(age); // 25' +
        'ы также можете переименовывать переменные:\n' +
        '\n' +
        '\n' +
        "const obj = { name: 'Alice', age: 25 };\n" +
        'const { name: userName, age: userAge } = obj;\n' +
        '\n' +
        "console.log(userName); // 'Alice'\n" +
        'console.log(userAge); // 25' +
        'Использование с остальными параметрами (...arguments)\n' +
        '\n' +
        'Остальные параметры (Rest parameters) в сочетании с деструктивным присваиванием позволяют собирать оставшиеся элементы массива или объектные свойства в отдельную переменную.\n' +
        ' Преимущества деструктивного присваивания\n' +
        '\n' +
        '1. Читаемость: Код становится более понятным и компактным.\n' +
        '2. Удобство: Упрощает извлечение данных из массивов и объектов, особенно если у вас много значений для извлечения.\n' +
        '3. Переименование и пропуск: Позволяет переименовывать переменные и пропускать не нужные элементы без дополнительных строк кода.',
      active: false,
    },
    {
      question: 'Иммутабельность, что это и для чего нужна?',
      response:
        'Иммутабельность (или неизменяемость) — это принцип в программировании, который подразумевает, что после создания объекта его состояние не может быть изменено. Вместо этого, всякий раз, когда требуется изменить объект, создается новый объект с необходимыми изменениями, оставляя оригинал без изменений.\n' +
        '\n' +
        '### Зачем нужна иммутабельность?\n' +
        '\n' +
        '1. Состояние и предсказуемость:\n' +
        '- Иммутабельные объекты делают состояние приложения более предсказуемым. Если вы знаете, что объект не изменится, вы можете быть уверены в его значении в любой момент времени. Это упрощает отслеживание изменений и отладку кода.\n' +
        '\n' +
        '2. Избежание побочных эффектов:\n' +
        '- При изменения объектов могут возникать непредвиденные побочные эффекты. Иммутабельность помогает избежать ситуации, когда одна часть кода изменяет объект, который затем используется в другой части кода, что может привести к трудным для понимания ошибкам.\n' +
        '\n' +
        '3. Улучшение производительности:\n' +
        '- В некоторых случаях иммутабельные структуры данных могут быть оптимизированы для более быстрого доступа и сравнения. Например, библиотеки, использующие иммутабельные объекты (такие как Immer), могут эффективно использовать изменения и минимизировать количество операций обновления.\n' +
        '\n' +
        '4. Упрощение работы с состоянием в реактивных библиотеках:\n' +
        '- Во многих современных библиотеках и фреймворках, таких как React, Redux, Vue, иммутабельность является важным аспектом. Заслуживает внимания тот факт, что изменения состояния можно легко отслеживать через сравнение старого и нового состояния, что позволяет упростить процесс рендеринга компонент.\n' +
        'Иммутабельные библиотеки\n' +
        '\n' +
        'Существуют специальные библиотеки, которые помогают работать с иммутабельными структурами данных, например:\n' +
        '- Immutable.js: Предоставляет иммутабельные структуры данных, такие как списки, карты и множества.\n' +
        '- Immer: Позволяет писать иммутабельные обновления в более удобном и понятном стиле, реализуя концепцию "промисканных" изменений.\n' +
        '\n' +
        '### Заключение\n' +
        '\n' +
        'Иммутабельность — это мощный подход к программированию, который помогает делать код более предсказуемым, безопасным и удобным для обслуживания. Она полезна в большинстве случаев, особенно в функциональных языках программирования и при работе с современными JavaScript-библиотеками и фреймворками.',
      active: false,
    },
    {
      question: 'WebRTC ',
      response:
        'WebRTC (Web Real-Time Communication) — это открытая технология, позволяющая осуществлять реальное время передачи аудио, видео и данных между браузерами и мобильными приложениями без необходимости установки плагинов или дополнительных программ. Она была разработана с целью упрощения создания приложений для видеозвонков, обмена данными и других видов коммуникации в реальном времени.\n' +
        '\n' +
        '### Основные компоненты WebRTC\n' +
        '\n' +
        '1. MediaStream:\n' +
        '- Позволяет захватывать аудио и видео с устройств пользователя (например, веб-камеры и микрофона) и передавать эти потоки в реальном времени.\n' +
        '\n' +
        '2. RTCPeerConnection:\n' +
        '- Основной компонент для установления соединения между двумя клиентами. Он управляет потоками медиа и данными, а также обеспечивает сетевые взаимодействия, такие как NAT traversal.\n' +
        '\n' +
        '3. RTCDataChannel:\n' +
        '- Используется для обмена произвольными данными между клиентами. Это может быть полезно для приложений, которые требуют совместной работы, например, игры или обмен файлами.\n' +
        '\n' +
        '### Принципы работы WebRTC\n' +
        '\n' +
        '1. Сигнализация:\n' +
        '- Для установления соединения между двумя пассажирами необходимо обменяться данными о состоянии соединения, называемыми "сигнализацией". Это может включать информацию о сетевых условиях и кодеках. Сигнализация обычно выполняется с использованием таких технологий, как WebSocket или HTTP.\n' +
        '\n' +
        '2. Наттраверс (NAT Traversal):\n' +
        '- WebRTC использует различные протоколы, такие как STUN и TURN, для решения проблемы NAT-траверсинга, позволяя клиентам соединяться друг с другом, даже если они находятся за роутерами или межсетевыми экранами.\n' +
        '\n' +
        '3. Кодеки:\n' +
        '- WebRTC поддерживает современные кодеки для сжатия аудио и видео, такие как VP8, VP9 и Opus. Это помогает оптимизировать качество передачи и уменьшить задержки.\n' +
        '\n' +
        '### Применения WebRTC\n' +
        '\n' +
        '1. Видеозвонки и аудиозвонки:\n' +
        '- Приложения для видеоконференций, как Zoom, Google Meet и Skype, могут использовать WebRTC для прямой передачи медиа.\n' +
        '\n' +
        '2. Обмен данными:\n' +
        '- WebRTC позволяет обмениваться данными между пользователями, что полезно для приложений, таких как файловые обменники и онлайн-игры.\n' +
        '\n' +
        '3. Live Streaming:\n' +
        '- WebRTC идеален для потоковой передачи, так как обеспечивает минимальные задержки и высокое качество картинки и звука.\n' +
        '\n' +
        '4. Совместная работа:\n' +
        '- WebRTC может быть использован в приложениях для совместной работы, таких как Google Docs, где пользователи могут в реальном времени редактировать документы и видеть изменения других пользователей.\n' +
        '\n' +
        '### Преимущества WebRTC\n' +
        '\n' +
        '- Простота использования: Веб-разработчики могут легко интегрировать технологию в свои приложения, используя доступные API.\n' +
        '- Открытая спецификация: WebRTC является открытым проектом, что позволяет разработчикам использовать его без лицензий и дополнительных затрат.\n' +
        '- Безопасность: WebRTC поддерживает шифрование на уровне протоколов (SRTP и DTLS), что обеспечивает высокий уровень безопасности передачи данных.',
      active: false,
    },
    {
      question:
        'Где можно сохранить какие либо данные в браузере? Слышали и работали ли вы с\n' +
        'indexedDB?  ',
      response:
        'В браузере существует несколько способов для хранения данных. Ниже перечислены основные из них:\n' +
        '\n' +
        '### 1. Local Storage\n' +
        '- Описание: Local Storage позволяет сохранять небольшие объемы данных в формате ключ-значение в веб-браузере. Данные сохраняются даже после закрытия вкладки или браузера.\n' +
        '- Объем: Ограничен до 5-10 МБ, в зависимости от браузера.\n' +
        '- Простой доступ: Можно легко получить доступ к данным с помощью JavaScript' +
        '2. Session Storage\n' +
        '- Описание: Session Storage аналогичен Local Storage, но данные хранятся только в рамках текущей сессии. Как только вкладка или браузер закрывается, данные удаляются.\n' +
        '- Объем: Также ограничен до 5-10 МБ.' +
        '3. Cookies\n' +
        '- Описание: Cookies могут хранить небольшие объемы данных и используют их для управления сессиями и хранения информации о пользователе.\n' +
        '- Объем: Ограничен до 4 КБ на одно значение, и в браузере можно хранить до 50-100 cookies.\n' +
        '- Срок хранения: Cookies могут иметь срок окончания, после которого они будут удалены.' +
        '4. IndexedDB\n' +
        '- Описание: IndexedDB — это более мощное хранилище, которое позволяет сохранять большие объемы структурированных данных, включая файловые блочные объекты. Это асинхронная база данных, которая позволяет осуществлять сложные запросы.\n' +
        '- Объем: Зависит от браузера и доступного места на диске, обычно значительно больше, чем Local Storage или Cookies.\n' +
        '- Асинхронный доступ: Использует промисы или колбэки для доступа к данным.',
      active: false,
    },
    {
      question:
        'Чем localStorage отличается от sessionStorage, cookieStorage? В чём преимущества?',
      response:
        'Local Storage, Session Storage и Cookies — это три различных метода хранения данных в браузере, каждый из которых имеет свои особенности, преимущества и области применения. Давайте рассмотрим их более подробно.\n' +
        '\n' +
        '### Основные отличия\n' +
        '\n' +
        '#### 1. Local Storage\n' +
        '- Описание: Local Storage хранит данные в формате ключ-значение и сохраняет их без ограничения по времени. Данные остаются даже после закрытия браузера или вкладки.\n' +
        '- Объем: Обычно ограничен до 5-10 МБ (в зависимости от браузера).\n' +
        '- Доступ: Доступен для всех вкладок/окен одного домена.\n' +
        '- Применение: Подходит для хранения данных, которые необходимо использовать длительное время (например, настройки пользователя, токены аутентификации и т. д.).\n' +
        '\n' +
        '#### 2. Session Storage\n' +
        '- Описание: Session Storage также хранит данные в формате ключ-значение, но эти данные существуют только в течение сессии вкладки. При закрытии вкладки данные удаляются.\n' +
        '- Объем: Так же ограничен до 5-10 МБ.\n' +
        '- Доступ: Доступен только для текущей вкладки; если открыть новую вкладку, доступ к данным уже не будет возможен.\n' +
        '- Применение: Удобен для хранения временной информации, например, состояния формы, временные токены или данные, которые не нужно сохранять после закрытия вкладки.\n' +
        '\n' +
        '#### 3. Cookies\n' +
        '- Описание: Cookies представляют собой небольшие текстовые файлы, которые хранятся на стороне клиента и могут содержать данные в формате ключ-значение. Cookies могут иметь срок действия и могут быть настроены для отправки на сервер с каждым запросом.\n' +
        '- Объем: Ограничен до 4 КБ на одно значение, можно хранить 50-100 cookies на домен.\n' +
        '- Срок хранения: Cookies могут иметь указанный срок действия, после чего они удаляются автоматически.\n' +
        '- Применение: Часто используется для управления сессиями, отслеживания пользователей и работы с аутентификацией.\n' +
        '\n' +
        '### Преимущества каждого метода\n' +
        '\n' +
        '#### Local StorageПреимущества:\n' +
        '- Данные сохраняются между сессиями и могут быть легко получены из любых вкладок.\n' +
        '- Простота использования: API Local Storage прост и понятен.\n' +
        '- Более крупный объем для хранения по сравнению с cookies.\n' +
        '\n' +
        '#### Session Storage\n' +
        '- Преимущества:\n' +
        '- Идеален для временных данных: хранит данные только до закрытия вкладки, что делает его отличным выбором для данных, которые не должны сохраняться.\n' +
        '- Изоляция данных: данные из разных вкладок не могут быть случайно перезаписаны.\n' +
        '\n' +
        '#### Cookies\n' +
        '- Преимущества:\n' +
        '- Поддержка сервера: Cookies автоматически отправляются на сервер с каждым HTTP-запросом, что делает их полезными для аутентификации и отслеживания сессий.\n' +
        '- Возрастающая поддержка: Удобны для работы с обработкой данных на стороне сервера и для управления сессиями.',
      active: false,
    },
    {
      question:
        'Можно ли в js вызвать функцию до ее объявления? Как это работает?',
      response:
        'Да, в JavaScript можно вызвать функцию до ее объявления, и это возможно благодаря механизму, известному как "подъем" (hoisting).' +
        'Подъем (Hoisting)\n' +
        '\n' +
        'Hoisting — это механизм, при котором объявления функций и переменных поднимаются на верхнюю часть своей области видимости (scope) в момент компиляции, а не выполнения. Это означает, что JavaScript сначала обрабатывает все объявления, а потом выполняет код.\n' +
        'Однако если вы используете функциональное выражение (или стрелочную функцию), то позиция объявления имеет значение. Вот пример с функциональным выражением:\n' +
        '\n' +
        '\n' +
        '// Вызов функционального выражения до его объявления\n' +
        'sayHello(); // TypeError: sayHello is not a function\n' +
        '\n' +
        'var sayHello = function() {\n' +
        '    console.log("Hello, World!");\n' +
        '};' +
        'В этом случае код выдаст ошибку TypeError, потому что переменная sayHello поднимается, но самой функции присвоено значение только после ее объявления. На момент вызова sayHello() она еще не определена как функция, и её значение равно undefined.\n' +
        'Стрелочные функции также поднимаются, как и обычные функции, но поскольку они являются выражениями, они должны быть объявлены до их вызова' +
        'Таким образом, в JavaScript можно вызвать функции до их объявления, если они были объявлены как функциональные декларации. Однако, если функция объявлена как функциональное выражение или стрелочная функция, вызов до их объявления приведет к ошибке, так как переменная будет подниматься, но не инициализироваться до момента её выполнения.',
      active: false,
    },
    {
      question: 'Расскажите об Object.create() ',
      response:
        ' Object.create() — это метод в JavaScript, который используется для создания нового объекта, используя другой объект в качестве прототипа. Это позволяет создавать объекты и наследовать свойства и методы от другого объекта.' +
        'Синтаксис\n' +
        'Object.create(prototype, propertiesObject);\n' +
        '\n' +
        '- prototype: Объект, который будет использован в качестве прототипа для создаваемого объекта.\n' +
        '- propertiesObject (необязательный): Это объект, который может содержать дополнительные свойства, которые будут добавлены к создаваемому объекту.\n' +
        'Преимущества использования Object.create()\n' +
        '\n' +
        '1. Упрощенное наследование: Этот метод позволяет создавать объекты и наследовать их методы и свойства, что упрощает реализацию прототипного наследования.\n' +
        '2. Настройка свойств: Вы можете определить, какие свойства должны быть доступны при создании объекта, например, являются ли они записываемыми, перечисляемыми и удаляемыми.\n' +
        '3. Гибкость: Вы можете создать новый объект на основе существующего объекта, модифицируя или добавляя новые свойства, не затрагивая сам прототип.\n',
      active: false,
    },
    {
      question:
        'Чем отличается спрэд-оператор от Object.assign? Как быть, если браузер не\n' +
        'поддерживает спрэд-оператор? ',
      response:
        'Спрэд-оператор (...) и метод Object.assign() являются способами копирования и комбинирования объектов в JavaScript, однако у них есть важные отличия в поведении и способах использования. Рассмотрим их подробно:\n' +
        '\n' +
        '### Спрэд-оператор (...)\n' +
        '\n' +
        '1. Использование:\n' +
        'Спрэд-оператор позволяет "разворачивать" объекты (или массивы) и создавать новый объект с помощью указанного объекта.' +
        '2. Копирование:\n' +
        'Спрэд-оператор делает поверхностную копию объектов. Если вы копируете объект с вложенными объектами, ссылки на вложенные объекты сохраняются:' +
        '3. Неподдерживаемые свойства:\n' +
        'Спрэд-оператор не может быть использован с null или undefined.\n' +
        '\n' +
        '### Object.assign()\n' +
        '\n' +
        '1. Использование:\n' +
        'Object.assign() принимает целевой объект и один или несколько исходных объектов, и копирует все перечисляемые свойства исходных объектов в целевой объект.' +
        '\n' +
        '2. Копирование:\n' +
        'Как и спрэд-оператор, Object.assign() делает поверхностную копию. То есть, если в одном объекте есть вложенные объекты, ссылки будут сохраняться' +
        '3. Проблемы с целевым объектом:\n' +
        'Object.assign() изменяет целевой объект. Если вы укажете существующий объект в качестве целевого, он будет модифицироваться.\n' +
        '\n' +
        '### Что делать, если браузер не поддерживает спрэд-оператор\n' +
        '\n' +
        'Если в вашем окружении требуется поддержка старых браузеров, которые не поддерживают спрэд-оператор, вы можете использовать Object.assign() как альтернативу, или воспользоваться другим подходом, как, например, использование библиотек, таких как Lodash.' +
        'Спрэд-оператор и Object.assign() имеют много общего, но важно понимать их различия и предпочитаемые сценарии использования. Если возникнет необходимость в поддержке старых браузеров, использование Object.assign() будет хорошим решением, но помните о необходимости проверки на наличие вложенных объектов при выполнении копирования.',
      active: false,
    },
    {
      question: 'Различия var, const и let? ',
      response:
        'В JavaScript, var, let и const — это ключевые слова, используемые для объявления переменных. Вот основные различия между ними:\n' +
        '\n' +
        '### 1. Область видимости (Scope)\n' +
        '\n' +
        '- var:\n' +
        '- Имеет функциональную или глобальную область видимости.\n' +
        '- Переменные, объявленные с помощью var, доступны внутри функции, в которой они объявлены, или глобально, если они объявлены вне функции.\n' +
        '- let:\n' +
        '- Имеет блочную область видимости.\n' +
        '- Переменные, объявленные с помощью let, доступны только в том блоке (например, в операторе if, for, и т.д.), где они были объявлены.\n' +
        '\n' +
        '- const:\n' +
        '- Также имеет блочную область видимости.\n' +
        '- Точно так же, как и let, переменные, объявленные через const, доступны только в том блоке, где они определены.' +
        '2. Переназначение (Reassignment)\n' +
        '\n' +
        '- var:\n' +
        '- Разрешает переназначение значения.' +
        '- let:\n' +
        '- Разрешает переназначение значения.' +
        '- const:\n' +
        '- Не позволяет переназначение значения после его первоначального назначения. Однако, если значение — это объект, вы можете изменять его свойства.' +
        '3. Инициализация\n' +
        '\n' +
        '- var:\n' +
        '- Может быть объявлен без инициализации (т.е. без значения), и его значение по умолчанию будет undefined.' +
        '\n' +
        '- let:\n' +
        '- Также может быть объявлен без инициализации, с тем же результатом — значение будет undefined.\n' +
        '\n' +
        '- const:\n' +
        '- Обязательно требует инициализации при объявлении.\n' +
        '4. Дерево всплытия (Hoisting)\n' +
        '\n' +
        '- var:\n' +
        '- Объявления переменных с использованием var "всплывают" (hoisted) в верхнюю область видимости функции, но инициализация происходит на месте определения.' +
        ' let и const:\n' +
        '- Также "всплывают", но не могут быть использованы до их объявления в коде (вызовет ReferenceError).' +
        '- Используйте var, если вам нужна глобальная или функциональная область видимости (но лучше избегать его использования в современном JavaScript).\n' +
        '- Используйте let, если вам нужно изменить значение переменной и область видимости — это блок.\n' +
        '- Используйте const, если значение не должно изменяться и если вы хотите объявить константу в блочной области видимости.',
      active: false,
    },
    {
      question: 'Prototype ',
      response:
        'Прототип — это один из основных механизмов наследования в JavaScript. Он позволяет объектам делиться свойствами и методами' +
        ' друг с другом. Давайте подробнее рассмотрим, как работает система прототипов, и как ее можно использовать в ваших программах.\n' +
        '\n' +
        '### 1. Основные понятия\n' +
        '\n' +
        '- Прототип: В JavaScript каждый объект имеет свойство, называемое prototype, которое ссылается на другой объект. Это позволяет объекту' +
        ' наследовать свойства и методы от прототипного объекта.\n' +
        '\n' +
        '- Прототипное наследование: При попытке доступа к свойству объекта JavaScript сначала ищет это свойство в самом объекте. Если оно не' +
        ' найдено, поиск продолжается в прототипе объекта. Этот процесс может продолжаться до тех пор, пока не будет найдено' +
        ' значение или не будет достигнут конец цепочки прототипов.' +
        'Цепочка прототипов — это процесс, при котором JavaScript проверяет объект и его прототипы, пока не найдет свойство или не достигнет ' +
        'конца цепи.' +
        ' Проверка прототипов\n' +
        '\n' +
        'Вы можете использовать метод isPrototypeOf() для проверки, является ли объект прототипом другого объекта.' +
        'Прототипы встроенных объектов\n' +
        '\n' +
        'Встроенные объекты в JavaScript, такие как Array и Function, также используют прототипы. Вы можете расширять эти' +
        ' объекты, добавляя свои собственные методы в их прототипы.' +
        '\n' +
        'Прототипы — это мощный инструмент в JavaScript, который позволяет реализовывать наследование и делиться методами и свойствами между объектами.' +
        ' Понимание системы прототипов поможет вам лучше структурировать ваш код и воспользоваться преимуществами динамической природы JavaScript.',
      active: false,
    },
    {
      question: 'this,call,apply,bind',
      response:
        'this - контекст, ссылка на обьект\n' +
        'call, apply  - методы функции (this, arguments) или (this, [...arguments]) сразу вызываются\n' +
        'bind - можно забиндить и вызвать после' +
        ' В JavaScript ключевыми концепциями, связанными с контекстом выполнения функций, являются this, а также методы call, apply и bind. Все они позволяют управлять значением this в функциях, и вот как они работают в деталях.\n' +
        '\n' +
        '### 1. Значение this\n' +
        '\n' +
        'this в JavaScript — это специальная переменная, которая ссылается на объект, который в данный момент выполняет код. Значение this может изменяться в зависимости от того, как вызывается функция:\n' +
        '\n' +
        '- В глобальном контексте (вне функции) this ссылается на глобальный объект (в браузере это window).\n' +
        "- В функции, вызванной в строгом режиме ('use strict'), this будет undefined.\n" +
        '- В методах объекта this ссылается на объект, к которому принадлежит метод.\n' +
        '- В обработчиках событий this ссылается на элемент, на который было нажато.' +
        ' Метод call()\n' +
        '\n' +
        'Метод call() позволяет вызвать функцию с указанным значением this и аргументами, переданными по отдельности.' +
        '- Первый аргумент для apply() — это значение this.\n' +
        '- Второй аргумент — массив аргументов, которые передаются функции.' +
        ' Метод bind()\n' +
        '\n' +
        'Метод bind() создает новую функцию, которая, когда вызывается, имеет установленное значение this, а также предустановленные начальные аргументы.' +
        '- bind() возвращает новую функцию, к которой применяются переданные аргументы. Это полезно, когда вы хотите привязать функцию к определенному контексту,' +
        ' но вы не хотите, чтобы она выполнялась немедленно.' +
        'Примечания:\n' +
        '\n' +
        '1. Строгий режим: в строгом режиме значение this для функции, вызванной без контекста (например, show()), будет undefined, в отличие от нестрогого режима, где это будет ссылка на глобальный объект.\n' +
        '2. Различия между call() и apply(): call() и apply() делают одно и то же, но apply() принимает массив аргументов, в то время как call() принимает их по отдельности.\n' +
        '3. Использование bind(): Часто используется для передачи обработчиков событий.' +
        'Методы call(), apply() и bind() дают возможность гибко управлять контекстом выполнения функции в JavaScript. Понимание этих концепций важно для работы с объектами и функциями, что позволяет предотвращать ошибки,' +
        ' связанные с неправильным значением this.',
      active: false,
    },
    {
      question:
        'const, let, arrow fn, class, шаблонные строки, spread, rest, итератор, генератор ',
      response:
        'const и let - ключевые слова let - можно обьявить,присвоить значение позже, также можно переприсвоить\n' +
        'const - начальное значение нужно, переприсвоить не получится, только обьект или массив\n' +
        'const && let - блочной области видимости\n' +
        'arrow fn(стрелочная функция ) -  () => {} нет своего контекста ,запоминает где была обьявлена, нет методов функций, аргументс,\n' +
        'более короткая запись, анонимна\n' +
        'spread - не глубокое копирование [...spread] || {...spread}\n' +
        'rest  - когда мы не знаем сколько у нас аргументов - используем rest ( function(a, ...rest){} )' +
        '\n' +
        'Генератор - это функция, которая можно запустить приостановить и возобновить на разных стадиях выполнения. Первый вызов функции вызовет итератор,' +
        ' у этого обьекта есть next для возобновления функции. При каждом вызове функция возобновляет свою' +
        ' работу пока не наткнется на yield и опять станет на паузу ',
      active: false,
    },
    {
      question: 'Веб-воркеры и сервис-вореры? ',
      response:
        ' В веб-разработке два типа рабочих процессов, которые часто обсуждаются — это веб-воркеры (Web Workers) и сервис-воркеры (Service Workers). Оба они используются для выполнения фоновых задач, но имеют разные цели и функционал. Давайте разберем каждую из этих технологий по отдельности.\n' +
        '\n' +
        '### Веб-воркеры (Web Workers)\n' +
        '\n' +
        '1. Описание:\n' +
        'Веб-воркеры позволяют выполнять скрипты в фоновом режиме, т.е. в параллельных потоках. Это позволяет выполнять тяжелые вычисления без блокировки пользовательского интерфейса.\n' +
        '\n' +
        '2. Основные характеристики:\n' +
        '- Отдельный поток: Веб-воркеры работают на отдельном потоке, что предотвращает блокировку основного потока, в котором работает пользовательский интерфейс.\n' +
        '- Ограниченный доступ: Веб-воркеры не имеют доступа к DOM и не могут выполнять действия, требующие интерфейса. Они могут взаимодействовать с основным потоком только через сообщения (используя postMessage()).\n' +
        '- Использование: Удобны для выполнения тяжелых вычислений — обработки данных, выполнения фоновых заданий и т.п.' +
        'Сервис-воркеры (Service Workers)\n' +
        '\n' +
        '1. Описание:\n' +
        'Сервис-воркеры — это специальные скрипты, которые работают между веб-приложением и сетевым сервером. Они служат в качестве прокси-сервера, позволяя перехватывать и обрабатывать сетевые запросы.\n' +
        '\n' +
        '2. Основные характеристики:\n' +
        '- Кэширование: Сервис-воркеры часто используются для реализации функции, связанной с кэшированием, что позволяет улучшить производительность и пользовательский опыт, особенно в условиях медленного интернет-соединения.\n' +
        '- Офлайн-режим: Они позволяют приложениям работать офлайн, кэшируя ресурсы.\n' +
        '- События: Сервис-воркеры работают на основе событий (например, fetch, install, activate). Им нельзя устанавливать свойства напрямую, они могут только реагировать на события.\n' +
        'Сравнение\n' +
        '\n' +
        '1. Цели:\n' +
        '- Веб-воркеры: Основная цель — выполнение фоновых задач, которые не могут блокировать UI.\n' +
        '- Сервис-воркеры: Основная цель — управление сетевыми запросами, кэширование ресурсов и реализация офлайн-функциональности.\n' +
        '\n' +
        '2. Контекст выполнения:\n' +
        '- Веб-воркеры имеют доступ к JavaScript API, но не имеют доступа к DOM.\n' +
        '- Сервис-воркеры не имеют доступа к DOM, но могут работать с сетевыми запросами и кэшами.\n' +
        '\n' +
        '3. Время работы:\n' +
        '- Веб-воркеры живут до тех пор, пока они не завершат свои задачи.\n' +
        '- Сервис-воркеры могут оставаться активными в фоновом режиме и работать на события.\n' +
        '\n' +
        '### Заключение\n' +
        '\n' +
        'Веб-воркеры и сервис-воркеры — это мощные инструменты для веб-разработчиков, которые позволяют реализовывать фоновые задачи и управлять сетевыми запросами. Выбор между ними зависит от ваших целей: если вам ' +
        'нужно выполнить тяжелую вычислительную задачу, используйте веб-воркеры; если же требуется управление кэшированием и работа в офлайн-режиме, вам подойдут сервис-воркеры.',
      active: false,
    },
    {
      question: 'Что вы знаете о функциональном подходе? ',
      response:
        'Функциональный подход (или функциональное программирование) — это парадигма программирования, которая рассматривает вычисления как оценку математических функций и избегает изменения состояния и изменяемых данных. В функциональном программировании функции являются первичными элементами композиции, и сами они рассматриваются как "первоклассные" сущности. Давайте рассмотрим основные концепции и принципы функционального программирования более подробно.\n' +
        '\n' +
        '### Основные концепции функционального программирования\n' +
        '\n' +
        '1. Чистые функции:\n' +
        '- Чистая функция — это функция, которая возвращает одно и то же значение при одинаковых входных данных и не имеет побочных эффектов (не изменяет состояния, не взаимодействует с внешним миром, как, например, ввод-вывод).' +
        '2. Функции высшего порядка:\n' +
        '- Это функции, которые принимают другие функции в качестве аргументов или возвращают функции в качестве результата.' +
        '3. Иммутабельность:\n' +
        '- В функциональном программировании предпочтительно избегать изменения состояний и использовать неизменяемые данные. Вместо изменения существует создание новых версий данных.' +
        '4. Композиция функций:\n' +
        '- Функции могут быть комбинированы для создания более сложных операций. Это позволяет строить цепочки обработки данных.' +
        '5. Лямбда-функции или стрелочные функции:\n' +
        '- Функции без имени, которые часто используются для передачи как аргументы.' +
        '6. Функциональные структуры данных:\n' +
        '- Использование структур данных, которые поддерживают функциональные операции, такие как map, filter, и reduce.' +
        'Преимущества функционального программирования\n' +
        '\n' +
        '1. Модульность: Код легче читать и поддерживать, благодаря чистым функциям и разделению задач на отдельные функции.\n' +
        '2. Тестирование: Чистые функции проще тестировать, так как их выходные данные зависят только от входных данных.\n' +
        '3. Избежание ошибок: Иммутабельность и отсутствие побочных эффектов уменьшают вероятность ошибок, связанных с изменением состояния программы.\n' +
        '\n' +
        '### Недостатки функционального подхода\n' +
        '\n' +
        '1. Производительность: Неизменяемость может вести к дополнительным затратам, поскольку при каждом изменении создаются новые объекты.\n' +
        '2. Обучаемость: Для разработчиков, привыкших к императивному программированию, может потребоваться время для привыкания к новым концепциям.\n' +
        '3. Сложность: Композиция функций может привести к сложным и труднопонимаемым конструкциям, если не использовать её осознанно.' +
        'Функциональный подход к программированию предлагает мощный набор инструментов и методов для создания более чистого, понятного и модульного кода. Использование функционального программирования может значительно улучшить определенные аспекты разработки, особенно в сложных приложениях.' +
        ' Существует много языков программирования, которые поддерживают функциональный стиль (например, Haskell, Scala, Clojure) и многие языки общего назначения, такие как JavaScript, Python и Ruby, также предоставляют возможности для функционального программирования. ',
      active: false,
    },
    {
      question:
        'Что такое чистая функция? Является ли функция делающая запрос чистой? ',
      response:
        'Чистая функция — это функция, которая выполняет определенные математические принципы и обладает следующими ключевыми свойствами:\n' +
        '\n' +
        '1. Детерминированность: Чистая функция всегда возвращает одно и то же значение при одинаковых входных параметрах. То есть, если вы вызываете функцию с одними и теми же аргументами, вы всегда получите один и тот же результат.' +
        '2. Отсутствие побочных эффектов: Чистая функция не вызывает побочных эффектов, что означает, что она не изменяет состояние внешних данных и не взаимодействует с внешним миром (например, не изменяет глобальные переменные, не выполняет операции ввода/вывода, такие как изменение содержимого HTML, вывод в консоль, сетевые запросы и т. д.).' +
        'Является ли функция, делающая запрос, чистой?\n' +
        '\n' +
        'Функция, выполняющая сетевой запрос (например, с помощью fetch в JavaScript) не является чистой функцией по следующим причинам:\n' +
        '\n' +
        '1. Побочные эффекты: Когда функция выполняет сетевой запрос, она взаимодействует с внешней средой (сервером), и результат этого взаимодействия может изменять состояние приложения. Например, вы получите данные от сервера, которые могут изменять отображаемое состояние UI.\n' +
        '\n' +
        '2. Недетерминированность: При одинаковых входных параметрах функция может возвращать разные значения, так как результат сетевого запроса может изменяться в зависимости от состояния сервера или базы данных в момент запроса.' +
        'Чистые функции являются важной концепцией в функциональном программировании, так как они способствуют более предсказуемому и тестируемому коду. Напротив, функции с побочными эффектами, такие как сетевые запросы, усложняют процесс тестирования и предсказуемости, и их часто нужно отдельно обрабатывать или использовать другие подходы для их тестирования.',
      active: false,
    },
    {
      question: 'Мемоизация функции? ',
      response:
        'Мемоизация функции\n' +
        '\n' +
        'Мемоизация — это техника оптимизации, которая заключается в сохранении результатов вызовов функций с одинаковыми аргументами, чтобы избежать повторных вычислений. Эта техника особенно полезна для функций, выполнение которых достаточно затратное и которые часто вызываются с одинаковыми аргументами.\n' +
        '\n' +
        '#### Принципы работы:\n' +
        '1. При первом вызове функции с определёнными аргументами результат вычисления сохраняется (кэшируется).\n' +
        '2. При последующих вызовах с теми же аргументами функция сразу возвращает закэшированный результат, не выполняя вычисление повторно.\n' +
        'Преимущества мемоизации:\n' +
        '- Уменьшение времени выполнения программы за счёт избежания повторных вычислений для одинаковых аргументов.\n' +
        '- Повышение общей производительности приложения, особенно если функции затратные по ресурсам.\n' +
        '\n' +
        '### Недостатки:\n' +
        '- Увеличение потребления памяти для хранения кэшированных результатов.\n' +
        '- Эффективность мемоизации зависит от характера входных данных и частоты повторных вызовов функции.\n' +
        '\n' +
        'Таким образом, чистые функции и мемоизация — это ключевые концепции в функциональном программировании, которые позволяют создавать более оптимизированные и предсказуемые программы.',
      active: false,
    },
    {
      question:
        'const, let, arrow fn, class, шаблонные строки, spread, rest, итератор, генератор ',
      response:
        'const и let - ключевые слова let - можно обьявить,присвоить значение позже, также можно переприсвоить\n' +
        'const - начальное значение нужно, переприсвоить не получится, только обьект или массив\n' +
        'const && let - блочной области видимости\n' +
        'arrow fn(стрелочная функция ) -  () => {} нет своего контекста ,запоминает где была обьявлена, нет методов функций, аргументс,\n' +
        'более короткая запись, анонимна\n' +
        'spread - не глубокое копирование [...spread] || {...spread}\n' +
        'rest  - когда мы не знаем сколько у нас аргументов - используем rest ( function(a, ...rest){} )' +
        '\n' +
        'Генератор - это функция, которая можно запустить приостановить и возобновить на разных стадиях выполнения. Первый вызов функции вызовет итератор,' +
        ' у этого обьекта есть next для возобновления функции. При каждом вызове функция возобновляет свою' +
        ' работу пока не наткнется на yield и опять станет на паузу ',
      active: false,
    },
    {
      question: 'Понятие каррирования функции? ',
      response:
        'Каррирование — это техника, используемая в функциональном программировании, которая превращает функцию, принимающую несколько аргументов, в последовательность функций, каждая из которых принимает один аргумент. Это позволяет вызывать функцию поэтапно, передавая аргументы по одному.\n' +
        '\n' +
        '### Принципы каррирования\n' +
        '1. Преобразование аргументов: Функция с несколькими аргументами, например, f(a, b, c), может быть преобразована в цепочку функций так, что первая функция принимает аргумент a, возвращает функцию, которая принимает аргумент b, и так далее, пока не будут введены все аргументы.' +
        'Преимущества каррирования\n' +
        '1. Улучшение модульности: Каррирование позволяет создавать более гибкие и переиспользуемые функции за счет частичного применения.\n' +
        '2. Читаемость кода: Код может стать более читаемым, когда функции могут быть вызваны с одним аргументом.\n' +
        '3. Легкость тестирования: Меньшие и более простые функции легче тестировать.\n' +
        '\n' +
        '### Недостатки\n' +
        '1. Сложность: Каррирование может усложнить код, особенно для программистов, не знакомых с этой концепцией.\n' +
        '2. Производительность: В некоторых случаях каррированные функции могут быть менее производительными из-за дополнительных вызовов функций.\n ',
      active: false,
    },
    {
      question:
        'Чем отличаются способы обработки ошибок для async/await и promises?',
      response:
        'Обработка ошибок в JavaScript может быть выполнена как с использованием Promise, так и с использованием синтаксиса async/await. Хотя оба подхода работают' +
        ' с асинхронными операциями, есть различия в способах обработки ошибок для каждого из них.\n' +
        'Promise\n' +
        '\n' +
        'При использовании Promise, ошибки обрабатываются с помощью методов catch() и then()' +
        ' Отличия при обработке ошибок с использованием Promise:\n' +
        '1. Цепочка вызовов: Ошибки могут быть обработаны через цепочку функций then(), что позволяет обрабатывать ошибки на разных уровнях цепочки.\n' +
        '2. Использование catch(): Метод catch() обрабатывает ошибки, возникающие в любом месте предыдущих методов then(). Это делает обработку ошибок ясной и централизованной.\n' +
        '\n' +
        '### Async/Await\n' +
        '\n' +
        'При использовании синтаксиса async/await, обработка ошибок осуществляется с помощью блока try/catch.' +
        '\n' +
        ' Отличия при обработке ошибок с использованием async/await:\n' +
        '1. Синтаксическая простота: Синтаксис try/catch более привычен и похож на синхронный код, что делает его более читаемым и управляемым.\n' +
        '2. Локализация ошибок: Блоки try/catch локализуют обработку ошибок, позволяя обрабатывать их только для конкретных частей кода, что может быть полезно,' +
        ' если у вас есть несколько отдельных асинхронных операций.' +
        'В итоге, оба подхода имеют свои преимущества. Promise более декларативный и подходит для простых случаев, тогда как async/await делает код более читабельным и управляемым, особенно для более' +
        ' сложных асинхронных операций. Используйте тот подход, который лучше подходит для вашей ситуации и стиля разработки.',
      active: false,
    },
    {
      question: 'Глубокое и неглубокое копирование объектов?',
      response:
        'В JavaScript существует две основные техники копирования объектов: глубокое копирование (deep copy) и неглубокое копирование (shallow copy). Эти два метода отличаются тем, как они обрабатывают вложенные объекты и массивы.\n' +
        '\n' +
        '### Неглубокое копирование (Shallow Copy)\n' +
        '\n' +
        'Неглубокое копирование создает новый объект, копируя свойства (ключи и значения) исходного объекта на верхнем уровне. Если объект содержит вложенные объекты, то их ссылки копируются, а не сами объекты, поэтому изменения во вложенных объектах в исходном объекте будут отражаться и в его копии.' +
        ' С помощью Object.assign()' +
        ' С помощью операторов расширения (spread operator)' +
        'Глубокое копирование (Deep Copy)\n' +
        '\n' +
        'Глубокое копирование создает новую копию объекта, включая все вложенные объекты. Все свойства и их значения копируются рекурсивно. Таким образом, изменения в копии не отражаются на оригинальном объекте и наоборот.' +
        '1. С использованием JSON.parse() и JSON.stringify()' +
        'Этот метод работает, но имеет ограничения: он не может копировать функции, undefined, специальные объекты (например, Date, Map, Set) и незначительно теряет типовые данные.\n' +
        '\n' +
        '2. С использованием библиотек Выбор метода копирования\n' +
        '\n' +
        '- Неглубокое копирование: подходит, если вы работаете с плоскими объектами или не собираетесь изменять вложенные объекты. Это быстро и просто.\n' +
        '\n' +
        '- Глубокое копирование: необходимо использовать, если вам нужно избежать изменений в вложенных объектах оригинала. Этот метод более ресурсоемкий и может требовать дополнительных библиотек.' +
        'Выбор между глубоким и неглубоким копированием зависит от ваших задач и структуры данных. Неглубокое копирование удобно для простых структур данных, тогда как глубокое копирование необходимо для работы с сложными и вложенными объектами.',
      active: false,
    },
    {
      question:
        'Какие коллекции в JavaScript вы знаете? С какими работали? Приведите пример\n' +
        'использования и основные плюсы какой либо коллекции? (Set, Map, WeakSet и\n' +
        'WeakMap)\n ',
      response:
        'В JavaScript существует несколько различных типов коллекций, каждая из которых имеет свои особенности и применение. Вот основные из них:\n' +
        '\n' +
        '1. Array (Массивы)\n' +
        '2. Set (Множества)\n' +
        '3. Map (Отображения)\n' +
        '4. WeakSet (Слабые множества)\n' +
        '5. WeakMap (Слабые отображения)\n' +
        '\n' +
        '### 1. Set\n' +
        '\n' +
        'Set представляет собой коллекцию уникальных значений, при этом порядок следования элементов сохраняется. Значения могут быть любого типа, включая объекты. Если вы пытаетесь добавить дубликаты, они будут проигнорированы.\n' +
        'Плюсы:\n' +
        '- Легкость в помощи уникальности значений.\n' +
        '- Быстрые операции добавления, удаления и проверки наличия элементов (приблизительно O(1)).\n' +
        '- Возможность итерироваться по значениям в порядке их добавления.' +
        '2. Map\n' +
        '\n' +
        'Map — это коллекция, которая сохраняет пары "ключ-значение". В отличие от обычных объектов, где ключи являются строками или символами, в Map ключи могут быть любого типа, включая объекты.' +
        'Плюсы:\n' +
        '- Удобно использовать в качестве структуры данных для хранения ассоциативных массивов.\n' +
        '- Поддерживает любые типы ключей.\n' +
        '- Позволяет сохранять порядок вставки элементов.\n' +
        '\n' +
        '---\n' +
        '\n' +
        '### 3. WeakSet\n' +
        '\n' +
        'WeakSet — это коллекция, которая похожа на Set, но позволяет хранить только слабые (слабые ссылки) на объекты. Это значит, что если объект, который хранится в WeakSet, больше нигде не используется, он может быть удалён сборщиком мусора.' +
        'Плюсы:\n' +
        '- Поддержка автоматического управления памятью, так как объекты могут быть автоматически удалены, если на них нет других ссылок.\n' +
        '- Можно использовать для хранения временных объектов.\n' +
        '\n' +
        '---\n' +
        '\n' +
        '### 4. WeakMap\n' +
        '\n' +
        'WeakMap — это коллекция, которая также хранит пары "ключ-значение", где ключом может быть только объект, а значения могут быть любого типа. WeakMap также использует слабые ссылки на ключи, благодаря чему объекты могут быть собраны сборщиком мусора.\n' +
        '\n' +
        'Плюсы:\n' +
        '- Сильные преимущества в управлении памятью: объекты-ключи могут быть удалены сборщиком мусора, когда на них нет других ссылок.\n' +
        '- Полезно для хранения данных, связанных с объектами, не мешая сборщику мусора.' +
        'Каждая из коллекций имеет свое место в JavaScript и может использоваться в зависимости от задач. Лично я работал с такими коллекциями, как Set и Map, и на практике они были полезными при решении задач, связанных с уникальностью данных и ассоциативными массивами. Например, Set отлично подошёл для фильтрации дубликатов в массиве при' +
        ' обработке данных из API, а Map — для хранения пар "ключ-значение", что сделало код более читабельным и простым в поддержке. ',
      active: false,
    },
    {
      question:
        'Какие есть базовые события JS (Генерация событий на элементах) ',
      response:
        ' В JavaScript существует множество базовых событий, которые можно прослушивать и обрабатывать в элементах DOM. Под событиями понимаются определенные действия или изменения состояния, которые происходят на веб-странице и могут быть перехвачены и обработаны с помощью обработчиков событий. Вот некоторые из основных типов событий, которые чаще всего используются в JavaScript:\n' +
        '\n' +
        '### 1. События работы с мышью\n' +
        '- click: Срабатывает, когда элемент нажимается мышью.\n' +
        '- dblclick: Срабатывает при двойном щелчке по элементу.\n' +
        '- mousedown: Срабатывает, когда кнопка мыши нажата на элементе.\n' +
        '- mouseup: Срабатывает, когда кнопка мыши отпускается над элементом.\n' +
        '- mouseover: Срабатывает, когда курсор мыши проходит над элементом.\n' +
        '- mouseout: Срабатывает, когда курсор мыши уходит с элемента.\n' +
        '\n' +
        '### 2. События работы с клавиатурой\n' +
        '- keydown: Срабатывает, когда клавиша нажата.\n' +
        '- keyup: Срабатывает, когда клавиша отпущена.\n' +
        '- keypress: Срабатывает при нажатии клавиши, которая генерирует символ (устаревшее, лучше использовать keydown и keyup).\n' +
        '\n' +
        '### 3. События фокуса\n' +
        '- focus: Срабатывает, когда элемент получает фокус (например, текстовое поле).\n' +
        '- blur: Срабатывает, когда элемент теряет фокус.\n' +
        '\n' +
        '### 4. События работы с формами\n' +
        '- submit: Срабатывает при отправке формы.\n' +
        '- change: Срабатывает, когда значение элемента формы изменено и потеряно фокус.\n' +
        '- input: Срабатывает, когда значение элемента ввода изменяется. (Поддерживает более широкий диапазон событий, чем change).\n' +
        '\n' +
        '### 5. События касания (для мобильных устройств)\n' +
        '- touchstart: Срабатывает, когда палец касается экрана.\n' +
        '- touchmove: Срабатывает, когда палец перемещается по экрану.\n' +
        '- touchend: Срабатывает, когда палец отпускается от экрана.\n' +
        '\n' +
        '### 6. События загрузки\n' +
        '- load: Срабатывает, когда объект (например, изображение, страница, скрипт) завершает загрузку.\n' +
        '- DOMContentLoaded: Срабатывает, когда первоначальная HTML-страница была полностью загружена и разобрана, не дожидаясь завершения загрузки стилей, изображений и всех подресурсов.\n' +
        '- beforeunload: Срабатывает перед тем, как пользователь покинет текущую страницу.',
      active: false,
    },
    {
      question: 'Поднятие переменных в ES5 что это?\n ',
      response:
        'Поднятие переменных (hoisting) в JavaScript — это механизм, при котором переменные и функции "поднимаются" в начало их контекста выполнения (scope), что позволяет им использоваться до их объявления в коде. Обычно это относится к переменным, объявленным с помощью var, а также к объявлениям функций.\n' +
        '\n' +
        '### Как работает поднятие переменных:\n' +
        '\n' +
        '1. Объявления переменных:\n' +
        'Когда JavaScript интерпретирует код, он сначала проходит через этап создания контекста выполнения и поднимает все объявления переменных. При этом поднимаются только объявления, но не инициализации (присваивания).\n' +
        '\n' +
        '2. Объявления функций:\n' +
        'Функции объявляются во время подъема полностью, поэтому они могут быть вызваны до их объявления.' +
        'Поднятие функций:\n' +
        '\n' +
        'Функции также поднимаются, но полное определение функции переносится в верхнюю часть ее области видимости' +
        'В данном примере мы можем вызвать myFunction() до ее фактического объявления в коде, и это работает, потому что объявление функции поднимается.\n' +
        '\n' +
        '### Важное отличие для let и const:\n' +
        '\n' +
        'С введением let и const в ES6 ситуация изменилась. Объявления с использованием let и const также поднимаются, но они не инициализируются до фактического присвоения значений, и доступ к ним раньше вызовет ошибку ReferenceError.' +
        'Поднятие переменных в JavaScript может вызывать путаницу, особенно для начинающих разработчиков. Пониженное значение переменной (undefined), когда оно вызывается до присвоения, может привести к ошибкам в коде. Рекомендуется всегда объявлять переменные перед их использованием, чтобы избежать недопонимания и потенциальных ошибок.',
      active: false,
    },
    {
      question: 'Функции первого класса',
      response:
        'В JavaScript функции являются первоклассными объектами (first-class objects), что означает, что функции могут рассматриваться и использоваться так же, как и другие значения. Это позволяет выполнять множество интересных операций с функциями. Давайте рассмотрим, что именно это означает и какие возможности оно предоставляет.\n' +
        '\n' +
        '### Что значит "функции первого класса"?\n' +
        '\n' +
        '1. Присвоение переменным: Вы можете присваивать функции переменным.\n' +
        '2. Передача как аргументы: Вы можете передавать функции в другие функции в качестве аргументов.\n' +
        '3. Возврат из других функций: Вы можете возвращать функции из других функций.\n' +
        '4. Создание и хранение: Вы можете создавать функции динамически и хранить их в структурах данных, таких как массивы или объекты.Функции можно хранить в массивах и начинать их с выполнения в программном коде.\n' +
        '\n' +
        '### Преимущества функций первого класса\n' +
        '\n' +
        '1. Высокая гибкость: Легко создавать составные функции и функции высшего порядка (higher-order functions).\n' +
        '2. Упрощение кода: Повышает читаемость и сокращает количество кода за счет использования обратных вызовов (callbacks).\n' +
        '3. Создание замыканий: Функции могут захватывать окружение (scope), что позволяет создавать замыкания.\n' +
        '\n' +
        '### Заключение\n' +
        '\n' +
        'Функции первого класса в JavaScript предоставляют мощные инструменты для разработки. Они позволяют программистам использовать функции так же, как и другие данные, и это открывает множество возможностей для более эффективного и абстрактного программирования. Понимание этого' +
        ' концепта является важной частью работы с языком и способствует созданию более чистого, модульного и переиспользуемого кода.',
      active: false,
    },
    {
      question: 'Как восстановить контекст this?',
      response:
        'В JavaScript контекст this — это важная концепция, которая определяет, на какой объект ссылается код в пределах функции. В зависимости от того, как вызывается функция, контекст this может меняться. Однако иногда возникает необходимость установить или восстановить желаемый контекст для функции. Здесь рассмотрим несколько способов этого добиться.\n' +
        '\n' +
        '### 1. Использование call, apply и bind\n' +
        '\n' +
        'JavaScript предоставляет методы, такие как call, apply и bind, которые позволяют явно установить контекст this.\n' +
        '\n' +
        '#### a. call()\n' +
        '\n' +
        'Метод call() вызывает функцию с заданным значением this и аргументами, переданными по отдельности.' +
        'b. apply()\n' +
        '\n' +
        'Метод apply() работает аналогично call(), но принимает аргументы в виде массива.' +
        'c. bind()\n' +
        '\n' +
        'Метод bind() создает новую функцию, которая, при вызове, имеет установленный контекст this. Она также может принимать аргументы, которые будут переданы в новую функцию.' +
        '2. Стрелочные функции\n' +
        '\n' +
        'Стрелочные функции захватывают значение this из окружающего контекста во время создания. Это означает, что this внутри стрелочной функции будет равно this родительской функции, где она была объявлена.' +
        'ажно понимать, как работает контекст this в JavaScript, а также как его можно устанавливать и восстанавливать в различных ситуациях. Используя методы call, apply, bind, стрелочные функции и правильные конструкции классов, вы сможете контролировать контекст this в вашем коде. Это поможет избежать распространенных ошибок и сделать ваш код более предсказуемым и стабильным.',
      active: false,
    },
    {
      question: 'Можно ли разбиндить контекст',
      response:
        'Да, можно "восстановить" или "разбиндить" контекст this в JavaScript, используя различные методы' +
        '. Когда вы работаете с функциями, особенно с методами объектов и функциями' +
        ' обратного вызова, контекст this может меняться. Вот несколько способов управления контекстом this в JavaScript' +
        'Способы восстановления контекста this\n' +
        '\n' +
        '1. Использование bind():\n' +
        'Метод bind() создает новую функцию, которая при вызове имеет установленное значение this, равное переданному значению.' +
        '2. Использование call() и apply():\n' +
        'Эти методы позволяют вызывать функцию с заданным контекстом this. call() принимает аргументы через запятую, а apply() принимает массив аргументов.' +
        '3. Стрелочные функции:\n' +
        'Стрелочные функции не имеют своего собственного this. Они берут this из родительского контекста, в котором они были определены.' +
        'Разбиндить контекст this\n' +
        '\n' +
        'В JavaScript нет встроенного способа "разбиндить" контекст this в функции, которая была связана с использованием bind(). Однако вы можете обойти это ограничение путем создания новой функции без привязки.\n' +
        '\n' +
        'Для этого можно использовать одну из следующих стратегий:\n' +
        '\n' +
        '1. Создание новой функции:\n' +
        'Если у вас есть функция с привязанным контекстом, и вы хотите вызвать ее с обычным контекстом, просто создайте новую функцию, используя ее объявление без привязки.\n' +
        '2. Использование обычного вызова:\n' +
        'Вы можете просто вызвать функцию без контекста, и this будет равен глобальному объекту (в браузере — window, в Node.js — global) или undefined в строгом режиме.' +
        'правление контекстом this — это важная часть JavaScript, особенно при работе с объектами и функциями обратного вызова. Используя методы bind(), call(), и apply(), а также стрелочные функции, можно эффективно управлять контекстом. Обратите внимание, что "разбиндить" контекст в прямом смысле невозможно, но можно вызвать функцию в контексте, где this не привязан, создавая новую функцию без привязки.',
      active: false,
    },
    {
      question:
        'Два подхода к обработке событий в DOM(onevent,addEventListener).Пользовательские события.Стадии прохода события',
      response:
        'События в JS - погружение и всплытие\n' +
        '1.onEvent - можно на элемент накинуть событие onClick\n' +
        '2.addEventListener - вешаем на элемент, далее пока не отпишемся через removеEventListener\n' +
        "element.addEventListener('событие (click)', функция которая наблюдает за событием (() => {}))\n" +
        '\n' +
        'Пользовательские события - \n' +
        '\n' +
        'new Event(”клик”, [опции]) опции - bubbles - true/false всплытие \n' +
        '\n' +
        'eanaeleble true/false \n' +
        '\n' +
        'composed-событие будет вставать за пределы shadow DOM метод dispatchEvent запускает событ[ие на элементе](http://8.web/)\n' +
        '\n' +
        'Стадии события\n' +
        '\n' +
        ' 1.погружение только addEventListener\n' +
        '\n' +
        '2.целевая фаза-все\n' +
        '\n' +
        '3.фаза всплытие - с add по capture \n',
      active: false,
    },
    {
      question: 'Web Worker ',
      response:
        'aссинхронная система позволяет выполнять тяжелые в вычислительном плане и длительные задачи\n' +
        'без блокировки потока пользовательского интерфейса. При их использовании вычисления идут параллельно.\n' +
        'Это своего рода многопоточность. Web Workers - не являются частью JS, они представляют собой возможность браузера,\n' +
        'к которой можно получить доступ посредством JS - new Worker() - они должны быть в отдельном файле ,воркеры\n' +
        'выполняются в изолированных потоках  в браузере\n' +
        'Для запуска - worker.postMessage() для отправки в основной поток   (DOM && Window -  для них недоступны)\n' +
        '\n' +
        'onMessage слушатель в основном потоке для получения сообщений от воркера terminate() завершает работу воркера \n' +
        '\n',
      active: false,
    },
    {
      question: 'В чем отличие вебсокетов от пулинга',
      response:
        'Веб-сокеты и пуллинг (polling) — это два разных подхода для реализации взаимодействия между клиентом и сервером в веб-приложениях, особенно для работы в режиме реального времени. Давайте рассмотрим их основные отличия.\n' +
        '\n' +
        '### 1. Определение\n' +
        '\n' +
        '- Веб-сокеты:\n' +
        'Веб-сокеты — это протокол, который обеспечивает постоянное соединение между клиентом и сервером. Он позволяет обмениваться данными в обоих направлениях (двусторонняя связь) без необходимости повторного запроса. После установления соединения с помощью веб-сокета оно остается открытым, что позволяет обмениваться сообщениями мгновенно.\n' +
        '\n' +
        '- Пуллинг:\n' +
        'Пуллинг — это подход, при котором клиент периодически отправляет запросы на сервер с целью проверки наличия обновлений или новых данных. Это можно реализовать как "опрос" (long polling) или короткий опрос (short polling). В первом случае клиент отправляет запрос, и сервер не отвечает, пока у него не появятся новые данные, а затем клиент сразу же отправляет следующий запрос. В случае короткого опроса клиент отправляет запросы через фиксированные промежутки времени.\n' +
        '\n' +
        '### 2. Эффективность и производительность\n' +
        '\n' +
        '- Веб-сокеты:\n' +
        '- Более эффективны, так как они требуют меньше ресурсов, чем пуллинг.\n' +
        '- После установления соединения обмен данными происходит без задержек, и не нужно каждый раз повторно устанавливать соединение.\n' +
        '- Минимальное использование пропускной способности, так как отсутствуют накладные расходы на заголовки HTTP (в отличие от обычных запросов).\n' +
        '\n' +
        '- Пуллинг:\n' +
        '- Может потреблять больше ресурсов, так как клиент не может предсказать, когда сервер будет готов отправить обновления. Поэтому он может отправлять много запросов, даже когда нет новых данных.\n' +
        '- Задержка между запросами может приводить к большему времени ожидания перед тем, как клиент получит данные, что делает его менее эффективным.\n' +
        '\n' +
        '### 3. Поддержка технологий\n' +
        '\n' +
        '- Веб-сокеты:\n' +
        '- Используют протокол WebSocket и могут работать во всех современных браузерах, поддерживающих этот протокол.\n' +
        '- Предоставляют поддержку для большого количества клиентов одновременно.\n' +
        '\n' +
        '- Пуллинг:\n' +
        '- Поскольку основан на XMLHttpRequest (или Fetch API), он поддерживается повсеместно и не требует встраивания ' +
        'дополнительных протоколов.\n' +
        '- Простой в реализации, но не столь эффективен для больших объемов данных или частых обновлений.\n' +
        '\n' +
        '### 4. Примеры использования\n' +
        '\n' +
        '- Веб-сокеты:\n' +
        '- Чат-программы, игры в реальном времени, биржевые приложения, где необходима высокая частота обновлений.\n' +
        '\n' +
        '- Пуллинг:\n' +
        '- Сайты с реже обновляемыми данными, где не критично, чтобы обновления приходили с минимальной задержкой' +
        ' (например, новостные агрегаторы).\n' +
        '\n' +
        '### Заключение\n' +
        '\n' +
        'Веб-сокеты и пуллинг имеют свои преимущества и недостатки, и выбор между ними зависит от конкретных' +
        ' требований приложения. В большинстве случаев, если требуется высокая производительность и минимальная задержка при обмене данными, веб-сокеты являются предпочтительным ' +
        'вариантом. Пуллинг может быть хорошим вариантом для простых приложений или где постоянное соединение не требуется.',
      active: false,
    },
    {
      question: 'Какие операторы в JavaScript знаете?',
      response:
        ' В JavaScript существует множество операторов, которые могут быть классифицированы на несколько категорий. Вот основные из них:\n' +
        '\n' +
        '### 1. Арифметические операторы\n' +
        'Эти операторы используются для выполнения математических операций:\n' +
        '- + (Сложение)\n' +
        '- - (Вычитание)\n' +
        '- * (Умножение)\n' +
        '- / (Деление)\n' +
        '- % (Остаток от деления)\n' +
        '- (Возведение в степень, ES6)\n' +
        '\n' +
        '### 2. Операторы присваивания\n' +
        'Эти операторы используются для присвоения значений переменным:\n' +
        '- = (Простое присваивание)\n' +
        '- += (Прибавить и присвоить)\n' +
        '- -= (Вычесть и присвоить)\n' +
        '- *= (Умножить и присвоить)\n' +
        '- /= (Разделить и присвоить)\n' +
        '- %= (Взять остаток и присвоить)\n' +
        '- = (Возвести в степень и присвоить)\n' +
        '\n' +
        '### 3. Операторы сравнения\n' +
        'Эти операторы используются для сравнения значений:\n' +
        '- == (Равенство)\n' +
        '- === (Строгое равенство)\n' +
        '- != (Неравенство)\n' +
        '- !== (Строгое неравенство)\n' +
        '- > (Больше)\n' +
        '- < (Меньше)\n' +
        '- >= (Больше или равно)\n' +
        '- <= (Меньше или равно)\n' +
        '\n' +
        '### 4. Логические операторы\n' +
        'Эти операторы используются для выполнения логических операций:\n' +
        '- && (Логическое И)\n' +
        '- || (Логическое ИЛИ)\n' +
        '- ! (Логическое НЕ)\n' +
        '\n' +
        '### 5. Побитовые операторы\n' +
        'Эти операторы работают на уровне битов:\n' +
        '- & (Побитовое И)\n' +
        '- | (Побитовое ИЛИ)\n' +
        '- ^ (Побитовое исключающее ИЛИ)\n' +
        '- ~ (Побитовое НЕ)\n' +
        '- << (Сдвиг влево)\n' +
        '- >> (Сдвиг вправо)\n' +
        '- >>> (Сдвиг вправо с заполнением нулями)\n' +
        '\n' +
        '### 6. Унарные операторы\n' +
        'Эти операторы работают с одним операндом:\n' +
        '- + (Унарный плюс, преобразует в число)\n' +
        '- - (Унарный минус, преобразует в число и меняет знак)\n' +
        '- ++ (Инкремент)\n' +
        '- -- (Декремент)\n' +
        '- typeof (Возвращает тип переменной)\n' +
        '- delete (Удаляет свойство из объекта)\n' +
        '\n' +
        '### 7. Оператор запятой\n' +
        '- , (Используется для отделения выражений, возвращает последнее выражение)\n' +
        '\n' +
        '### 8. Оператор условия (тернарный оператор)\n' +
        '- ? : (Упрощенная форма условия. condition ? expr1 : expr2)\n' +
        '\n' +
        '### 9. Оператор "new"\n' +
        '- new (Создает новый объект)\n' +
        '\n' +
        '### 10. Оператор "instanceof"\n' +
        '- instanceof (Проверяет, является ли объект экземпляром определенного конструктора)\n' +
        '\n' +
        '### 11. Оператор "in"\n' +
        '- in (Проверяет, существует ли свойство в объекте)',
      active: false,
    },
    {
      question: 'Как перебрать в цикле все свойства объекта? ',
      response:
        '1. Использование for...in' +
        'Цикл for...in позволяет перебрать все перечисляемые свойства объекта, включая унаследованные свойства.' +
        '2. Использование Object.keys()\n' +
        '\n' +
        'Метод Object.keys() возвращает массив собственных перечисляемых свойств объекта (без унаследованных) и позволяет использовать стандартный метод перебора массивов.' +
        '3. Использование Object.entries()\n' +
        '\n' +
        'Метод Object.entries() возвращает массив пар ключ-значение, которые также можно перебрать.' +
        ' 4. Использование Object.values()\n' +
        '\n' +
        'Метод Object.values() возвращает массив значений собственных перечисляемых свойств объекта. Его можно использовать вместе с циклом.' +
        '5. Использование forEach с Object.keys()\n' +
        '\n' +
        'Это способ использовать методы массивов с массивом ключей.',
      active: false,
    },
    {
      question: 'Как работает setTimeout, setInterval? Что возвращают?',
      response:
        'В JavaScript функции setTimeout и setInterval используются для работы с таймерами, позволяя выполнять код с задержкой или через определенные интервалы времени. Давайте рассмотрим, как они работают и что они возвращают.\n' +
        '\n' +
        '### 1. setTimeout\n' +
        '\n' +
        'Функция setTimeout выполняет заданный код через определенный промежуток времени.' +
        'Что возвращает: setTimeout возвращает уникальный идентификатор таймера (timeoutId), который можно использовать для отмены этого таймера с помощью функции clearTimeout.\n' +
        '2. setInterval\n' +
        '\n' +
        'Функция setInterval выполняет заданный код с регулярным интервалом времени.' +
        'Что возвращает: setInterval возвращает уникальный идентификатор интервала (intervalId), который можно использовать для остановки выполнения интервала с помощью функции clearInterval.',
      active: false,
    },
    {
      question:
        'С помощью какой операции можно отбросить дробную часть числа? ',
      response:
        '1. Использование Math.floor()\n' +
        'Метод Math.floor() округляет число до ближайшего меньшего целого числа, тем самым отбросив дробную часть.' +
        '2. Использование Math.trunc()\n' +
        'Метод Math.trunc() удаляет дробную часть числа, не округляя его.' +
        '3. Использование parseInt()\n' +
        'Функция parseInt() преобразует строку в целое число, игнорируя дробную часть, если переданное значение не является строкой.' +
        '4. Использование побитового оператора | (побитовое или)\n' +
        'Этот оператор приводит число к целочисленному типу, отбросив дробную часть.' +
        '5. Использование Math.round() с Math.abs()\n' +
        'Метод Math.round() позволяет округлить число, но с условием можно отбросить дробную часть.',
      active: false,
    },
    {
      question:
        'Каковы особенности сравнения с null и undefined?Каковы особенности сравнения с null и\n' +
        'undefined? ',
      response:
        'В JavaScript null и undefined представляют собой особые значения, которые часто используются для обозначения отсутствия или неопределенности. Однако между ними есть важные различия и особенности поведения при сравнении. Ниже рассмотрим их подробнее.\n' +
        '\n' +
        '### 1. Определение\n' +
        '\n' +
        '- null: Это явное значение, которое задает отсутствие объекта или значения. Используется для инициализации переменной, что подразумевает, что она будет иметь объектное значение в будущем.\n' +
        '- undefined: Это значение автоматически присваивается переменным, которые были объявлены, но не инициализированы. Оно также возникает, если функция ничего не возвращает.' +
        '2. Сравнение с помощью оператора == (нестрогое равенство)\n' +
        '\n' +
        'При использовании нестрогого равенства (==) JavaScript выполняет автоматическое преобразование типов для сравнения значений.' +
        'аким образом, null и undefined равны, когда происходит нестрогое сравнение.\n' +
        '\n' +
        '### 3. Сравнение с помощью оператора === (строгое равенство)\n' +
        '\n' +
        'С помощью строгого равенства (===) JavaScript не приводит значения к одному типу. Исходя из этого:' +
        'Таким образом, null и undefined не равны при строгом сравнении, так как они имеют разные типы.' +
        '4. Типы данных\n' +
        'typeof можно проверить тип переменной:' +
        'console.log(typeof null); // "object"\n' +
        'console.log(typeof undefined); // "undefined"' +
        'Здесь стоит отметить, что typeof null возвращает "object", что является известным глюком в JavaScript.\n' +
        '\n' +
        '### 5. Использование в условных выражениях\n' +
        '\n' +
        'Оба значения (null и undefined) считаются "ложными" (falsy) в условиях. Это означает, что они будут интерпретироваться как false в контексте условных операторов.' +
        '6. Частые ошибки и практические моменты\n' +
        '\n' +
        '- Если вы хотите проверить, если переменная не задана (т.е. равно null или undefined), используйте нестрогое сравнение с ==' +
        '- Если необходимо строго различать null и undefined, используйте строгое равенство ===. Это помогает избежать неожиданных последствий.',
      active: false,
    },
    {
      question:
        ' К чему преобразуются null и undefined в численном преобразовании типов?\n',
      response:
        'Преобразование null в число\n' +
        '\n' +
        'Когда вы преобразуете null в число, оно становится 0. Это происходит потому, что null считается "пустым" или "отсутствующим" значением, и в числовом контексте это значение эквивалентно нулю. Преобразование undefined в число\n' +
        '\n' +
        'При преобразовании undefined в число результатом будет NaN (Not-a-Number). undefined обозначает, что значение отсутствует или недоступно, поэтому при попытке преобразовать его в число возникает неопределенность.\nТаким образом, при численном преобразовании:\n' +
        '- null преобразуется в 0\n' +
        '- undefined преобразуется в NaN',
      active: false,
    },
    {
      question: '  Объяснить разницу между !!(a && b) и (a && b)',
      response:
        '!!(a && b) и (a && b) — это два различных выражения в JavaScript, и их разница заключается в том, как они обрабатываются и какое значение возвращают. Давайте рассмотрим их подробнее.\n' +
        '\n' +
        '### 1. (a && b)\n' +
        '\n' +
        'Выражение (a && b) использует логический оператор AND (&&). Оно возвращает:\n' +
        '\n' +
        '- Первое истинное (truthy) значение: Если a является истинным значением, то результатом будет значение b. Если a является ложным (falsy), будет возвращено a.\n' +
        '- Ложное (falsy) значение: Если оба значения ложные, то будет возвращено первое ложное значение.\n' +
        '\n' +
        'Таким образом, результатом этого выражения могут быть три возможных варианта:\n' +
        '- Если и a, и b истинны, возвращается значение b.\n' +
        '- Если a ложное, возвращается значение a.\n' +
        '- Если b ложное и a истинно, возвращается значение b.' +
        '2. !!(a && b)\n' +
        '\n' +
        'Выражение !! — это двойное логическое отрицание, которое используется для приведения значения к типу Boolean. Оно делает следующее:\n' +
        '\n' +
        '- Оператор ! (логическое отрицание) преобразует значение в булевый тип и инвертирует его.\n' +
        '- При использовании !! вы сначала инвертируете значение, а затем инвертируете его снова, что возвращает его истинное булевое значение.\n' +
        '\n' +
        'Таким образом, выражение !!(a && b) всегда возвращает true или false, что соответствует булевому значению, представляющему результат логического выражения (a && b).' +
        'Краткое резюме:\n' +
        '\n' +
        '- (a && b) возвращает одно из значений (a или b) или false, в зависимости от значений переменных.\n' +
        '- !!(a && b) возвращает только true или false, приводя результат выражения к логическому значению.',
      active: false,
    },
    {
      question:
        ' Как реализовать сложение числа с объектом(в результате должно получиться число)?',
      response:
        ' JavaScript, чтобы реализовать сложение числа с объектом и получить числовой результат, необходимо определить метод, который будет обрабатывать это сложение.\n' +
        '\n' +
        'Объекты в JavaScript могут иметь пользовательские методы, включая метод valueOf(), который вызывается автоматически, когда объект используется в контексте, ' +
        'требующем примитивное значение (например, при выполнении арифметической операции).' +
        'Пример реализации\n' +
        '\n' +
        'Давайте создадим объект, который будет иметь метод valueOf(), возвращающий числовое значение, и затем сложим его с числом.\n' +
        '\n' +
        '\n' +
        'let obj = {\n' +
        '    value: 10,\n' +
        '    valueOf: function() {\n' +
        '        return this.value; // Возвращаем числовое значение\n' +
        '    }\n' +
        '};\n' +
        '\n' +
        '// Сложение числа с объектом\n' +
        'let number = 5;\n' +
        'let result = number + obj; // Здесь будет вызван obj.valueOf()\n' +
        'console.log(result); // 15' +
        'Объяснение:\n' +
        '\n' +
        '1. Создание объекта: Мы создали объект obj с числовым свойством value и методом valueOf(), который возвращает это значение.\n' +
        '\n' +
        '2. Арифметическая операция: При выполнении операции сложения number + obj JavaScript автоматически вызывает метод valueOf() у объекта obj, чтобы получить его числовое значение. В данном случае, результатом будет 5 + 10, что дает 15.\n' +
        '\n' +
        '### Другие методы\n' +
        '\n' +
        'Кроме метода valueOf(), можно также использовать метод toString(), если это необходимо. Однако в контексте арифметических операций метод valueOf() является предпочтительным, так как он возвращает примитивное (числовое) значение.',
      active: false,
    },
    {
      question: ' Что является областью видимости для переменных в JavaScript?',
      response:
        'Область видимости (scope) в JavaScript определяет, где доступна переменная в коде и откуда она может быть использована или изменена. Понимание области видимости является важной частью работы с JavaScript, так как это влияет на жизненный цикл переменных и управление памятью. В JavaScript существуют несколько типов областей видимости: глобальная и локальная (функциональная и блочная). Давайте рассмотрим каждый из этих типов подробно.\n' +
        '\n' +
        '### 1. Глобальная область видимости\n' +
        'Переменные, объявленные в глобальной области видимости, доступны из любого места в коде, включая функции и другие блоки кода. Если переменная объявлена вне функции, она получает глобальную область видимости.' +
        '2. Локальная область видимости\n' +
        'Переменные, объявленные внутри функции, имеют локальную область видимости и доступны только внутри этой функции. Они не могут быть доступны вне функции.' +
        '\n' +
        '### 3. Блочная область видимости\n' +
        'С появлением let и const в ES6 была введена блочная область видимости. Переменные, объявленные с помощью let или const внутри блока (например, в фигурных скобках), доступны только внутри этого блока.' +
        '4. Замыкания\n' +
        'Замыкания (closures) — это особая форма видимости, когда внутренняя функция имеет доступ к переменным своей внешней функции даже после завершения выполнения этой функции. Это позволяет сохранять состояние и создавать приватные переменные.' +
        '5. Область видимости в глобальных объектах\n' +
        'Переменные, объявленные с помощью var в глобальной области, становятся свойствами глобального объекта (например, window в браузере).',
      active: false,
    },
    {
      question: ' Реализация аргументов по умолчанию в функции',
      response:
        'Аргументы по умолчанию определяются простым присваиванием значения в объявлении функции',
      active: false,
    },
    {
      question:
        'Как работает чтение и запись свойств объекта в прототипном наследовании?',
      response:
        'Прототипное наследование — это одна из ключевых концепций в JavaScript. Она позволяет объектам наследовать свойства и методы от других объектов. При работе с объектами и их свойствами важно понимать, как происходит чтение и запись свойств, а также как используется цепочка прототипов. Давайте рассмотрим это подробнее.\n' +
        '\n' +
        '### Как работает чтение и запись свойств объекта\n' +
        '\n' +
        '1. Чтение свойств: Когда вы обращаетесь к свойству объекта, JavaScript сначала проверяет, существует ли это свойство непосредственно в объекте. Если такое свойство найдено, оно возвращается. Если же его нет, JavaScript переходит к прототипу объекта и продолжает процедуру проверки. Этот процесс повторяется по цепочке прототипов до тех пор, пока не будет найдено свойство или не закончится цепочка. Если свойство не найдено, будет возвращено undefined.\n' +
        '\n' +
        '2. Запись свойств: Когда вы присваиваете значение свойству объекта, JavaScript сначала проверяет, существует ли это свойство в самом объекте. Если свойство существует, новое значение перезаписывает старое. Если же свойства нет, оно создается непосредственно в объекте, и новое значение присваивается ему. Важно отметить, что при записи свойств происходит именно создание или обновление непосредственно в объекте, который был использован для записи, без необходимости проходить по цепочке прототипов' +
        'Цепочка прототипов\n' +
        'При создании объекта с помощью Object.create(), вы устанавливаете прототип для нового объекта. Цепочка прототипов позволяет объекту наследовать свойства и методы от его прототипа.\n' +
        '\n' +
        '- В приведенном выше примере, объект child содержит собственное свойство name, но для вызова метода greet он будет искать его в parent, потому что greet не определен в child.\n' +
        '\n' +
        '### Лексическое окружение и замыкания\n' +
        'Важно понимать, что при использовании прототипного наследования не следует путать контекст и области видимости. Свойства, добавленные к объекту, могут затмить одноименные свойства, наследуемые от прототипа, но возможности доступа к замыканиям и лексическому окружению остаются незатронутыми..',
      active: false,
    },
    {
      question: ' Что такое контекст функции?',
      response:
        'Контекст функции в JavaScript — это объект, который определяет, к каким данным имеет доступ функция, когда она вызывается. Контекст функции определяет значение слова this внутри функции. Понимание контекста является важным аспектом написания корректного и предсказуемого кода на JavaScript. Давайте разберемся с основными аспектами контекста функции подробнее.\n' +
        '\n' +
        '### 1. Виды контекста\n' +
        '\n' +
        '#### Глобальный контекст\n' +
        'Когда код выполняется вне функций, он работает в глобальном контексте. В браузере это объект window, а в Node.js — объект global.\n' +
        'Контекст функции\n' +
        'Когда функция вызывается, создается новый контекст. Значение this внутри функции зависит от того, как была вызвана функция.' +
        '2. Способы вызова функций и их влияние на контекст\n' +
        '\n' +
        '#### Простой вызов\n' +
        'При простом вызове функции (как в приведенном выше примере) контекст будет глобальным объектом (или undefined в строгом режиме).\n' +
        '\n' +
        '#### Метод объекта\n' +
        'Когда функция вызывается как метод объекта, this ссылается на объект, к которому принадлежит метод.' +
        'Конструктор\n' +
        'При вызове функции с оператором new, контекст this будет ссылаться на новый объект, создаваемый с помощью конструктора.' +
        'Привязка контекста\n' +
        'Функции можно явно привязывать к объектам с помощью методов call(), apply() и bind().' +
        'Стрелочные функции\n' +
        'Стрелочные функции не имеют собственного this. Они наследуют значение this от своего лексического окружения (т.е., от родительской функции или контекста, в котором они были созданы).' +
        '3. Контекст и области видимости\n' +
        'Контекст this не зависит от области видимости и определяет, каким образом функция была вызвана. Это важно отличать от переменных, которые имеют свою область видимости.',
      active: false,
    },
    {
      question: 'Каков результат выполнения var obj = Object.create(null);?',
      response:
        ' Выражение var obj = Object.create(null); создает новый объект obj, который не имеет прототипа. Это означает, что он не наследует никаких свойств и методов от стандартного объекта Object, таких как toString, hasOwnProperty, и других.\n' +
        '\n' +
        '### Объяснение:\n' +
        '\n' +
        '1. Создание объекта без прототипа:\n' +
        '- Object.create(null) создает пустой объект, который не имеет никаких свойств и методов, унаследованных от Object. Это делает его "чистым" объектом.\n' +
        '- Например, можно сказать, что это объект в "чистой" форме, без каких-либо дополнительных свойств.\n' +
        '\n' +
        '2. Результат:\n' +
        '- obj будет объектом, который не реагирует на стандартные методы и свойства объектного типа' +
        '3. Практическое применение:\n' +
        '- Использование объектов без прототипа может быть полезно, когда нужно создать контейнер для хранения данных, где вы не хотите, чтобы они конфликтовали с методами и свойствами, которые могут унаследоваться от Object.\n' +
        '- Это также важно в случаях, когда вы строите структуры данных (например, хеш-таблицы) и хотите избежать путаницы с методами, унаследованными от стандартного объекта.\n' +
        '\n' +
        '4. Итог:\n' +
        '- Создание объекта с использованием Object.create(null) позволяет вам избежать потенциальных проблем и обеспечить чистоту данных, что делает этот подход полезным в различных сценариях программирования',
      active: false,
    },
    {
      question: 'Как скопировать функцию со всеми свойствами?',
      response:
        'В JavaScript для копирования функции вместе со всеми её свойствами можно воспользоваться либо встроенными методами, либо инструментами, предоставляемыми языком. Однако стоит иметь в виду, что функции в JavaScript являются объектами, поэтому простое присваивание не скопирует их свойства. Ниже приведены несколько подходов к решению этой задачи:\n' +
        '\n' +
        '### 1. Использование Object.assign\n' +
        '\n' +
        'Можно использовать Object.assign для копирования всех свойств функции в новую функцию.2. Использование Function.prototype.bind\n' +
        '\n' +
        'Созданная с помощью bind функция будет иметь те же свойства, что и исходная функция' +
        '3. Использование ES6 class\n' +
        '\n' +
        'Если ваша функция является конструктором, вы можете создать новый класс, который будет наследовать её' +
        '4. Ручное копирование\n' +
        '\n' +
        'Если вам нужно сделать более комплексное копирование свойств, вы можете вручную перебрать иx' +
        'Все эти методы копируют только собственные свойства функции (если они есть). Унаследованные свойства, такие как методы прототипа, не будут скопированы.\n' +
        '- Копировать функции и их свойства следует с осторожностью, так как при изменениях в оригинальной функции изменения не отразятся на копии и наоборот.',
      active: false,
    },
    {
      question: 'Как выглядит модуль в JavaScript?',
      response:
        ' Модули в JavaScript представляют собой способ структурирования кода в отдельные файлы или модули и позволяют импортировать и экспортировать функции, объекты или переменные между этими модулями. С введением ECMAScript 6 (ES6) появилась официальная поддержка модулей в JavaScript, что сделало работу с модулями более удобной и понятной. Вот как выглядит модуль в JavaScript.\n' +
        '\n' +
        '### 1. Определение модуля\n' +
        '\n' +
        'Чтобы создать модуль, вам нужно использовать ключевые слова export и import.' +
        'a. Экспорт\n' +
        '\n' +
        'Вы можете экспортировать переменные, функции или классы, используя export. Это можно сделать либо по умолчанию, либо именованным образом.' +
        '2. Импорт модуля\n' +
        '\n' +
        'Теперь, когда у вас есть модули, вы можете их импортировать в другие модули.' +
        '3. Импорт всего модуля\n' +
        '\n' +
        'Вы также можете импортировать весь модуль как объект' +
        '4. Важно помнить\n' +
        '\n' +
        '- Расширение файлов: Важно добавить расширение .js, когда вы импортируете модули, если вы используете ES6 модули в браузере, который поддерживает модули.\n' +
        '- Корректная загрузка модулей: Для использования ES6 модулей в браузере используйте атрибут type="module" в script>:' +
        '5. Поддержка модулей\n' +
        '\n' +
        'Модули в JavaScript поддерживаются во всех современных браузерах и Node.js.',
      active: false,
    },
    {
      question: 'Какие способы назначения обработчиков событий вы знаете?',
      response:
        ' В JavaScript существует несколько способов назначения обработчиков событий на элементы DOM. Вот основные из них:\n' +
        '\n' +
        '### 1. Атрибуты HTML\n' +
        'Вы можете назначить обработчик события непосредственно в HTML-коде, используя атрибуты, такие как onclick, onmouseover и другие. Это старый способ, который может быть менее предпочтительным из-за смешивания разметки и логики.' +
        '2. Свойства DOM\n' +
        'Вы можете назначить обработчик события непосредственно через свойство элемента DOM' +
        '3. Метод addEventListener()\n' +
        'Это наиболее современный и гибкий способ назначения обработчиков событий. Он позволяет добавлять несколько обработчиков на одно событие и поддерживает захват событий.' +
        'Преимущества addEventListener():\n' +
        '- Можно добавлять несколько обработчиков событий для одного и того же элемента и события.\n' +
        '- Поддерживает параметры захвата и не всплытия.\n' +
        '- Легко удалять обработчики с помощью removeEventListener().' +
        '5. Стрелочные функции\n' +
        'При использовании ES6 стрелочных функций можно задавать обработчики событий более лаконично, особенно если вы используете их внутри других функций или методов.' +
        '6. Привязка событий в CSS\n' +
        'Некоторые события, такие как :hover, могут вызывать применение стилей CSS, но это не полноценные обработчики событий JavaScript. Однако это стоит упомянуть в контексте работы с событиями.\n' +
        '\n' +
        '### 7. Inline обработчики\n' +
        'Вы можете назначать обработчики событий непосредственно в HTML-коде с использованием on Event>, что также является старым методом.',
      active: false,
    },
    {
      question: 'Как предотвратить распространение события?',
      response:
        ' В JavaScript для предотвращения распространения события (всплытия) можно использовать два метода: stopPropagation() и stopImmediatePropagation(). Оба метода доступны на объекте события, который передается в обработчик. Вот как они работают:\n' +
        '\n' +
        '### 1. stopPropagation()\n' +
        '\n' +
        'Метод stopPropagation() предотвращает дальнейшее распространение события по дереву DOM. Если событие вызвано на элементе, этот метод предотвращает его всплытие к родительским элементам.' +
        '2. stopImmediatePropagation()\n' +
        '\n' +
        'Метод stopImmediatePropagation() не только предотвращает всплытие события, но и останавливает выполнение всех остальных обработчиков событий, назначенных на тот же элемент для того же события.' +
        ' Используйте stopPropagation(), когда вам нужно остановить всплытие события, но продолжить выполнение других обработчиков на том же элементе.\n' +
        '- Используйте stopImmediatePropagation(), если вы хотите остановить не только всплытие, но и выполнение остальных обработчиков на текущем элементе.',
      active: false,
    },
    {
      question:
        'Как отменить стандартное дествие браузера при наступлении события?\n',
      response:
        'Для отмены стандартного действия браузера при наступлении события в JavaScript вы можете использовать метод preventDefault() объекта события. Этот метод предотвращает выполнение стандартного действия, связанного с конкретным событием.' +
        ' Например, если вы хотите отменить отправку формы, переход по ссылке или использование клавиши в текстовом поле.',
      active: false,
    },
    {
      question: ' Как получить тэг html?',
      response:
        'Для получения (или создания) HTML-тегов можно использовать различные подходы в зависимости от контекста: разработки веб-страниц или взаимодействия с DOM (Document Object Model) с помощью JavaScript. Ниже приведены основные способы получения HTML-тегов.\n' +
        '\n' +
        '### 1. Получение HTML-тегов с помощью JavaScript\n' +
        '\n' +
        'Чтобы получить элементы HTML на веб-странице с помощью JavaScript, вы можете использовать следующие методы:\n' +
        '\n' +
        '- document.getElementById(): Получает элемент по уникальному значению атрибута id.\n' +
        '- document.getElementsByClassName(): Получает все элементы с указанным классом.' +
        '- document.getElementsByTagName(): Получает все элементы по имени тега.' +
        '- document.querySelector(): Получает первый элемент, соответствующий указанному CSS-селектору.\n' +
        '- document.querySelectorAll(): Получает все элементы, соответствующие указанному CSS-селектору.' +
        '3. Создание HTML-тегов\n' +
        '\n' +
        'Для создания новых HTML-элементов с помощью JavaScript вы можете использовать метод document.createElement()',
      active: false,
    },
    {
      question:
        'Какое событие позволяет отловить загрузку страницы? (разница между onload и\n' +
        'DocumentContentLoaded)\n',
      response:
        ' В JavaScript для отслеживания загрузки страницы используются два основных события: onload и DOMContentLoaded. Оба события относятся к загрузке документа, но они имеют разные триггеры и цели. Ниже приведено их сравнение и объяснение:\n' +
        '\n' +
        '\n' +
        '\n' +
        '### 1. onload\n' +
        '\n' +
        '- Триггер: Событие onload срабатывает, когда весь документ, включая все его ресурсы (такие как изображения, стили, скрипты и т. д.), полностью загружен. Это означает, что браузер закончил загрузку всех аспектов страницы.\n' +
        '- Использование: Обычно используется для выполнения скриптов, которые требуют, чтобы вся страница и все её ресурсы были загружены до их выполнения. Например, инициализация слайдеров изображений или выполнение каких-то функций, которые зависят от загруженных изображений.' +
        '2. DOMContentLoaded\n' +
        '\n' +
        '- Триггер: Событие DOMContentLoaded срабатывает, когда HTML-документ полностью загружен и разобран, без ожидания завершения загрузки стилей, изображений и других ресурсов. Это происходит раньше, чем событие onload.\n' +
        '- Использование: Обычно используется для инициализации интерфейса или выполнения скриптов, которые не зависят от загрузки внешних ресурсов. Это позволяет ускорить реакцию страницы на действия пользователя.' +
        'ыбор между onload и DOMContentLoaded зависит от требуемой логики приложения. Если нужно дождаться загрузки всех ресурсов, используйте onload. Если достаточно дожидаться загрузки HTML, лучше использовать DOMContentLoaded для повышения производительности и лучшей отзывчивости интерфейса.',
      active: false,
    },
    {
      question: 'Как подписаться на событие OnLoad?\n',
      response:
        'Подписаться на событие onload можно несколькими способами в JavaScript. Вот основные подходы, которые можно использовать для этого:\n' +
        '\n' +
        '### 1. Использование атрибута в HTML\n' +
        'Вы можете добавить атрибут onload к тегу body> в HTML-коде' +
        '2. Использование свойства window.onload\n' +
        'Вы можете назначить обработчик события onload через свойство window.onload в JavaScript' +
        'Этот метод заменяет предыдущий обработчик onload, если он был установлен. Если необходимо добавить несколько обработчиков, используйте другой способ, описанный ниже.\n' +
        '\n' +
        '### 3. Использование addEventListener\n' +
        'Самый рекомендуемый и гибкий способ — использовать метод addEventListener. Это позволяет вам добавлять несколько обработчиков для одного события и не заменяет предыдущие обработчики' +
        'Этот метод также позволяет указать дополнительные параметры, такие как использование фазы захвата события и возможность удаления обработчика.' +
        'Для подписки на событие onload лучше использовать метод addEventListener, так как он предоставляет много преимуществ, включая возможность добавления нескольких обработчиков и лучшую совместимость с современными стандартами JavaScript.',
      active: false,
    },
    {
      question: 'Как можно перебрать коллекцию html элементов',
      response:
        'еребрать коллекцию HTML-элементов можно с помощью различных методов и подходов в JavaScript. Ниже приведены некоторые из наиболее распространенных способов:\n' +
        '\n' +
        '### 1. Использование цикла for\n' +
        'Это один из самых простых и интуитивно понятных способов перебора коллекции. Например, если у вас есть коллекция элементов, полученная с помощью getElementsByClassName или getElementsByTagName, вы можете использовать for цикл' +
        '2. Использование цикла forEach\n' +
        'Если вы используете метод querySelectorAll, он возвращает NodeList, на который можно применить метод forEach для перебора элементов' +
        '3. Использование цикла for-of\n' +
        'Если вы хотите использовать более современный подход, можно воспользоваться циклом for-of для перебора коллекции. Это также возможно с NodeList или с массивами' +
        '4. Преобразование в массив\n' +
        'Если вы используете коллекции, которые не поддерживают методы массивов (например, getElementsByClassName или getElementsByTagName), вы можете преобразовать их в массив, а затем использовать forEach',
      active: false,
    },
    {
      question: 'Как перевести html коллекцию в массив',
      response:
        'HTML-коллекцию можно перевести в массив несколькими способами в JavaScript. Такие коллекции часто возвращаются методами, такими как getElementsByClassName, getElementsByTagName и children. Поскольку эти коллекции являются живыми списками (Live NodeList), они не поддерживают методы массива, такие как forEach, map, и т. д. Поэтому их необходимо преобразовать в массив. Вот несколько способов сделать это:\n' +
        '\n' +
        '### 1. Использование Array.from()\n' +
        'Метод Array.from() создает новый массив из объектов, которые имеют итератор или являются массивоподобными.' +
        '2. Использование оператора расширения ... (Spread Operator)\n' +
        'Оператор расширения позволяет развернуть массивоподобные объекты в массив.' +
        '3. Использование обычного цикла для создания массива\n' +
        'Вы можете создать новый массив и передать в него элементы из коллекции с помощью обычного цикла.',
      active: false,
    },
    {
      question: 'Разница между атрибутами async элемента script>?',
      response:
        'Атрибуты async и defer элемента script> в HTML используются для управления загрузкой и выполнением JavaScript на веб-странице. Хотя оба атрибута позволяют загружать скрипты асинхронно, они работают по-разному. Вот основные различия между ними:\n' +
        '\n' +
        '### 1. async\n' +
        '- Загрузка: Скрипт с атрибутом async загружается асинхронно по мере того, как страница загружается. Это означает, что браузер продолжает загружать HTML-документ, не дожидаясь полной загрузки скрипта.\n' +
        '- Исполнение: Скрипт выполняется сразу после его загрузки, что может произойти до того, как будет завершена загрузка всего HTML-документа. Поэтому порядок выполнения не гарантирован, если у вас несколько скриптов ' +
        'с атрибутом async. Можно сказать, что скрипт будет выполняться, как только он будет готов, независимо от того, были ли загружены более ранние или поздние скрипты.. defer\n' +
        '- Загрузка: Скрипт с атрибутом defer также загружается асинхронно, чтобы не блокировать загрузку HTML-документа.\n' +
        '- Исполнение: Однако в отличие от async, скрипт с атрибутом defer выполняется только после того, как весь HTML-документ будет полностью загружен и разобран. Таким образом, все скрипты с defer выполняются в порядке, в котором они записаны в документе.' +
        'Порядок выполнения\n' +
        'Чтобы подвести итоги:\n' +
        '- Скрипты с async выполняются по мере загрузки (порядок не гарантируется).\n' +
        '- Скрипты с defer выполняются в порядке их появления в документе, только после завершения загрузки всего HTML.' +
        'Используйте async, если порядок выполнения скриптов не важен и вы хотите ускорить загрузку страницы, и defer, когда вам важно, чтобы скрипты выполнялись после загрузки полного HTML-документа, сохраняя при этом порядок их обработки.',
      active: false,
    },
    {
      question: '',
      response: '',
      active: false,
    },
    {
      question: 'Какие методы выборки элементов DOM вы знаете?',
      response:
        'В JavaScript есть несколько методов для выборки элементов из DOM (Document Object Model). Вот основные из них:\n' +
        '\n' +
        '### 1. getElementById()\n' +
        'Этот метод возвращает элемент с указанным идентификатором (id).' +
        '2. getElementsByClassName()\n' +
        'Этот метод возвращает коллекцию всех элементов с указанным классом. Обратите внимание, что он возвращает "живую" коллекцию, которая обновляется при изменении DOM.' +
        '3. getElementsByTagName()\n' +
        'Этот метод возвращает коллекцию всех элементов с указанным тегом. Также возвращает "живую" коллекцию.' +
        '4. querySelector()\n' +
        'Этот метод возвращает первый элемент, соответствующий указанному CSS-селектору. Если элемент не найден, возвращает null.\n' +
        '5. querySelectorAll()\n' +
        'Этот метод возвращает статическую коллекцию всех элементов, соответствующих указанному CSS-селектору. В отличие от getElementsByClassName() и getElementsByTagName(), эта коллекция не обновляется при изменении DOM.' +
        '6. childNodes\n' +
        'Это свойство возвращает коллекцию всех дочерних узлов элемента, включая текстовые узлы и комментарии.' +
        '7. firstChild, lastChild\n' +
        'Эти свойства возвращают первый и последний дочерний узел элемента соответственно.' +
        '8. children\n' +
        'Это свойство возвращает коллекцию всех дочерних элементов элемента, исключая текстовые узлы и комментарии.' +
        '9. firstElementChild, lastElementChild\n' +
        'Эти свойства возвращают первый и последний дочерний элемент соответственно, игнорируя текстовые узлы.',
      active: false,
    },
    {
      question: 'Как добавить новый элемент DOM в дерево?',
      response:
        'Добавление нового элемента в дерево DOM в JavaScript можно сделать с помощью методов, которые предоставляют API DOM. Вот основные шаги, как это сделать:\n' +
        '\n' +
        '### 1. Создание нового элемента\n' +
        '\n' +
        'Для создания нового элемента используется метод createElement()' +
        '2. Настройка нового элемента\n' +
        '\n' +
        'Вы можете добавить текст, атрибуты или классы к новому элементу:\n' +
        '\n' +
        '\n' +
        "newElement.textContent = 'Hello, World!'; // Добавляет текстовое содержимое\n" +
        "newElement.className = 'my-class'; // Устанавливает класс\n" +
        "newElement.setAttribute('id', 'my-id'); // Устанавливает атрибут id" +
        '3. Выбор родительского элемента\n' +
        '\n' +
        'Теперь необходимо выбрать элемент, в который вы хотите добавить новый элемент. Это можно сделать с помощью одного из методов выбора элементов, таких как getElementById(), querySelector() и т. д.:\n' +
        '\n' +
        '\n' +
        "const parentElement = document.getElementById('parent'); // Выбор родительского элемента" +
        '4. Добавление нового элемента в DOM\n' +
        '\n' +
        'Теперь, когда у вас есть новый элемент и родительский элемент, вы можете добавить новый элемент в дерево DOM с помощью методов appendChild(), insertBefore(), или append():\n' +
        '\n' +
        '#### Использование appendChild()parentElement.appendChild(newElement); // Добавляет новый элемент как последний дочерний элемен' +
        ' Использование insertBefore()\n' +
        '\n' +
        'Если вы хотите вставить элемент перед определенным дочерним элементом:\n' +
        '\n' +
        '\n' +
        "const referenceElement = document.getElementById('reference');\n" +
        'parentElement.insertBefore(newElement, referenceElement); // Вставляет новый элемент перед referenceElement' +
        '#### Использование append()\n' +
        '\n' +
        'append() можно использовать для добавления одного или нескольких элементов в конец родительского элемента. Также он позволяет добавлять текст:',
      active: false,
    },
    {
      question: 'Объяснить как работать с AJAX запросами в JS',
      response:
        'AJAX (Asynchronous JavaScript and XML) позволяет выполнять асинхронные запросы к серверу без необходимости перезагрузки страницы. В JavaScript для работы с AJAX-запросами можно использовать как устаревший объект XMLHttpRequest, так и более современный Fetch API. Давайте рассмотрим оба способа.\n' +
        '\n' +
        '### 1. Использование XMLHttpRequest\n' +
        'Вот пример использования объекта XMLHttpRequest для выполнения AJAX-запроса:' +
        '2. Использование Fetch API\n' +
        'Fetch API упрощает выполнение запросов и возвращает Promise, что позволяет использовать более современный стиль работы с асинхронным кодом (например, через .then() и async/await).' +
        '3. Использование async/await с Fetch API\n' +
        'Можно сделать код еще более читаемым, используя async/await' +
        '4. Отправка данных на сервер\n' +
        'Чтобы отправить данные на сервер с использованием Fetch API, вы можете использовать метод POST.',
      active: false,
    },
    {
      question: 'element.cloneNode — как копируются свойства элемента?',
      response:
        'Метод cloneNode() в JavaScript используется для создания клона (копии) элемента и может копировать его свойства и структуру. Давайте подробнее рассмотрим, как работает этот метод и какие свойства копируются при клонировании элементов.\n' +
        '\n' +
        '### 1. Синтаксис\n' +
        '\n' +
        'Метод cloneNode() принимает один параметр:\n' +
        '\n' +
        '- deep (boolean) — если true, производится глубокое клонирование, включая все дочерние элементы. Если false (по умолчанию), то клонируется только сам элемент без его дочерних узлов.\n' +
        '2. Что копируется?\n' +
        '\n' +
        '- Атрибуты: Все атрибуты оригинального элемента (например, id, class, data-* и другие пользовательские атрибуты) будут скопированы в клоне. Однако, значения свойства id могут не сработать должным образом, если у вас уже есть элемент с таким же id в документе. Это может также вызвать проблемы с уникальностью.\n' +
        '\n' +
        '- События: Событие не копируется. Например, если на оригинальном элементе установлены обработки событий (например, с помощью addEventListener), они не будут перенесены на клон. Необходимо отдельно привязывать обработчики событий к клону.\n' +
        '\n' +
        '- Дочерние элементы: Если параметр deep установлен в true, все дочерние элементы и их атрибуты также будут скопированы. Если false, клонируется только сам элемент без его содержимого.\n' +
        '\n' +
        '- Стили (inline): Инлайновые стили (например, стиль, указанный непосредственно в атрибуте style элемента) будут скопированы. Однако, стили, применяемые через CSS-классы, не будут скопированы. Клон будет наследовать стили, применяемые к классу, если к нему применены те же классы.' +
        'етод cloneNode() предоставляет удобный способ клонирования DOM-элементов с учетом их атрибутов, но не копирует обработчики событий. Для полной функциональности, особенно если вам нужны события, придется добавлять обработчики отдельно для клонированного элемента.',
      active: false,
    },
    {
      question: 'События, работа с DOM',
      response:
        'Работа с DOM (Document Object Model) и событиями — это ключевые аспекты взаимодействия с веб-страницами на JavaScript. В этой области вы можете манипулировать элементами документа, изменять их содержимое и реагировать на действия пользователя. Давайте подробнее рассмотрим эти концепции.\n' +
        '\n' +
        '### 1. Что такое DOM?\n' +
        '\n' +
        'DOM — это объектная модель документа, которая представляет структуру документа HTML или XML в виде дерева объектов. Каждый элемент на странице, будь то текст, кнопка или изображение, представлен как узел в этой структуре. Это позволяет скриптам взаимодействовать с элементами страницы.\n' +
        '\n' +
        '### 2. Основные методы работы с DOM\n' +
        '\n' +
        'Вот несколько основных методов для работы с DOM в JavaScript:\n' +
        '\n' +
        '- Получение элементов\n' +
        "- document.getElementById('id'): Получает элемент по его ID.\n" +
        "- document.getElementsByClassName('class'): Получает коллекцию элементов по имени класса.\n" +
        "- document.getElementsByTagName('tag'): Получает коллекцию элементов по тэгу.\n" +
        "- document.querySelector('selector'): Получает первый элемент, соответствующий селектору CSS.\n" +
        "- document.querySelectorAll('selector'): Получает все элементы, соответствующие селектору CSS.\n" +
        '\n' +
        '- Изменение содержимого\n' +
        '- element.innerHTML: Изменяет HTML-содержимое элемента.\n' +
        '- element.textContent: Изменяет текстовое содержимое элемента.\n' +
        '\n' +
        '- Изменение стилей\n' +
        "- element.style.property: Позволяет изменять стили элемента, например: element.style.color = 'red';.\n" +
        '\n' +
        '- Создание и добавление элементов\n' +
        "- document.createElement('tag'): Создает новый элемент.\n" +
        '- parentElement.appendChild(childElement): Добавляет элемент как дочерний к указанному родителю.\n' +
        '\n' +
        '- Удаление элементов\n' +
        '- element.remove(): Удаляет элемент из DOM.\n' +
        '- parentElement.removeChild(childElement): Удаляет дочерний элемент из родителя.\n' +
        '\n' +
        '### 3. События в JavaScript\n' +
        '\n' +
        'События — это действия или действия пользователя, которые могут происходить на веб-странице, такие как щелчки мыши, нажатия клавиш,' +
        ' наведение указателя на элемент и т.д. JavaScript позволяет вам реагировать на эти события с помощью обработчиков событий.',
      active: false,
    },
    {
      question: 'Манипуляции с DOM',
      response:
        'Dom - поиск через getElementById - по id, querySelector - по селектору, querySelectorAll\n' +
        'getElementByClassName - по имени класса  getElementByTagName - по тегу\n' +
        'создание элемента Dom - document.createElement(tag).className(класс).innerHtml(текст)\n' +
        'чтобы его вставить body.append - добавляем в конец, prepend - в начало, before -  до, after- после\n' +
        '\n' +
        'Изменение replaseWith, cloneNode\n' +
        'удаление через element.remove()\n' +
        'добавление классов - element.classList.add/remove/sidebar.component.ts\n',
      active: false,
    },
    {
      question: 'Какие способы реализации ООП есть в JS(ES6) ',
      response:
        'ООП в JS - наследование prototype,  у классов через new\n' +
        'Инкапсуляция  - через #приватные поля и методы в классе',
      active: false,
    },
    {
      question: 'Как устроена асинхронность в js',
      response:
        'Асинхронность в JavaScript — это важная концепция, которая позволяет выполнять операции' +
        ' не блокируя основной поток выполнения кода. Это особенно полезно при работе с такими задачами,' +
        ' как запросы к серверу, работа с файловой системой, таймеры и другие действия, которые могут занять ' +
        'неопределённое время. JavaScript использует несколько механизмов для работы с асинхронностью:\n' +
        '\n' +
        '### Обработка событий (Event Loop)\n' +
        '\n' +
        'JavaScript работает в однопоточном режиме, что означает, что он выполняет один поток кода за раз. ' +
        'Чтобы справляться с асинхронными операциями, используется система событий и цикл событий (Event Loop).\n' +
        '\n' +
        '- Call Stack: Это стек вызовов, который хранит текущие функции, которые выполняются. Когда функция' +
        ' вызывается, она помещается в стек, а когда завершается, удаляется из стека.\n' +
        '\n' +
        '- Web APIs: Когда происходит асинхронное выполнение (например, HTTP-запрос), это передаётся соответствующему ' +
        'API, который работает независимо, не блокируя основной поток JavaScript.\n' +
        '\n' +
        '- Callback Queue: Когда асинхронная операция завершена, соответствующий callback помещается в очередь обратных' +
        ' вызовов (callback queue).\n' +
        '\n' +
        '- Event Loop: Цикл событий движется между стеком вызовов и очередью обратных вызовов. Когда стек пуст, Event Loop' +
        ' берёт функцию из очереди и помещает её в стек для выполнения.' +
        'Функции обратного вызова (callbacks) — это функции, которые передаются как аргументы в другие функции,' +
        ' чтобы быть вызванными позже, когда операция будет завершена.',
      active: false,
    },
    {
      question: 'Функциональные конструкции map,reduce,filter',
      response:
        ' Метод reduce() применяет функцию reducer к каждому элементу массива' +
        ' (слева-направо), возвращая одно результирующее значение.' +
        'Метод filter() создаёт новый массив со всеми элементами, ' +
        'прошедшими проверку, задаваемую в передаваемой функции.' +
        ' Метод map вызывает переданную функцию callback один раз ' +
        'для каждого элемента, в порядке их появления и конструирует новый массив из результатов функции',
      active: false,
    },
    {
      question: 'Работа с ассинхронностью',
      response:
        '' +
        'Promise - специальный обьект  в JS, для работы с ассинхронностью\n' +
        'у него есть состояние - pending(в процессе ), reject(ошибка), fullfield(успешно)\n' +
        'методы then(), catch(), finally()  чейнинг(цепочка вызовов) - then().then()\n' +
        'new Promise((res, rej) => {})  два колбека res, rej  он срабатывает один раз и неизменяем либо resolve или reject\n' +
        '.all([]) - ждет пока все пройдут, если один с ошибкой выдаст ошибку\n' +
        '.race() - выдаст результат первого промиса\n' +
        '.allSetled() - покажет результат всех и их статусы',
      active: false,
    },
    {
      question: 'Async/await',
      response:
        'async/await - специальный синтаксис над промисом\n' +
        'async function() {return } - зарезолвленный промис\n' +
        'await - аналог .then() - у промиса\n' +
        'обработчик ошибок try/catch внутри' +
        'async/await — это синтаксический сахар в JavaScript, который упрощает работу с промисами и делает асинхронный код более читаемым и удобным для написания. Давайте подробнее рассмотрим, как это работает, как его использовать и чем он удобен.\n' +
        '\n' +
        '### Основные концепции async и await\n' +
        '\n' +
        '1. async:\n' +
        '- Ключевое слово async используется для определения функции как асинхронной.\n' +
        '- Асинхронная функция всегда возвращает промис. Если она возвращает значение, это значение автоматически упаковывается в промис, разрешенный с этим значением.\n' +
        '- Если в асинхронной функции выбрасывается ошибка, промис будет отклонён с этой ошибкой.\n' +
        '\n' +
        '2. await:\n' +
        '- Ключевое слово await используется для ожидания завершения промиса.\n' +
        '- Оно может использоваться только внутри асинхронной функции.\n' +
        '- await приостанавливает выполнение функции, пока промис не будет выполнен (либо разрешён, либо отклонён).\n' +
        '- Если при ожидании промиса возникает ошибка, она будет выброшена, и вы можете обработать её через блок try...catch.' +
        'Преимущества использования async/await\n' +
        '\n' +
        '1. Читаемость: Код выглядит более линейно и легко читается, как обычный синхронный код, что упрощает его понимание.\n' +
        '2. Простота обработки ошибок: Использование try...catch облегчает обработку ошибок по сравнению с использованием метода .catch() с промисами.\n' +
        '3. Упрощение работы с цепочками промисов: С async/await можно избежать "адов колбеков" и глубоких вложенных структур, упрощая структуру кода.\n' +
        '\n' +
        '### Важно помнить:\n' +
        '\n' +
        '- В большинстве случаев, если вы используете await, вы должны обрабатывать ошибки с помощью try...catch.\n' +
        '- await может быть использован только внутри функций, помеченных как async.\n' +
        '- Вы также можете параллельно выполнять несколько промисов с использованием Promise.all(), чтобы дождаться их выполнения, но это не требует использования await для каждого промиса.\n',
      active: false,
    },
    {
      question:
        'Способы оптимизации работы с Dom.  Список самых дорогих операций',
      response:
        'добавление в Dom после рендеринга  - нужно использовать  documentFragment\n' +
        'слишком частые события window.resize - использовать debounce()\n' +
        '\n' +
        'Узлы дом необходимо создавать только при их необходимости а как только в них отпала надобность, удаляем\n' +
        '\n' +
        'Подгружать узлы по мере необходимости пользователю\n' +
        '\n' +
        'Сокращение объёма  сложных вычислительных стилей',
      active: false,
    },
    {
      question: 'Modules, Proxy, Reflect,',
      response:
        'Модули - файл с use strict режимом, у них есть импорт и экспорт\n' +
        'Proxy - спец. обьект для перехвата и переопределения основных операций\n' +
        'new Proxy(obj, handler) reflect -часто используют вместе с proxy внутри надстройка',
      active: false,
    },
    {
      question: 'localStorage, sessionStorage, cookie',
      response:
        'localStorage - хранит данные без срока годности session- во время жизни вкладки, если дублировать вкладку создаст для каждой\n' +
        "setItem('key', содержимое) - закинуть, getItem('ключ') - забрать\n" +
        'cookie - хранит данные, которые должны быть отправлены обратно на сервер последующими запросами\n' +
        'Если установить флаг httpOnly -true - для файла то предотвратит доступ на стороне клиента, добавляется  через document.coockie',
      active: false,
    },
    {
      question: 'Сборщик мусора  ',
      response:
        'Сборщик мусора периодически находит ' +
        'объекты, которые больше не доступны в контексте ' +
        'выполнения программы, и автоматически освобождает связанную с ними память',
      active: false,
    },
    {
      question: 'repaint, reflow',
      response:
        'repaint -перерисовка элементов стили визуальный слой, ' +
        'без изменения размеров(это процесс, в ходе которого браузер отрисовывает (перерисовывает) визуальное представление' +
        ' элемента. Происходит, когда изменяются визуальные стили элемента, не влияющие на его размеры или положение.)\n' +
        'reflow - перерисовка макета страницы(Reflow — это процесс, в ходе которого' +
        ' браузер вычисляет размеры и позиции элементов на странице. Он происходит, когда' +
        ' изменяются какие-либо свойства, влияющие на расположение (размеры, границы, отступы, содержание и т. д.) элементов на странице.)' +
        'Оптимизация\n' +
        '\n' +
        'Чтобы минимизировать количество reflow и repaint, следует следовать ряду рекомендаций:\n' +
        '\n' +
        '- Структура изменений: Группируйте изменения стилей и добавления/удаления элементов, чтобы избежать множественных перерисовок.\n' +
        '- Избегайте частых изменений в циклах: Если необходимо много раз изменить стиль в цикле, лучше собрать все изменения и применить их за один раз.\n' +
        '- Используйте requestAnimationFrame: Для анимаций это позволяет браузеру оптимально справляться с обновлением интерфейса.\n' +
        '- Работайте с классовыми селекторами: Изменение класса может затронуть несколько стилий одновременно и сэкономить ресурсы на перерисовку.\n' +
        '- Минимизируйте зависимости: Будьте внимательны с событиями, которые могут вызвать восприятие изменений интерфейса.\n',
      active: false,
    },
    {
      question: 'Web Assembly',
      response:
        'язык программирования низкого уровня, призванный внести программируемость ' +
        'туда, где нужны кроссплатформенность,' +
        ' эффективность и безопасность, в первую очередь на клиентскую сторону Всемирной паутины.WebAssembly — это мощный инструмент, который расширяет ' +
        'возможности веб-разработки' +
        ', позволяя использовать более производительные и эффективные языки, а также обеспечивая отличную совместимость с существующим' +
        ' JavaScript. Он открывает новые возможности ' +
        'для создания современных высокопроизводительных веб-приложений и идеально подходит для сценариев, требующих высоких вычислительных затрат.',
      active: false,
    },
  ],
  active: false,
};
