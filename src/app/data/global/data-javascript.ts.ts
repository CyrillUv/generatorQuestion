import { IDataQuestion } from '../question/type';

export const dataJS: IDataQuestion = {
  name: 'JavaScript',
  questions: [
    {
      question: 'Что такое JavaScript?',
      response:
        'Это язык программирования с ' +
        'динамической типизацией, однопоточный',
      active: false,
    },
    {
      question: 'Типы данных',
      response:
        '1.Строка\n' +
        '2.Число\n' +
        '3.BigInt(большое число)\n' +
        '4.Boolean(логическое)\n' +
        '5.Null\n' +
        '6.Undefined(не определено)\n' +
        '7.Symbol(символ)\n' +
        '8.Object(обьект)',
      active: false,
    },
    {
      question: 'Отличие null от undefined ',
      response:
        'undefined - отсутствие значение, null - намеренное присвоение' +
        'undefined:\n' +
        '- Обычно используется системой или движком JavaScript, чтобы указать, что что-то не было инициализировано или не было установлено.\n' +
        '- Это может происходить, когда функция не возвращает значение (в этом случае возвращается undefined по умолчанию).\n' +
        '\n' +
        '- null:\n' +
        '- Используется программистами для указания на отсутствие значения.\n' +
        '- Чаще всего применяется в логике программы, чтобы обозначить, что значение было удалено или не установлено по какой-то причине.',
      active: false,
    },
    {
      question: 'Prototype ',
      response:
        'Прототип — это один из основных механизмов наследования в JavaScript. Он позволяет объектам делиться свойствами и методами' +
        ' друг с другом. Давайте подробнее рассмотрим, как работает система прототипов, и как ее можно использовать в ваших программах.\n' +
        '\n' +
        '### 1. Основные понятия\n' +
        '\n' +
        '- Прототип: В JavaScript каждый объект имеет свойство, называемое prototype, которое ссылается на другой объект. Это позволяет объекту' +
        ' наследовать свойства и методы от прототипного объекта.\n' +
        '\n' +
        '- Прототипное наследование: При попытке доступа к свойству объекта JavaScript сначала ищет это свойство в самом объекте. Если оно не' +
        ' найдено, поиск продолжается в прототипе объекта. Этот процесс может продолжаться до тех пор, пока не будет найдено' +
        ' значение или не будет достигнут конец цепочки прототипов.' +
        'Цепочка прототипов — это процесс, при котором JavaScript проверяет объект и его прототипы, пока не найдет свойство или не достигнет ' +
        'конца цепи.' +
        ' Проверка прототипов\n' +
        '\n' +
        'Вы можете использовать метод isPrototypeOf() для проверки, является ли объект прототипом другого объекта.' +
        'Прототипы встроенных объектов\n' +
        '\n' +
        'Встроенные объекты в JavaScript, такие как Array и Function, также используют прототипы. Вы можете расширять эти' +
        ' объекты, добавляя свои собственные методы в их прототипы.' +
        '\n' +
        'Прототипы — это мощный инструмент в JavaScript, который позволяет реализовывать наследование и делиться методами и свойствами между объектами.' +
        ' Понимание системы прототипов поможет вам лучше структурировать ваш код и воспользоваться преимуществами динамической природы JavaScript.',
      active: false,
    },
    {
      question: 'this,call,apply,bind',
      response:
        'this - контекст, ссылка на обьект\n' +
        'call, apply  - методы функции (this, arguments) или (this, [...arguments]) сразу вызываются\n' +
        'bind - можно забиндить и вызвать после' +
        ' В JavaScript ключевыми концепциями, связанными с контекстом выполнения функций, являются this, а также методы call, apply и bind. Все они позволяют управлять значением this в функциях, и вот как они работают в деталях.\n' +
        '\n' +
        '### 1. Значение this\n' +
        '\n' +
        'this в JavaScript — это специальная переменная, которая ссылается на объект, который в данный момент выполняет код. Значение this может изменяться в зависимости от того, как вызывается функция:\n' +
        '\n' +
        '- В глобальном контексте (вне функции) this ссылается на глобальный объект (в браузере это window).\n' +
        "- В функции, вызванной в строгом режиме ('use strict'), this будет undefined.\n" +
        '- В методах объекта this ссылается на объект, к которому принадлежит метод.\n' +
        '- В обработчиках событий this ссылается на элемент, на который было нажато.' +
        ' Метод call()\n' +
        '\n' +
        'Метод call() позволяет вызвать функцию с указанным значением this и аргументами, переданными по отдельности.' +
        '- Первый аргумент для apply() — это значение this.\n' +
        '- Второй аргумент — массив аргументов, которые передаются функции.' +
        ' Метод bind()\n' +
        '\n' +
        'Метод bind() создает новую функцию, которая, когда вызывается, имеет установленное значение this, а также предустановленные начальные аргументы.' +
        '- bind() возвращает новую функцию, к которой применяются переданные аргументы. Это полезно, когда вы хотите привязать функцию к определенному контексту,' +
        ' но вы не хотите, чтобы она выполнялась немедленно.' +
        'Примечания:\n' +
        '\n' +
        '1. Строгий режим: в строгом режиме значение this для функции, вызванной без контекста (например, show()), будет undefined, в отличие от нестрогого режима, где это будет ссылка на глобальный объект.\n' +
        '2. Различия между call() и apply(): call() и apply() делают одно и то же, но apply() принимает массив аргументов, в то время как call() принимает их по отдельности.\n' +
        '3. Использование bind(): Часто используется для передачи обработчиков событий.' +
        'Методы call(), apply() и bind() дают возможность гибко управлять контекстом выполнения функции в JavaScript. Понимание этих концепций важно для работы с объектами и функциями, что позволяет предотвращать ошибки,' +
        ' связанные с неправильным значением this.',
      active: false,
    },
    {
      question:
        'const, let, arrow fn, class, шаблонные строки, spread, rest, итератор, генератор ',
      response:
        'const и let - ключевые слова let - можно обьявить,присвоить значение позже, также можно переприсвоить\n' +
        'const - начальное значение нужно, переприсвоить не получится, только обьект или массив\n' +
        'const && let - блочной области видимости\n' +
        'arrow fn(стрелочная функция ) -  () => {} нет своего контекста ,запоминает где была обьявлена, нет методов функций, аргументс,\n' +
        'более короткая запись, анонимна\n' +
        'spread - не глубокое копирование [...spread] || {...spread}\n' +
        'rest  - когда мы не знаем сколько у нас аргументов - используем rest ( function(a, ...rest){} )' +
        '\n' +
        'Генератор - это функция, которая можно запустить приостановить и возобновить на разных стадиях выполнения. Первый вызов функции вызовет итератор,' +
        ' у этого обьекта есть next для возобновления функции. При каждом вызове функция возобновляет свою' +
        ' работу пока не наткнется на yield и опять станет на паузу ',
      active: false,
    },
    {
      question:
        'Два подхода к обработке событий в DOM(onevent,addEventListener).Пользовательские события.Стадии прохода события',
      response:
        'События в JS - погружение и всплытие\n' +
        '1.onEvent - можно на элемент накинуть событие onClick\n' +
        '2.addEventListener - вешаем на элемент, далее пока не отпишемся через removеEventListener\n' +
        "element.addEventListener('событие (click)', функция которая наблюдает за событием (() => {}))\n" +
        '\n' +
        'Пользовательские события - \n' +
        '\n' +
        'new Event(”клик”, [опции]) опции - bubbles - true/false всплытие \n' +
        '\n' +
        'eanaeleble true/false \n' +
        '\n' +
        'composed-событие будет вставать за пределы shadow DOM метод dispatchEvent запускает событ[ие на элементе](http://8.web/)\n' +
        '\n' +
        'Стадии события\n' +
        '\n' +
        ' 1.погружение только addEventListener\n' +
        '\n' +
        '2.целевая фаза-все\n' +
        '\n' +
        '3.фаза всплытие - с add по capture \n',
      active: false,
    },
    {
      question: 'Web Worker ',
      response:
        'aссинхронная система позволяет выполнять тяжелые в вычислительном плане и длительные задачи\n' +
        'без блокировки потока пользовательского интерфейса. При их использовании вычисления идут параллельно.\n' +
        'Это своего рода многопоточность. Web Workers - не являются частью JS, они представляют собой возможность браузера,\n' +
        'к которой можно получить доступ посредством JS - new Worker() - они должны быть в отдельном файле ,воркеры\n' +
        'выполняются в изолированных потоках  в браузере\n' +
        'Для запуска - worker.postMessage() для отправки в основной поток   (DOM && Window -  для них недоступны)\n' +
        '\n' +
        'onMessage слушатель в основном потоке для получения сообщений от воркера terminate() завершает работу воркера \n' +
        '\n',
      active: false,
    },
    {
      question: 'Новые типы данных',
      response:
        '.new Map() - коллекция ключ/значение  - ключ любого типа\n' +
        ".set(ключ, значение) - новое записать .get('ключ') - найти  clear() - очистить  .size() - размер  .delete('ключ') -  удалить\n" +
        'new Set() - коллекция уникальных значений, без ключей\n' +
        'WeakMap() - ключи обьекты, если мы запишем значение null - то будет удален автоматом сборщиком мусора\n' +
        'нет методов перебора keys(), values(), entries(), только get, set, delete\n' +
        'WeakSet() - коллекция уникальных обьектов',
      active: false,
    },
    {
      question: 'Манипуляции с DOM',
      response:
        'Dom - поиск через getElementById - по id, querySelector - по селектору, querySelectorAll\n' +
        'getElementByClassName - по имени класса  getElementByTagName - по тегу\n' +
        'создание элемента Dom - document.createElement(tag).className(класс).innerHtml(текст)\n' +
        'чтобы его вставить body.append - добавляем в конец, prepend - в начало, before -  до, after- после\n' +
        '\n' +
        'Изменение replaseWith, cloneNode\n' +
        'удаление через element.remove()\n' +
        'добавление классов - element.classList.add/remove/sidebar.component.ts\n',
      active: false,
    },
    {
      question: 'Какие способы реализации ООП есть в JS(ES6) ',
      response:
        'ООП в JS - наследование prototype,  у классов через new\n' +
        'Инкапсуляция  - через #приватные поля и методы в классе',
      active: false,
    },
    {
      question: 'Как устроена асинхронность в js',
      response:
        'Асинхронность в JavaScript — это важная концепция, которая позволяет выполнять операции' +
        ' не блокируя основной поток выполнения кода. Это особенно полезно при работе с такими задачами,' +
        ' как запросы к серверу, работа с файловой системой, таймеры и другие действия, которые могут занять ' +
        'неопределённое время. JavaScript использует несколько механизмов для работы с асинхронностью:\n' +
        '\n' +
        '### Обработка событий (Event Loop)\n' +
        '\n' +
        'JavaScript работает в однопоточном режиме, что означает, что он выполняет один поток кода за раз. ' +
        'Чтобы справляться с асинхронными операциями, используется система событий и цикл событий (Event Loop).\n' +
        '\n' +
        '- Call Stack: Это стек вызовов, который хранит текущие функции, которые выполняются. Когда функция' +
        ' вызывается, она помещается в стек, а когда завершается, удаляется из стека.\n' +
        '\n' +
        '- Web APIs: Когда происходит асинхронное выполнение (например, HTTP-запрос), это передаётся соответствующему ' +
        'API, который работает независимо, не блокируя основной поток JavaScript.\n' +
        '\n' +
        '- Callback Queue: Когда асинхронная операция завершена, соответствующий callback помещается в очередь обратных' +
        ' вызовов (callback queue).\n' +
        '\n' +
        '- Event Loop: Цикл событий движется между стеком вызовов и очередью обратных вызовов. Когда стек пуст, Event Loop' +
        ' берёт функцию из очереди и помещает её в стек для выполнения.' +
        'Функции обратного вызова (callbacks) — это функции, которые передаются как аргументы в другие функции,' +
        ' чтобы быть вызванными позже, когда операция будет завершена.',
      active: false,
    },
    {
      question: 'Функциональные конструкции map,reduce,filter',
      response:
        ' Метод reduce() применяет функцию reducer к каждому элементу массива' +
        ' (слева-направо), возвращая одно результирующее значение.' +
        'Метод filter() создаёт новый массив со всеми элементами, ' +
        'прошедшими проверку, задаваемую в передаваемой функции.' +
        ' Метод map вызывает переданную функцию callback один раз ' +
        'для каждого элемента, в порядке их появления и конструирует новый массив из результатов функции',
      active: false,
    },
    {
      question: 'Работа с ассинхронностью',
      response:
        '' +
        'Promise - специальный обьект  в JS, для работы с ассинхронностью\n' +
        'у него есть состояние - pending(в процессе ), reject(ошибка), fullfield(успешно)\n' +
        'методы then(), catch(), finally()  чейнинг(цепочка вызовов) - then().then()\n' +
        'new Promise((res, rej) => {})  два колбека res, rej  он срабатывает один раз и неизменяем либо resolve или reject\n' +
        '.all([]) - ждет пока все пройдут, если один с ошибкой выдаст ошибку\n' +
        '.race() - выдаст результат первого промиса\n' +
        '.allSetled() - покажет результат всех и их статусы',
      active: false,
    },
    {
      question: 'Async/await',
      response:
        'async/await - специальный синтаксис над промисом\n' +
        'async function() {return } - зарезолвленный промис\n' +
        'await - аналог .then() - у промиса\n' +
        'обработчик ошибок try/catch внутри',
      active: false,
    },
    {
      question:
        'Способы оптимизации работы с Dom.  Список самых дорогих операций',
      response:
        'добавление в Dom после рендеринга  - нужно использовать  documentFragment\n' +
        'слишком частые события window.resize - использовать debounce()\n' +
        '\n' +
        'Узлы дом необходимо создавать только при их необходимости а как только в них отпала надобность, удаляем\n' +
        '\n' +
        'Подгружать узлы по мере необходимости пользователю\n' +
        '\n' +
        'Сокращение объёма  сложных вычислительных стилей',
      active: false,
    },
    {
      question: 'Modules, Proxy, Reflect,',
      response:
        'Модули - файл с use strict режимом, у них есть импорт и экспорт\n' +
        'Proxy - спец. обьект для перехвата и переопределения основных операций\n' +
        'new Proxy(obj, handler) reflect -часто используют вместе с proxy внутри надстройка',
      active: false,
    },
    {
      question: 'localStorage, sessionStorage, cookie',
      response:
        'localStorage - хранит данные без срока годности session- во время жизни вкладки, если дублировать вкладку создаст для каждой\n' +
        "setItem('key', содержимое) - закинуть, getItem('ключ') - забрать\n" +
        'cookie - хранит данные, которые должны быть отправлены обратно на сервер последующими запросами\n' +
        'Если установить флаг httpOnly -true - для файла то предотвратит доступ на стороне клиента, добавляется  через document.coockie',
      active: false,
    },
    {
      question: 'Сборщик мусора  ',
      response:
        'Сборщик мусора периодически находит ' +
        'объекты, которые больше не доступны в контексте ' +
        'выполнения программы, и автоматически освобождает связанную с ними память',
      active: false,
    },
    {
      question: 'repaint, reflow',
      response:
        'repaint -перерисовка элементов стили визуальный слой, ' +
        'без изменения размеров(это процесс, в ходе которого браузер отрисовывает (перерисовывает) визуальное представление' +
        ' элемента. Происходит, когда изменяются визуальные стили элемента, не влияющие на его размеры или положение.)\n' +
        'reflow - перерисовка макета страницы(Reflow — это процесс, в ходе которого' +
        ' браузер вычисляет размеры и позиции элементов на странице. Он происходит, когда' +
        ' изменяются какие-либо свойства, влияющие на расположение (размеры, границы, отступы, содержание и т. д.) элементов на странице.)' +
        'Оптимизация\n' +
        '\n' +
        'Чтобы минимизировать количество reflow и repaint, следует следовать ряду рекомендаций:\n' +
        '\n' +
        '- Структура изменений: Группируйте изменения стилей и добавления/удаления элементов, чтобы избежать множественных перерисовок.\n' +
        '- Избегайте частых изменений в циклах: Если необходимо много раз изменить стиль в цикле, лучше собрать все изменения и применить их за один раз.\n' +
        '- Используйте requestAnimationFrame: Для анимаций это позволяет браузеру оптимально справляться с обновлением интерфейса.\n' +
        '- Работайте с классовыми селекторами: Изменение класса может затронуть несколько стилий одновременно и сэкономить ресурсы на перерисовку.\n' +
        '- Минимизируйте зависимости: Будьте внимательны с событиями, которые могут вызвать восприятие изменений интерфейса.\n',
      active: false,
    },
    {
      question: 'Web Assembly',
      response:
        'язык программирования низкого уровня, призванный внести программируемость ' +
        'туда, где нужны кроссплатформенность,' +
        ' эффективность и безопасность, в первую очередь на клиентскую сторону Всемирной паутины.WebAssembly — это мощный инструмент, который расширяет ' +
        'возможности веб-разработки' +
        ', позволяя использовать более производительные и эффективные языки, а также обеспечивая отличную совместимость с существующим' +
        ' JavaScript. Он открывает новые возможности ' +
        'для создания современных высокопроизводительных веб-приложений и идеально подходит для сценариев, требующих высоких вычислительных затрат.',
      active: false,
    },
  ],
  active: false,
};
