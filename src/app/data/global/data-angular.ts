import { IDataQuestion } from '../question/type';

export const dataAngular: IDataQuestion = {
  name: 'Angular',
  questions: [
    {
      level: 'Junior',
      title: 'Что такое Angular?',
      response:
        'Angular – это фреймворк для создания клиентских веб-приложений' +
        ', разработанный компанией Google. Он позволяет создавать динамические веб-приложения, обеспечивая ' +
        'высокую производительность и гибкость кода.',
      active: false,
    },
    {
      level: 'Junior',
      title:
        'Как на Angular2 и Angular8 при получении данных с бэка парсить их в модель?\n ',
      response:
        'На Angular (как версии 2, так и 8) процесс получения данных с бэкенда и их парсинга в модель можно описать следующими этапами:\n' +
        '\n' +
        '### 1. Определение модели данных\n' +
        'Перед тем, как получать данные, необходимо определить, как они будут представляться в приложении. Это включает в себя создание модели, которая описывает структуру данных, получаемых от бэкенда. Например, если вы работаете с пользователями, вам нужно решить, какие свойства будут у пользователя (например, имя, email, возраст и т.д.).\n' +
        '\n' +
        '### 2. Создание сервиса\n' +
        'Создайте сервис, который будет отвечать за взаимодействие с API бэкенда. Этот сервис будет отправлять HTTP-запросы к серверу для получения данных. Важно, чтобы сервисы в Angular отвечали за логику работы с данными, отделяя эту логику от компонентов, которые отображают данные.\n' +
        '\n' +
        '### 3. Запрос к API\n' +
        'Сервис использует методы для отправки запросов к API для получения данных. В ответ на запрос бэкэнд возвращает данные, обычно в формате JSON. После получения этих данных сервис должен обработать их, чтобы они соответствовали модели.\n' +
        '\n' +
        '### 4. Парсинг данных\n' +
        'На этом этапе происходит преобразование данных, полученных с бэкенда, в объекты вашей модели. Это включает в себя сопоставление свойств, которые пришли от сервера, с полями вашей модели. Если структура данных соответствует ожидаемым полям модели, то можно создать экземпляры модели с полученными значениями.\n' +
        '\n' +
        '### 5. Использование данных в компоненте\n' +
        'После того, как данные были успешно преобразованы в объекты модели, их можно использовать в компонентах Angular. Компоненты могут подписываться на сервисы, чтобы получать данные, и обновлять свое состояние, чтобы отобразить эти данные на экране. Это значит, что компоненты могут легко обновлять представление в зависимости от данных, получаемых из сервиса.\n' +
        '\n' +
        '### 6. Обработка ошибок\n' +
        'Всегда полезно обрабатывать возможные ошибки, которые могут возникнуть при запросах к бэкенду. Это может быть сделано путем проверки ответов от сервера и добавления соответствующей обработки ошибок.\n' +
        '\n' +
        '### Заключение\n' +
        'В итоге, процесс парсинга данных из бэкенда в Angular включает в себя определение модели данных, создание сервиса для работы с API, выполнение запросов, их обработку и преобразование в объекты модели, а затем использование этих данных в компонентах приложения. Такой подход позволяет поддерживать чистую архитектуру и легкость управления данными в приложении.',
      active: false,
    },
    {
      level: 'Junior',
      title: 'Расскажи про guardы? ',
      response:
        'Гарды (guards) в Angular — это механизм, который позволяет контролировать доступ к определённым маршрутам (pages) в вашем приложении. Они действуют как защитные слои, проверяя, имеет ли пользователь право переходить на определённые страницы или выполнять определённые действия. Гарды помогают реализовать маршрутизацию с учетом авторизации, аутентификации и других условий.\n' +
        '\n' +
        '### Основные виды гардов в Angular:\n' +
        '\n' +
        '1. CanActivate:\n' +
        '- Проверяет, может ли пользователь перейти на определённый маршрут. Если метод возвращает true, переход разрешён; если false, переход отменяется.\n' +
        '- Используется для проверки, прошел ли пользователь аутентификацию или имеет ли права доступа к определённому маршруту.\n' +
        '\n' +
        '2. CanActivateChild:\n' +
        '- Работает аналогично CanActivate, но применяется к дочерним маршрутам. Это позволяет контролировать доступ ко всем дочерним маршрутам конкретного родительского маршрута.\n' +
        '\n' +
        '3. CanDeactivate:\n' +
        '- Переход контролируется, когда пользователь пытается покинуть текущий маршрут. Например, это может быть полезно, если у вас есть форма, и вы хотите предупредить пользователя о том, что он потеряет несохраненные данные.\n' +
        '\n' +
        '4. Resolve:\n' +
        '- Используется для получения данных перед активацией маршрута. Это позволяет загружать данные заранее и передавать их в компонент, что полезно для случаев, когда вы хотите отображать данные, прежде чем пользователь увидит страницу.\n' +
        '\n' +
        '5. CanLoad:\n' +
        '- Проверяет, имеет ли пользователь доступ к загрузке определённого модуля. Это используется для ленивой загрузки маршрутов, что позволяет загружать модули только при необходимости. Это помогает улучшить производительность приложения, предотвращая загрузку ненужных модулей.\n' +
        '\n' +
        '### Как работают гарды:\n' +
        '\n' +
        'Гарды реализуются в виде сервисов. Чтобы создать гард, вы можете использовать Angular CLI, который автоматически создаст необходимый сервис. Каждый гард должен реализовывать интерфейс, соответствующий его типу (например, CanActivate), и реализовывать метод, который будет возвращать true или false, либо Observable boolean> или Promise boolean>.\n' +
        '\n' +
        '### Пример использования гарда:\n' +
        '\n' +
        '1. Создание гарда: Вы создаете гард, который проверяет, старше ли пользователь определенного возраста.\n' +
        '2. Имплементация логики: В методе проверяете возраст пользователя и возвращаете true или false.\n' +
        '3. Настройка маршрутов: В маршрутах указываете, какой гард применить к конкретному маршруту, тем самым обеспечивая контроль доступа.\n' +
        '\n' +
        '### Преимущества использования гардов:\n' +
        '\n' +
        '- Позволяют улучшить безопасность вашего приложения, предотвращая несанкционированный доступ.\n' +
        '- Обеспечивают лучшую управляемость переходов между маршрутами, особенно в сложных приложениях с множеством условий доступа.\n' +
        '- Помогают загружать необходимые данные перед тем, как пользователь увидит страницу, что улучшает пользовательский опыт.\n' +
        '\n' +
        'В целом, гарды в Angular являются мощным инструментом для управления доступом к маршрутам и организации логики переходов в приложении.',
      active: false,
    },
    {
      level: 'Junior',
      title:
        'Использовали ли сторонние библиотеки для форм? Angular Material? ',
      response:
        'Да, в Angular часто используются сторонние библиотеки для работы с формами, и одной из наиболее популярных таких библиотек является Angular Material. Вот несколько аспектов, касающихся использования Angular Material и других библиотек для работы с формами:\n' +
        '\n' +
        '### Angular Material\n' +
        '\n' +
        '1. UI-компоненты: Angular Material предоставляет набор предопределённых пользовательских интерфейсных компонентов, которые соответствуют Material Design. Это включает в себя различные элементы форм, такие как текстовые поля, селекты, чекбоксы, радиокнопки и другие.\n' +
        '\n' +
        '2. Стилизация: Использование Angular Material позволяет быстро и просто создавать стильные и отзывчивые формы с минимальными усилиями по стилизации. Компоненты уже имеют встроенные стили по умолчанию, соответствующие рекомендациям по дизайну.\n' +
        '\n' +
        '3. Валидация: Angular Material делает процесс валидации форм более удобным. Компоненты формы интегрированы с механизмом валидации Angular, что позволяет легко отображать сообщения об ошибках и советы пользователям.\n' +
        '\n' +
        '4. Интерактивность: Angular Material поддерживает различные интерактивные возможности, такие как автозаполнение, выпадающие списки и адаптивное поведение в зависимости от размера экрана. Это улучшает взаимодействие пользователей с формами.\n' +
        '\n' +
        '### Другие сторонние библиотеки\n' +
        '\n' +
        '1. Ngx-formly: Это библиотека для создания динамических форм в Angular. Она позволяет определять формы с использованием JSON и автоматически генерировать пользовательский интерфейс на основе этого определения. Это особенно полезно для приложений с изменяемыми требованиями к формам.\n' +
        '\n' +
        '2. Reactive Forms: Хотя это не совсем сторонняя библиотека, это важный подход в Angular. Reactive Forms предоставляет более мощные инструменты для управления состоянием форм и их валидацией по сравнению с Template-driven Forms. Reactive Forms позволяют легче отслеживать изменения формы и управлять их состоянием.\n' +
        '\n' +
        '3. ngx-bootstrap и PrimeNG: Эти библиотеки также предлагают компоненты для работы с формами, в том числе таблицы, модальные окна и различные элементы управления. Они могут быть использованы в сочетании с Angular Material или другим стилем приложения в зависимости от требований проекта.\n' +
        '\n' +
        '### Заключение\n' +
        '\n' +
        'Использование сторонних библиотек, таких как Angular Material, значительно упрощает разработку форм в Angular-приложениях. Они не только предоставляют готовые компоненты, но и обеспечивают удобное взаимодействие с пользователями, улучшая общее восприятие приложения. Выбор библиотеки зависит от конкретных потребностей вашего проекта, предпочтений по стилю и дизайну, а также уровня требуемой функциональности.',
      active: false,
    },
    {
      level: 'Junior',
      title:
        'Пользуетесь типизацией в typescript или используете как дефолтный инструмент для\n' +
        'Angular?\n',
      response:
        'Типизация в TypeScript является одной из его ключевых особенностей, и в большинстве случаев использование типизации рассматривается как важная практическая практика при разработке приложений на Angular. Вот несколько причин, почему типизация считается полезной и важной в контексте Angular:\n' +
        '\n' +
        '### 1. Улучшенная безопасность типов\n' +
        '- Использование типизации позволяет обнаруживать ошибки на этапе компиляции вместо выполнения, что снижает вероятность возникновения ошибок во время выполнения приложения.\n' +
        '- Это особенно полезно в крупных приложениях, где сложно отслеживать типы данных, передаваемых между компонентами, сервисами и другими частями приложения.\n' +
        '\n' +
        '### 2. Лучшее автозавершение и поддержка IDE\n' +
        '- Типы помогают интегрированным средам разработки (IDE) предоставлять более точные подсказки, автозавершение и документацию для методов и свойств.\n' +
        '- Это упрощает разработку, поскольку разработчики могут легче понимать структуры данных и интерфейсы, используемые в приложении.\n' +
        '\n' +
        '### 3. Чёткое определение интерфейсов и моделей\n' +
        '- В TypeScript можно использовать интерфейсы и классы для явного определения структуры объектов и моделей данных, что делает код более понятным и поддерживаемым.\n' +
        '- Это помогает обеспечить единообразие в использовании объектов в разных частях приложения.\n' +
        '\n' +
        '### 4. Поддержка и расширяемость\n' +
        '- Типизация упрощает совместную работу в команде, поскольку другие разработчики могут легко понять, какие данные ожидаются, и какие структуры данных необходимы для использования.\n' +
        '- Это делает код более удобным для тестирования и расширения, поскольку вы точно знаете, какие типы передаются в функции и компоненты.\n' +
        '\n' +
        '### 5. Использование сложных типов\n' +
        '- TypeScript позволяет использовать сложные типы данных, такие как объединения (union types), пересечения (intersection types) и типы с помощью дженериков. Это помогает создавать более гибкие и обобщенные компоненты и сервисы.\n' +
        '- Это особенно полезно для сложных бизнес-логик и компонентов, которые могут обрабатывать разнообразные данные.\n' +
        '\n' +
        '### Заключение\n' +
        'Таким образом, хотя TypeScript и является дефолтным инструментом для Angular, использование типизации в TypeScript не следует рассматривать как опцию, а как рекомендацию. Это не только улучшает надежность и читаемость кода, но и делает разработку более эффективной и управляемой, что критически важно в современных веб-приложениях.' +
        ' Поэтому большинство разработчиков на Angular активно используют типизацию TypeScript для повышения качества своего кода.',
      active: false,
    },
    {
      level: 'Middle',
      title: 'Что такое change detection? В чём разница между default и push?',
      response:
        'Change Detection (обнаружение изменений) в Angular — это механизм, который отслеживает изменения в данных и обновляет пользовательский интерфейс (UI) в соответствии с этими изменениями. Angular использует этот механизм для актуализации представления приложения, когда данные изменяются в модели. С помощью обнаружения изменений вы можете автоматически реагировать на изменения состояния приложения, обеспечивая синхронизацию между моделью и представлением.\n' +
        '\n' +
        '### Как работает обнаружение изменений в Angular\n' +
        '\n' +
        'Angular обновляет представление компонентов при помощи так называемого механизма обнаружения изменений. Он основан на концепции "потока" данных и использует различные стратегии для определения изменений:\n' +
        '\n' +
        '1. Zone.js: Angular использует библиотеку Zone.js, чтобы отслеживать асинхронные операции, такие как события, таймеры и HTTP-запросы. Когда такие операции завершаются, Angular знает, что необходимо проверить, произошло ли изменение.\n' +
        '\n' +
        '2. Change Detection Strategy: У каждого компонента в Angular есть стратегия обнаружения изменений, которая определяет, как именно Angular будет отслеживать изменения в этом компоненте.\n' +
        '\n' +
        '### Стратегии обнаружения изменений\n' +
        '\n' +
        'В Angular существуют две основные стратегии обнаружения изменений:\n' +
        '\n' +
        '1. Default Change Detection (Default strategy):\n' +
        '- Это стандартная стратегия обнаружения изменений, используемая по умолчанию для всех компонентов.\n' +
        '- Angular проверяет каждую часть дерева компонентов на изменения после каждой асинхронной операции (например, при событиях, таймерах и HTTP-запросах).\n' +
        '- Это означает, что Angular будет периодически проверять все компоненты с целью указать, есть ли изменения в их переменных, и обновлять соответствующее представление при необходимости.\n' +
        '- Эта стратегия проста в использовании и подходит для большинства приложений, но может привести к неэффективности в производительности, особенно в сложных приложениях с глубоким деревом компонентов.\n' +
        '\n' +
        '2. OnPush Change Detection (OnPush strategy):\n' +
        '- Эта стратегия оптимизирует производительность компонента, проверяя только те компоненты, которые имеют изменения в своих входных параметрах (inputs), или те, которые вызывают события.\n' +
        '- Angular не проверяет компонент, если не были выполнены изменения в его свойствах, и если он не реагирует на события в его пределах. Это означает, что если никаких изменений не произошло, компонент не будет проверяться на изменения, что снижает нагрузку на производительность.\n' +
        '- Компоненты с OnPush должны использовать иммутабельные данные (immutable data) или производить изменения экземпляра для вызова обновлений.\n' +
        '- OnPush может быть полезен в больших и сложных приложениях, где производительность имеет важное значение.',
      active: false,
    },
    {
      level: 'Middle',
      title: 'ngZone',
      response:
        'NgZone — это сервис в Angular, который позволяет управлять контекстом выполнения асинхронного кода и обеспечивать обнаружение изменений. Он является частью механизма, который позволяет Angular отслеживать изменения в приложении и обновлять представление в соответствии с изменениями состояния. NgZone использует библиотеку Zone.js для работы с зонами, изолированными контекстами выполнения, которые позволяют отслеживать асинхронные операции.\n' +
        '\n' +
        '### Основные функции NgZone:\n' +
        '\n' +
        '1. Обнаружение изменений:\n' +
        '- NgZone позволяет Angular эффективно отслеживать изменения, происходящие в приложении, автоматически активируя обнаружение изменений после завершения асинхронных операций (таких как HTTP-запросы, таймеры и события). Это обеспечивает автоматическое обновление представления, когда данные меняются.\n' +
        '\n' +
        '2. Контроль над изменениями:\n' +
        '- NgZone предоставляет методы для управления тем, когда Angular должен проверять изменения. Вы можете использовать его для временного выхода из зоны (например, при выполнении операций, которые не требуют изменений в UI), что может помочь улучшить производительность.\n' +
        '\n' +
        '3. Методы NgZone:\n' +
        '- run(): Этот метод запускает функцию внутри контекста Angular, активируя обнаружение изменений. Это полезно, если вы хотите выполнить некоторые действия и убедиться, что изменения будут отслежены.\n' +
        '- runOutsideAngular(): Этот метод позволяет выполнять функции вне контекста Angular. Это важно, если вы хотите избежать избыточного отслеживания изменений и улучшить производительность (например, при использовании сторонних библиотек для работы с событиями или анимациями).',
      active: false,
    },
    {
      level: 'Senior',
      title: 'Чем e2e-тесты отличаются от unit-тестов?',
      response:
        'E2E-тесты (end-to-end тесты) и unit-тесты (модульные тесты) являются двумя различными уровнями тестирования программного обеспечения, и каждый из них имеет свои особенности, цели и области применения.\n' +
        '\n' +
        '### Unit-тесты\n' +
        '\n' +
        '#### Определение:\n' +
        'Unit-тесты предназначены для проверки отдельных "единиц" кода, таких как функции, методы или классы, в изоляции от остальной части системы.\n' +
        '\n' +
        '#### Основные характеристики:\n' +
        '1. Изоляция: Каждый unit-тест проверяет только одну конкретную функциональность, отделённую от других частей приложения. Это достигается через использование моков (mocks), заглушек (stubs) или фейков (fakes).\n' +
        '\n' +
        '2. Скорость: Unit-тесты обычно выполняются быстро, так как они не требуют взаимодействия с внешними компонентами, такими как база данных или API.\n' +
        '\n' +
        '3. Инструменты: Для написания unit-тестов часто используются фреймворки, такие как Jasmine, Mocha, Jest и другие.\n' +
        '\n' +
        '4. Простота: Unit-тесты проще для реализации и отладки, так как они сосредоточены на маленьких кусках кода.\n' +
        '\n' +
        '5. Цели: Основная цель unit-тестов — выявление ошибок в логике отдельных модулей и обеспечение правильного функционирования этих модулей.\n' +
        '\n' +
        '### E2E-тесты\n' +
        '\n' +
        '#### Определение:\n' +
        'E2E-тесты проверяют приложение в целом, имитируя поведение пользователя, чтобы убедиться, что все части системы работают вместе должным образом.\n' +
        '\n' +
        '#### Основные характеристики:\n' +
        '1. Полное тестирование: E2E-тесты проверяют все слои приложения, включая фронтенд, бэкенд, базы данных и другие взаимодействия. Они проверяют, как различные модули и компоненты работают вместе.\n' +
        '\n' +
        '2. Сложность: E2E-тесты более сложные в написании и поддержке, поскольку требуют настройки тестовых данных и окружения.\n' +
        '\n' +
        '3. Скорость: E2E-тесты обычно медленнее, чем unit-тесты, из-за необходимости симуляции всей системы и взаимодействия с различными компонентами.\n' +
        '\n' +
        '4. Инструменты: Для E2E-тестирования часто используются инструменты, такие как Protractor, Cypress, Selenium и другие.\n' +
        '\n' +
        '5. Пользовательский опыт: E2E-тесты предназначены для проверки пользовательского опыта, начиная с загрузки страницы и заканчивая действиями пользователя, такими как нажатия кнопок и ввод данных.\n' +
        '\n' +
        '6. Цели: Основная цель E2E-тестов — удостовериться, что приложение работает как единое целое и что все его части правильно взаимодействуют друг с другом.\n' +
        '\n' +
        '### Заключение\n' +
        '\n' +
        'В целом, оба типа тестирования важны и дополняют друг друга в процессе разработки программного обеспечения. Unit-тесты обеспечивают проверку отдельных компонентов на грамматические ошибки и ошибки логики, тогда как E2E-тесты подтверждают' +
        ', что приложение работает корректно при взаимодействии всех компонентов. Чаще всего в проектах комбинируют оба подхода, чтобы получить более полное покрытие и уверенность в качестве кода.',
      active: false,
    },
    {
      level: 'Junior',
      title: 'Что такое pipe? Расскажите про async pipe?',
      response:
        'В Angular pipe (пайп) — это специальный механизм, позволяющий трансформировать данные в шаблонах. Пайпы применяются для изменения форматирования, преобразования и фильтрации данных при их отображении в UI. Они представляют собой функции, которые могут быть использованы в выражениях Angular для изменения значений, прежде чем они будут отображены в HTML.\n' +
        '\n' +
        '### Основные характеристики пайпов:\n' +
        '\n' +
        '1. Чистота: Пайпы могут быть чистыми или грязными. Чистые пайпы не изменяют входные данные и возвращают одно и то же значение для одного и того же входного значения. Грязные пайпы могут возвращать разные результаты при каждом вызове.\n' +
        '\n' +
        '2. Параметры: Пайпы могут принимать дополнительные параметры для настройки их поведения.\n' +
        '\n' +
        '3. Композиция: Пайпы могут быть вложены друг в друга, позволяя комбинировать их функции.' +
        'Async Pipe\n' +
        '\n' +
        'Async Pipe — это специальный пайп в Angular, который упрощает работу с асинхронными данными, такими как результаты HTTP-запросов, промисы или потоки (Observables). Он позволяет автоматически подписываться на Observable или промис и обновлять представление, когда приходит новое значение.\n' +
        '\n' +
        '#### Основные функции Async Pipe:\n' +
        '\n' +
        '1. Подписка и отписка: Async Pipe автоматически подписывается на Observable при загрузке компонента и отписывается при уничтожении компонента. Это помогает избежать утечек памяти и упрощает управление подписками.\n' +
        '\n' +
        '2. Актуализация данных: Async Pipe автоматически обновляет отображаемые данные в шаблоне, когда Observable эмитирует новое значение.\n' +
        'Пайпы, в том числе Async Pipe, являются очень удобным инструментом для работы с данными в Angular. Они позволяют легко и эффективно форматировать и трансформировать данные непосредственно в шаблонах, а также упрощают работу с асинхронными данными, автоматизируя управление подписками и актуализацией данных в пользовательском интерфейсе.',
      active: false,
    },
    {
      level: 'Junior',
      title: 'Жизненный цикл компоненты',
      response:
        ' В Angular жизненный цикл компонента описывает последовательность событий и методов, через которые проходит компонент с момента его создания до уничтожения. Понимание жизненного цикла компонентов позволяет разработчикам лучше управлять состоянием и поведением компонентов, а также выполнять определенные действия на различных этапах их существования.\n' +
        '\n' +
        '### Основные стадии жизненного цикла компонента и их хуки\n' +
        '\n' +
        '1. Создание\n' +
        '- ngOnChanges(): Вызывается при изменении входных свойств компонента. Этот хук получает объект SimpleChanges, который содержит информацию о предыдущих и текущих значениях входных свойств. Используется для реакции на изменения входных данных.\n' +
        '- ngOnInit(): Вызывается после первого отображения компонента и инициализации свойств. Здесь лучше всего помещать код, зависящий от входных свойств или других данных.\n' +
        '\n' +
        '2. Изменение\n' +
        '- ngDoCheck(): Вызывается во время каждого цикла обнаружения изменений и позволяет разработчику реагировать на изменения, которые Angular не может отследить автоматически.\n' +
        '\n' +
        '3. Отображение\n' +
        '- ngAfterContentInit(): Вызывается после того, как контент (ng-content) был проинициализирован. Это позволяет выполнять действия, которые зависят от наличия содержимого в компоненте.\n' +
        '- ngAfterContentChecked(): Вызывается после проверки содержания компонента. Здесь можно выполнять действия, зависимые от изменений в контенте.\n' +
        '- ngAfterViewInit(): Вызывается после инициализации представления компонента и всех дочерних представлений. Здесь можно выполнять действия, которые требуют доступа к дочерним компонентам.\n' +
        '- ngAfterViewChecked(): Вызывается после проверки представления и дочерних представлений. Этот метод можно использовать для выполнения дополнительных действий после каждой проверки.\n' +
        '\n' +
        '4. Уничтожение\n' +
        '- ngOnDestroy(): Вызывается перед уничтожением компонента. Здесь можно выполнять финальную уборку, освобождать ресурсы, такие как подписки на события или таймеры, для предотвращения утечек памяти.',
      active: false,
    },
    {
      level: 'Middle',
      title: 'Почему change работает раньше onInit (чендж детекшн)',
      response:
        'почему изменение данных может вызвать обнаружение изменений до выполнения метода ngOnInit.\n' +
        '\n' +
        '1. Состояние данных перед ngOnInit():\n' +
        '- Когда компонент инициализируется, его свойства могут быть уже установлены в определенные значения. Если эти свойства изменяются до вызова ngOnInit, Angular запускает обнаружение изменений, чтобы отражать эти изменения в интерфейсе.\n' +
        '\n' +
        '2. Процесс обнаружения изменений:\n' +
        '- Angular использует механизм изменений, чтобы отслеживать изменения состояния в приложении. Этот механизм реагирует на изменения, происходящие в свойствах компонента.\n' +
        '\n' +
        '3. Очередность вызовов:\n' +
        '- Как только Angular заметит изменения входных данных или состояния, он инициирует обнаружение изменений, что может привести к перерисовке компонента, даже если метод ngOnInit еще не был вызван. Однако, после этого Angular также вызовет ngOnInit() для выполнения дополнительной логики и инициализации.',
      active: false,
    },
    {
      level: 'Middle',
      title: 'Viewchild от contentChild',
      response:
        'В Angular @ViewChild и @ContentChild — это декораторы, которые используются для получения ссылок на компоненты, директивы или элементы DOM, но у них есть разные области применения и методы работы. Давайте рассмотрим каждую из этих аннотаций более подробно.\n' +
        '\n' +
        '### @ViewChild\n' +
        '\n' +
        '#### Определение:\n' +
        '@ViewChild позволяет получить доступ к дочерним компонентам, директивам или элементам шаблона, которые находятся в пределах самого компонента. Это означает, что @ViewChild используется для доступа к элементам, которые находятся в шаблоне текущего компонента.' +
        '@ContentChild\n' +
        '\n' +
        '#### Определение:\n' +
        '@ContentChild позволяет получить доступ к дочерним компонентам или элементам, которые были переданы в родительский компонент через ng-content>. Это означает, что @ContentChild используется для доступа к элементам, которые находятся вне шаблона текущего компонента, но были вставлены в него.' +
        'Как использовать:\n' +
        'Для использования @ContentChild необходимо вставить элемент в родительский компонент, проделав это с помощью ng-content.\n' +
        '\n' +
        'br>app-parent>br>  child-component>/child-component>br>/app-parent>br>\n' +
        '\n' +
        '\n' +
        '### Основные отличия\n' +
        '\n' +
        '1. Положение элементов:\n' +
        '- @ViewChild: Получает доступ к дочерним компонентам, директивам или элементам, которые находятся внутри текущего компонента.\n' +
        '- @ContentChild: Получает доступ к элементам, которые были переданы в текущий компонент через ng-content.\n' +
        '\n' +
        '2. Событие инициализации:\n' +
        '- @ViewChild: Необходимо использовать в методах жизненного цикла, таких как ngAfterViewInit, чтобы быть уверенным, что элемент инициализирован.\n' +
        '- @ContentChild: Обычно используется в ngAfterContentInit, поскольку контент может быть вставлен после инициализации компонента.\n' +
        '\n' +
        '3. Контекст использования:\n' +
        '- @ViewChild: Используется для взаимодействия с элементами/компонентами, которые являются частью самого компонента (например, элементы формы, дочерние компоненты).\n' +
        '- @ContentChild: Используется для получения доступа к элементам, которые вставлены в компонент извне, например, элементы, переданные через контент.\n',
      active: false,
    },
    {
      level: 'Middle',
      title: 'Как стили навесить на viewChild (renderer2) ',
      response:
        'В Angular, чтобы навесить стили на элемент, полученный с помощью @ViewChild, вы можете использовать Renderer2. Это позволяет вам динамически изменять стили элемента в безопасном и независимом от платформы способом. Ниже приведен пример того, как это можно сделать.\n' +
        '\n' +
        '### Шаги для изменения стилей с помощью Renderer2 и @ViewChild\n' +
        '\n' +
        '1. Импортируйте необходимые модули.\n' +
        '2. Получите ссылку на элемент через @ViewChild.\n' +
        '3. Используйте сервис Renderer2 для управления стилями.',
      active: false,
    },
    {
      level: 'Junior',
      title: 'У нас есть код модули, как разбить код на модули ',
      response:
        'Разбиение кода на модули - это важный аспект организации и управления проектом в Angular. Модули позволяют вам структурировать приложение, улучшить его читаемость и повторное использование кода. Вот шаги и рекомендации о том, как разбить код на модули в Angular:\n' +
        '\n' +
        '### Причины для разбивки на модули\n' +
        '1. Структурирование кода: Модули помогают организовать код по функциональным направлениям.\n' +
        '2. Улучшение производительности: Модули могут загружаться лениво (lazy loading), что ускоряет начальную загрузку приложения.\n' +
        '3. Повторное использование: Модули можно использовать в разных частях приложения или даже в других проектах.\n' +
        '\n' +
        '### Шаги для разбиения кода на модули\n' +
        '\n' +
        ' 1. Определите функциональные области\n' +
        'Сначала разделите приложение на логические секции. Например:\n' +
        '- Пользовательский интерфейс (UI)\n' +
        '- Аутентификация\n' +
        '- Продукты или товары\n' +
        '- Заказы или корзина\n' +
        '- Админ-панель\n' +
        '\n' +
        '2. Создайте модули' +
        '3. Переместите компоненты и сервисы' +
        '4. Настройте маршрутизацию' +
        '5. Импортируйте общий модуль' +
        '6. Настройте ленивую загрузку (если необходимо)',
      active: false,
    },
    {
      level: 'Middle',
      title: ' Стал бы ты провайдить сервисы в шаред модуль',
      response:
        'Да, обычно сервисы провайдятся в shared модуль, чтобы их можно было использовать ' +
        'в разных модулях приложения. Это помогает избежать дублирования кода и упрощает управление ' +
        'зависимостями. Убедитесь, что сервисы являются stateless (без состояния) или могут безопасно ' +
        'работать с состоянием, если это необходимо',
      active: false,
    },
    {
      level: 'Middle',
      title: ' Реактивные формы плюсы в чем\n',
      response:
        'Плюсы реактивных форм в Angular:\n' +
        '\n' +
        '1. Контроль состояния: Обеспечивает строгий контроль над состоянием формы и её элементами.\n' +
        '\n' +
        '2. Модульность: Упрощает разделение форм на мелкие, управляемые компоненты.\n' +
        '\n' +
        '3. Тестируемость: Упрощает тестирование, так как логика формы отделена от представления.\n' +
        '\n' +
        '4. Удобное управление валидаторами: Легко добавлять и изменять валидаторы в реальном времени.\n' +
        '\n' +
        '5. Лучше с асинхронными данными: Удобнее работать с асинхронными операциями, такими как запросы к серверу.\n' +
        '\n' +
        '6. Императивный подход: Позволяет управлять формами через программный код, что может быть более понятно для разработчиков.\n' +
        '\n' +
        '7. Динамическое изменение форм: Упрощает создание форм с динамическим набором полей и зависимостями между ними.',
      active: false,
    },
    {
      level: 'Middle',
      title:
        'Разница между 6-ым и 9-ым Angular? Что поменялось в плане работы с backEnd',
      response:
        'Angular активно развивается, и между версиями 6 и 9 были внесены значительные изменения и улучшения. Вот основные изменения и отличия между Angular 6 и Angular 9, особенно в контексте работы с бэкендом:\n' +
        '\n' +
        '### 1. Ivy Renderer\n' +
        '- Angular 9: Одной из самых заметных изменений в Angular 9 стал новый рендерер под названием Ivy. Ivy улучшает производительность, уменьшает размер бандла и значительно ускоряет время компиляции. Благодаря Ivy теперь проще и быстрее оптимизировать загрузку приложений.\n' +
        '- Angular 6: Использовал стандартный рендерер.\n' +
        '\n' +
        '### 2. Анализ времени сборки\n' +
        '- Angular 9: Новый рендерер Ivy предоставляет улучшенные возможности для анализа приложения и позволяет лучше оптимизировать время сборки и размеры финального бандла.\n' +
        '- Angular 6: Возможности оптимизации были более ограничены по сравнению с тем, что предоставляет Ivy.\n' +
        '\n' +
        '### 3. Упрощение использования Angular для работы с HTTP\n' +
        '- Angular 6: В этой версии были введены улучшения в модуле HttpClient, но основные изменения в основном касались улучшения обращений к API.\n' +
        '- Angular 9: Были улучшены возможности работы с HttpClient и добавлены дополнительные возможности, такие как более удобные инструменты для использования RxJS на уровне сервисов. Более гибкие механизмы для обработки ошибок и применения интерсепторов.\n' +
        '\n' +
        '### 4. Ручное указание зависимостей\n' +
        '- Angular 9: Улучшена поддержка "Ручного указания зависимостей" через providedIn на уровне сервиса, что делает внедрение зависимостей более простым и понятным. Это улучшает работу с DI и некоторыми сценариями, которые могут возникнуть при взаимодействии с бэкендом.\n' +
        '\n' +
        '### 5. Улучшения в CLI\n' +
        '- Angular 9: Улучшены инструменты Angular CLI, которые обеспечивают более простой и быстрый процесс создания приложений и управления зависимостями. Новые функции, такие как возможность создания компонентов без необходимости вручную обновлять модули, делают разработку быстрее.\n' +
        '\n' +
        '### 6. Зависимости на уровне библиотеки\n' +
        '- Angular 9: Старая структура зависимостей была улучшена для библиотек, что сделало процесс работы с библиотеками более интуитивным. Это упрощает интеграцию сторонних библиотек и работу с API, обеспечивая более гладкое взаимодействие с бэкендом.\n' +
        '\n' +
        '### 7. Поддержка Internationalization (i18n)\n' +
        '- Angular 9: Улучшение системы локализации, что позволяет проще работать с многоязычными приложениями.\n' +
        '\n' +
        '### Заключение\n' +
        'В общем,Angular 9 обеспечивает более удобную компиляцию, лучшую производительность и оптимизацию. Работая с бэкендом, у разработчиков теперь есть дополнительные инструменты, которые упрощают процесс интеграции с API и обработку данных. Улучшенная отдача от Ivy также делает общую производительность приложений выше по сравнению с Angular 6.',
      active: false,
    },
    {
      level: 'Junior',
      title: ' Что такое компонент в Angular?',
      response:
        'Компоненты являются основными строительными блоками Angular-приложений и содержат логику и представление.',
      active: false,
    },
    {
      level: 'Junior',
      title: ' Что такое сервисы и как их использовать?',
      response:
        'сервисы — это классы, которые предоставляют определённый функционал и могут быть использованы для ' +
        'обмена данными и выполнения логики, которая не привязана к конкретному компоненту. Сервисы помогают' +
        ' реализовать архитектуру, при которой код становится более модульным, переиспользуемым и легче поддерживаемым.' +
        ' Обычно они используются для взаимодействия с API, хранения и обработки данных, а также для реализации различных функций,' +
        ' таких как маршрутизация, аутентификация и т.д.\n' +
        '\n' +
        '### Основные характеристики сервисов:\n' +
        '\n' +
        '1. Инъекция зависимостей: Angular использует механизм инъекции зависимостей для создания экземпляров сервисов, ' +
        'что позволяет автоматически управлять их жизненным циклом и зависимостями.\n' +
        '\n' +
        '2. Переиспользуемость: Сервисы могут быть использованы в разных компонентах, что повышает переиспользуемость кода.\n' +
        '\n' +
        '3. Модульность: Сервисы способствуют разделению бизнес-логики и логики представления (UI), что улучшает структуру кода.\n' +
        '\n' +
        '4. Тестируемость: Благодаря высокой модульности, сервисы легче тестировать отдельно от компонентов.' +
        "Как правило, сервис регистрируется автоматически при использовании декоратора @Injectable с свойством providedIn: 'root'. " +
        'Это делает его доступным' +
        ' в корневом модуле вашего приложения. Вы также можете зарегистрировать сервис в конкретном модуле или компоненте,' +
        ' добавив его в массив providers соответствующего декоратора.',
      active: false,
    },
    {
      level: 'Junior',
      title: 'Каковы основные характеристики Angular?',
      response:
        '### 1. Компонентный подход\n' +
        'Angular основан на компонентной архитектуре, что позволяет разбивать интерфейс приложения на управляемые ' +
        'и переиспользуемые компоненты. Каждый компонент инкапсулирует свою логику, шаблон и стили, что упрощает ' +
        'разработку и сопровождение приложения.\n' +
        '\n' +
        '### 2. Двусторонняя привязка данных\n' +
        'Angular поддерживает двустороннюю привязку данных (two-way data binding), что позволяет автоматически ' +
        'синхронизировать данные между моделью и представлением. Это упрощает взаимодействие между компонентами' +
        ' и инкапсулирует обновления данных, что делает разработку более интуитивной.\n' +
        '\n' +
        '### 3. Модули\n' +
        'Angular использует систему модулей, что позволяет организовать код в независимые и логически связанные' +
        ' группы. Каждый модуль может содержать компоненты, директивы, сервисы и другие модули, что способствует ' +
        'модульному подходу и лучшей управляемости кода.\n' +
        '\n' +
        '### 4. Инъекция зависимостей (Dependency Injection)\n' +
        'Angular предоставляет встроенную поддержку инъекции зависимостей, что упрощает управление зависимостями между ' +
        'классами и улучшает тестируемость приложения. Это позволяет легче управлять жизненным циклом объектов и их взаимодействием.\n' +
        '\n' +
        '### 5. Маршрутизация\n' +
        'Angular включает встроенный модуль маршрутизации, который позволяет организовать навигацию между' +
        ' различными представлениями или страницами приложения. Это делает приложения более удобными для' +
        ' пользователей и улучшает организацию кода.\n' +
        '\n' +
        '### 6. Реактивные формы\n' +
        'Angular позволяет работать с формами через реактивные формы или шаблонные формы, что обеспечивает' +
        ' мощные инструменты для валидации и отслеживания состояния. Реактивные формы позволяют динамически ' +
        'управлять формами в приложении, облегчая их настройку и валидацию.\n' +
        '\n' +
        '### 7. RxJS и реактивное программирование\n' +
        'Angular активно использует библиотеку RxJS, которая предоставляет инструменты для работы с асинхронными' +
        ' данными и потоками событий. Это дает разработчикам возможность эффективно управлять потоками данных ' +
        'и событий с использованием Observable.\n' +
        '\n' +
        '### 8. Генерация и сборка с помощью CLI\n' +
        'Angular CLI (Command Line Interface) позволяет быстро создавать и управлять Angular приложениями.' +
        ' Он предлагает команды для создания новых компонентов, сервисов, модулей и т.д., ' +
        'а также автоматизирует процесс сборки, тестирования и развертывания.\n' +
        '\n' +
        '### 9. Тестируемость\n' +
        'Angular разработан с учетом тестируемости. Он поддерживает юнит-тестирование компонентов и сервисов ' +
        'с помощью таких инструментов, как Jasmine и Karma. Это позволяет легко писать и запускать тесты,' +
        ' что способствует повышению качества кода.\n' +
        '\n' +
        '### 10. Поддержка Progressive Web Apps (PWA)\n' +
        'Angular обеспечивает поддержку создания прогрессивных веб-приложений, которые могут' +
        ' работать как нативные приложения на мобильных устройствах. PWA имеют повышенную скорость загрузки,' +
        ' работоспособность в оффлайн-режиме и возможность установки на домашний экран.\n' +
        '\n' +
        '### 11. Поддержка SEO\n' +
        'Angular предоставляет механизмы для улучшения поисковой оптимизации (SEO) приложений, включая серверный' +
        ' рендеринг с использованием Angular Universal. Это помогает приложениям эффективно индексироваться поисковыми системами.\n',
      active: false,
    },
    {
      level: 'Junior',
      title: 'Что такое NgModule?',
      response:
        'NgModule — это основной строительный блок приложения в Angular, который используется для организации и ' +
        'структурирования кода. Он позволяет группировать связанные компоненты, директивы, пайпы и сервисы в единое' +
        ' целое. Основная цель NgModule — определить область видимости и зависимости для различных частей вашего приложения. ' +
        'Вот основные аспекты NgModule:\n' +
        '\n' +
        '### Основные характеристики NgModule:\n' +
        '\n' +
        '1. Определение модуля:\n' +
        'Каждый Angular-модуль определяется с помощью декоратора @NgModule, который принимает объект конфигурации.' +
        ' Этот объект содержит метаданные, описывающие модуль.\n' +
        '\n' +
        '2. Импортируемые и экспортируемые модули:\n' +
        '- Imports: Позволяет модулю импортировать другие модули, что делает доступными их компоненты,' +
        ' директивы и пайпы. Это позволяет разделять функциональность на разные модули и повторно использовать код.\n' +
        '- Exports: Позволяет экспортировать компоненты, директивы и пайпы, чтобы они были доступны в других модулях,' +
        ' которые импортируют текущий модуль.\n' +
        '\n' +
        '3. Область видимости:\n' +
        'Модули определяют область видимости для компонентов и сервисов. Компоненты, указанные в разделе' +
        ' declarations, могут быть использованы только внутри этого модуля, если не экспортированы.\n' +
        '\n' +
        '4. Декларации:\n' +
        'В разделе declarations указываются компоненты, директивы и пайпы, которые принадлежат этому модулю.\n' +
        '\n' +
        '5. Сервис и DI:\n' +
        'Модули могут предоставлять сервисы через секцию providers. Angular автоматически создает экземпляр сервиса' +
        ' и обеспечивает его инъекцию в компоненты, пользовательские директивы и другие сервисы.\n' +
        '\n' +
        '6. Основной модуль:\n' +
        'Каждое Angular-приложение имеет как минимум один корневой модуль, обычно называемый AppModule,' +
        ' который инициализирует приложение.' +
        'NgModule играет жизненно важную роль в организации Angular-приложений. Он обеспечивает модульность, упрощая управление ' +
        'зависимостями, структурирование кода и повторное использование компонентов. Правильное использование NgModule ' +
        'помогает создавать масштабируемые и поддерживаемые приложения.',
      active: false,
    },
    {
      level: 'Junior',
      title: 'Data binding (привязка к данным)',
      response:
        'В шаблоне Angular привязка создает живую связь между частью пользовательского интерфейса, ' +
        'созданной из шаблона (элемент DOM, директива или компонент), и моделью (экземпляр компонента, ' +
        'к которому принадлежит шаблон). Эту связь можно использовать для синхронизации представления с ' +
        'моделью, для уведомления модели о том, что в представлении происходит событие или действие пользователя,' +
        ' или для того и другого. Алгоритм обнаружения изменений Angular отвечает за поддержание синхронизации представления и модели.\n' +
        '\n' +
        'Примеры связывания включают в себя:\n' +
        '\n' +
        'интерполяции текста {{value}},\n' +
        'свойство связывание [value]\n' +
        'привязка событий (click)\n' +
        'двусторонняя привязка [{ngModel}]\n' +
        'Привязки всегда состоят из двух частей: цели , которая будет получать связанное значение, и шаблонного ' +
        'выражения , которое создает значение из модели.',
      active: false,
    },
    {
      level: 'Junior',
      title: 'Что такое @Pipe',
      response:
        ' функция которая преобразует разметку через | если есть доп свойства то через :\n' +
        '  есть pure и impure pipe - у него есть метод трансформ' +
        'Pipe (или "трубка") в Angular — это специальный механизм, который позволяет преобразовывать данные' +
        ' в шаблонах приложения. Pipes используются для обработки и изменения данных перед их отображением' +
        ' пользователю. Они могут применяться для форматирования текста, преобразования дат, чисел, массивов и многого другого.' +
        'Основные характеристики Pipe:\n' +
        '\n' +
        '1. Простота использования:\n' +
        '- Pipes можно легко использовать в шаблонах Angular. Для этого достаточно указать название pipe и передать ' +
        'ему необходимые параметры в интерполяции или директиве.\n' +
        '\n' +
        '2. Чистые и не чистые Pipes:\n' +
        '- Пайпы могут быть чистыми и не чистыми. Чистые Pipes возвращают один и тот же результат при одинаковых ' +
        'входных данных, а не чистые могут выдавать разные результаты с одинаковыми входными данными (например,' +
        ' если они зависят от динамических данных, таких как текущее время).\n' +
        '\n' +
        '3. Встроенные Pipes:\n' +
        '- Angular предоставляет несколько встроенных pipes, например:\n' +
        '- DatePipe: преобразует дату в заданный формат.\n' +
        '- CurrencyPipe: форматирует число в валюту.\n' +
        '- DecimalPipe: форматирует число в десятичный формат.\n' +
        '- JsonPipe: преобразует объект в JSON-строку для отладки.\n' +
        '\n' +
        '4. Пользовательские Pipes:\n' +
        '- Вы можете создавать свои собственные pipes, чтобы реализовать специфическую логику преобразования ' +
        'данных. Для этого необходимо использовать декоратор @Pipe и реализовать метод transform(value: any, ...args: any[]): any.\n',
      active: false,
    },
    {
      level: 'Junior',
      title: 'Хуки жизненного цикла',
      response:
        ' 1.OnChanges - вызывается каждый раз, при установлении свойства\n' +
        '  2.OnInit - один раз при инициализации компонента\n' +
        '  3.DoCheck - при каждом проверки  изменении свойств\n' +
        '  4.AfterContentInit - после проецирования контента в компоненте, вставка в html\n' +
        '  5.AfterContentChecket - после проверки изменения проецируемого контент в шаблон\n' +
        '  6.AfterViewInit - после инициализации представления родительского или дочернего компонента\n' +
        '  7.AfterViewChecket - после проверки представления родительского или дочернего  компонента\n' +
        '  8.OnDestroy - один раз после уничтожения компонента',
      active: false,
    },
    {
      level: 'Junior',
      title: 'Модуль и его свойства',
      response:
        '6.Модуль - класс с декоратором @ngModule - обьединяющая структура  для компонент, сервисов, пайпов, директив\n' +
        '        свойства -\n' +
        '        1.Импорт - массив модулей нужных для нашего\n' +
        '        2.Экспорт - массив компонент, пайпов, директив для экспорта\n' +
        '        3.declaration - массив компонент, пайп, директив\n' +
        '        4.providers - сервисы',
      active: false,
    },
    {
      level: 'Junior',
      title: 'Lazy loading',
      response:
        'Асинхронная маршрутизация, позволяет не сразу создавать модуль, а когда пользователь переходит по определённому роутингу ',
      active: false,
    },
    {
      level: 'Middle',
      title: 'Что такое интерсепторы (interceptors) в Angular?',
      response:
        ' Интерсепторы (interceptors) в Angular являются частью модуля HttpClient и предоставляют' +
        ' мощный механизм для перехвата и обработки HTTP-запросов и ответов. Они позволяют разработчикам' +
        ' добавлять функциональность для каждого запроса и ответа на глобальном уровне, не изменяя сами компоненты' +
        ' или сервисы. Это может быть полезно для обработки заголовков, управления ошибками, добавления токенов аутентификации,' +
        ' логирования, кеширования и других задач.' +
        '\n' +
        'Интерсепторы являются классами, которые реализуют интерфейс HttpInterceptor. Для их создания необходимо выполнить следующие шаги:\n' +
        '\n' +
        '1. Создание класса интерсептора. Он должен реализовать метод intercept, который принимает два параметра: объект HttpRequest' +
        ' и объект HttpHandler. Этот метод должен возвращать объект Observable, который представляет ответ от сервера.\n' +
        '\n' +
        '2. Регистрация интерсептора. Интерсептор необходимо зарегистрировать в корневом модуле приложения или в соответствующем' +
        ' модуле, добавив его в массив providers.' +
        'Применение интерсепторов:\n' +
        '\n' +
        'Интерсепторы могут использоваться для различных задач:\n' +
        '\n' +
        '1. Добавление токенов авторизации. Например, вы можете добавлять JWT-токены в заголовки каждого' +
        ' защищенного запроса.\n' +
        '2. Обработка ошибок. Интерсептор может обрабатывать ошибки от сервера и предоставлять единый подход к' +
        ' этому, вместо необходимости делать это в каждом сервисе или компоненте.\n' +
        '3. Логирование. Вы можете записывать все исходящие запросы и входящие ответы для отладки или аудита.\n' +
        '4. Модификация запросов и ответов. Интерсепторы могут изменять или фильтровать данные запроса и ответа ' +
        'перед их отправкой или после получения.',
      active: false,
    },
    {
      level: 'Middle',
      title: 'Взаимодействие с формами',
      response:
        'В Angular взаимодействие с формами осуществляется с помощью двух основных подходов: реактивные формы и шаблонные формы.' +
        ' Оба подхода позволяют обрабатывать пользовательский ввод и валидировать данные, но используют разные механизмы и подходы.' +
        '1. Шаблонные формы (Template-driven Forms)\n' +
        '\n' +
        'Шаблонные формы ориентированы на использование декларативного подхода и позволяют управлять формами через HTML-шаблоны.' +
        ' Для работы с ними нужно импортировать модуль FormsModule.\n' +
        '2. Реактивные формы (Reactive Forms)\n' +
        '\n' +
        'Реактивные формы ориентированы на использование императивного подхода, предоставляя большую гибкость и контроль над формами.' +
        ' Для работы с реактивными формами нужно импортировать модуль ReactiveFormsModule.' +
        'Оба подхода поддерживают валидацию форм. В шаблонных формах валидация осуществляется через атрибуты (например, required), ' +
        'а в реактивных формах — через встроенные валидаторы или пользовательские валидаторы.' +
        ' Шаблонные формы проще и быстрее в реализации, в то время как реактивные формы предоставляют' +
        ' больше контроля и гибкости, особенно для сложных сценариев.',
      active: false,
    },
  ],
  active: false,
};
