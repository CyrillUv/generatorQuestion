import { IDataQuestion } from '../question';

export const dataPatterns: IDataQuestion = {
  name: 'Паттерны проектирования',
  questions: [
    {
      level: 'Junior',
      title: ' Что такое паттерны проектирования',
      response:
        ' Это способы решения часто встречающихся  проблем при проектировании программ',
      active: false,
    },
    {
      level: 'Middle',
      title: ' Типы паттернов проектирования',
      response:
        ' 1. Паттерны порождения (Creational Patterns):\n' +
        ' Эти паттерны касаются процесса создания объектов. Они помогают создавать экземпляры ' +
        ' объектов в разных ситуациях и обеспечивают контроль над процессом создания.\n' +
        '\n' +
        ' Примеры:\n' +
        ' - Singleton: Гарантирует, что класс имеет только один экземпляр и предоставляет глобальную точку доступа к нему.\n' +
        ' - Factory Method: Определяет интерфейс для создания объектов, позволяя подклассам изменять тип создаваемых объектов.\n' +
        ' - Abstract Factory: Предоставляет интерфейс для создания семейств взаимосвязанных или зависимых объектов без указания их' +
        '  конкретных классов.\n' +
        ' - Builder: Позволяет создавать сложные объекты пошагово.\n' +
        ' - Prototype: Позволяет копировать существующие объекты без зависимости от их классов.\n' +
        '\n' +
        ' 2. Структурные паттерны (Structural Patterns):\n' +
        ' Эти паттерны касаются организации классов и объектов для формирования более крупных структур. ' +
        ' Они помогают упростить проектирование за счёт определения, как классы и объекты могут работать вместе.\n' +
        '\n' +
        ' Примеры:\n' +
        ' - Adapter: Позволяет объектам с несовместимыми интерфейсами работать вместе.\n' +
        ' - Bridge: Разделяет абстракцию и реализацию, чтобы они могли изменяться независимо.\n' +
        ' - Composite: Позволяет создавать деревья объектов и обрабатывать их как единые объекты.\n' +
         '- Decorator: Позволяет добавлять новые функциональные возможности к объектам динамически.\n' +
        ' - Facade: Предоставляет упрощённый интерфейс к более сложным подсистемам.\n' +
        '\n' +
        ' 3. Поведенческие паттерны (Behavioral Patterns):\n' +
        ' Эти паттерны касаются взаимодействия между объектами и определяют, как они взаимодействуют и распределяют ответственность.\n' +
        '\n' +
        ' Примеры:\n' +
        ' - Observer: Определяет зависимость «один ко многим» между объектами, чтобы при изменении состояния одного объекта' +
        ' все зависимые объекты уведомлялись и обновлялись автоматически.\n' +
        ' - Strategy: Определяет ряд взаимозаменяемых алгоритмов, инкапсулирует их и делает их взаимозаменяемыми.\n' +
        ' - Command: Превращает запросы в объекты, позволяя параметризовать клиентов с очередями, запросами и операциями.\n' +
        ' - State: Позволяет объектам менять своё поведение при изменении внутреннего состояния.\n' +
        ' - Chain of Responsibility: Позволяет передавать запросы вдоль цепочки обработчиков, где каждый обработчик решает, ' +
        ' обрабатывать ли запрос или передать его дальше.',
      active: false,
    },
    {
      level: 'Middle',
      title:
        ' Можете кратко описать паттерн «Singleton»? В каких ситуациях он полезен?',
      response:
        ' Паттерн «Singleton» (одиночка) — это порождающий паттерн проектирования, который гарантирует, ' +
        ' что у класса есть только один экземпляр, и предоставляет глобальную точку доступа к этому экземпляру.' +
        ' Основные характеристики паттерна «Singleton»:\n' +
        '\n' +
        ' 1. Единичный экземпляр: Паттерн обеспечивает создание только одного экземпляра класса.\n' +
        ' 2. Глобальный доступ: Предоставляет доступ к своему единственному экземпляру через статический метод или свойство.\n' +
        ' 3. Ленивая инициализация: Экземпляр часто создается только по мере необходимости (по запросу).' +
        ' В Angular Singleton можно реализовать с помощью сервисов. Сервисы, предоставляемые на уровне приложения (в @NgModule), ' +
        ' будут являться синглтонами.' +
        ' Несмотря на преимущества, паттерн Singleton следует использовать с осторожностью, так как он может усложнить тестирование ' +
        ' и управление состоянием приложения.' +
        ' Как правило, его стоит применять только в тех случаях, когда это действительно необходимо.',
      active: false,
    },
    {
      level: 'Middle',
      title: ' Объясните паттерн «Factory Method» и его преимущества',
      response:
        ' Паттерн «Factory Method» (фабричный метод) — это порождающий паттерн проектирования, который предоставляет интерфейс для создания ' +
        ' объектов в суперклассе, но позволяет подклассам изменять тип создаваемого объекта.' +
        ' Этот паттерн помогает делегировать процесс создания объектов, что позволяет упростить код и сделать его более гибким и расширяемым.' +
        ' Основные компоненты паттерна «Factory Method»:\n' +
        '\n' +
        ' 1. Продукт: Интерфейс или абстрактный класс, который определяет тип объектов, создаваемых фабричным методом.\n' +
        '\n' +
        ' 2. Конкретные продукты: Классы, которые реализуют интерфейс продукта.\n' +
        '\n' +
        ' 3. Создатель (Creator): Абстрактный класс или интерфейс, который содержит объявление фабричного метода. Этот метод может возвращать объект типа «Продукт».\n' +
        '\n' +
        ' 4. Конкретные создатели: Подклассы, которые реализуют фабричный метод для создания конкретных типов объектов.' +
        ' Преимущества паттерна «Factory Method»:\n' +
        '\n' +
        ' 1. Изолированность кода: Создание объектов вынесено из клиентского кода, что позволяет сосредоточиться на логике приложения, а не на процессе создания объектов.\n' +
        '\n' +
        ' 2. Производительность и тестирование: Паттерн упрощает тестирование, так как можно легко подменить фабричный метод на заглушку при тестировании.\n' +
        '\n' +
        ' 3. Открытость к расширению: Легко добавлять новые продукты, создавая новые подклассы создателя и продукта, не изменяя существующий код.\n' +
        '\n' +
        ' 4. Гибкость и поддерживаемость: Позволяет динамически выбирать классы в зависимости от состояния приложения или внешних условий, улучшая поддерживаемость кода.\n' +
        '\n' +
        ' 5. Снижение зависимости: Уменьшает зависимость клиентского кода от конкретных классов, что улучшает инкапсуляцию и упрощает возможность изменения кода.\n' +
        '\n' +
        ' Паттерн «Factory Method» часто используется в ситуациях, когда необходимо создавать объекты одного и того же типа, но с различной реализацией. Это позволяет создать более гибкую систему,' +
        ' которая может легко адаптироваться к изменениям.',
      active: false,
    },
    {
      level: 'Middle',
      title: ' Что такое «Observer» паттерн и как он используется?',
      response:
        ' Паттерн «Observer» (наблюдатель) — это поведенческий паттерн проектирования, который определяет зависимость один-ко-многим между ' +
        ' объектами. Когда один объект (изначальный субъект) изменяет свое состояние, все зависимые объекты (наблюдатели) ' +
        ' автоматически оповещаются и обновляются. Это позволяет снизить связность между компонентами и сделать систему более гибкой и расширяемой.\n' +
        '\n' +
        ' ### Основные компоненты паттерна «Observer»:\n' +
        '\n' +
        ' 1. Subject (Субъект): Это объект, который хранит состояние и управляет списком наблюдателей. Он предоставляет методы для добавления,' +
        ' удаления и оповещения наблюдателей.\n' +
        '\n' +
        ' 2. Observer (Наблюдатель): Это интерфейс или абстрактный класс, который объявляет метод для обновления состояния.' +
        ' Наблюдатели должны реализовать этот метод для обработки изменений.\n' +
        '\n' +
        ' 3. ConcreteSubject (Конкретный субъект): Конкретная реализация субъекта, которая хранит состояние и уведомляет наблюдателей об изменениях.\n' +
        '\n' +
        ' 4. ConcreteObserver (Конкретный наблюдатель): Конкретная реализация наблюдателя, которая реагирует на изменения состояния конкретного субъекта.\n' +
        '\n' +
        ' ### Преимущества паттерна «Observer»:\n' +
        '\n' +
        ' 1. Слабая связанность: Наблюдатели не зависят от субъекта, что позволяет легко добавлять или удалять их без изменения кода субъекта.\n' +
        '\n' +
        ' 2. Расширяемость: Можно легко добавлять новых наблюдателей без изменения существующего кода и логики субъекта.\n' +
        '\n' +
        ' 3. Множественные уведомления: Один субъект может оповещать несколько наблюдателей о своих изменениях.\n' +
        '\n' +
        ' 4. Гибкость: Позволяет динамически подключать или отключать наблюдателей во время выполнения программы.',
      active: false,
    },
    {
      level: 'Senior',
      title: ' Преимущества и недостатки паттернов проектирования',
      response:
        ' Преимущества паттернов проектирования:\n' +
        '\n' +
        ' 1. Повторное использование кода:\n' +
        ' - Паттерны предлагают решения, которые можно применять в разных проектах, что уменьшает дублирование и ускоряет разработку.\n' +
        '\n' +
        ' 2. Упрощение проектирования:\n' +
        ' - Паттерны помогают разработчикам сосредоточиться на сути задачи и обеспечивают четкие архитектурные решения.\n' +
        '\n' +
        ' 3. Улучшение читаемости кода:\n' +
        ' - Стандартизированные подходы помогают другим разработчикам быстрее понять и поддерживать код.\n' +
        '\n' +
        ' 4. Упрощение тестирования:\n' +
        ' - Многие паттерны способствуют созданию более модульного и тестируемого кода. Например, паттерн «Dependency Injection» облегчает подмену зависимостей в тестах.\n' +
        '\n' +
        ' 5. Гибкость и расширяемость:\n' +
        ' - Использование паттернов проектирования часто делает систему более гибкой и легко расширяемой, позволяя вносить изменения и добавлять новые функции с минимальными усилиями.\n' +
        '\n' +
        ' 6. Упрощение коммуникации:\n' +
        ' - Использование общепринятой терминологии паттернов облегчает общение между разработчиками, особенно в больших командах.' +
        ' Недостатки паттернов проектирования:\n' +
        '\n' +
        ' 1. Сложность:\n' +
        ' - Некоторые паттерны могут добавлять излишнюю сложность, особенно для небольших проектов, где простое решение более предпочтительно.\n' +
        '\n' +
        ' 2. Потеря производительности:\n' +
        ' - В некоторых случаях использование паттернов может привести к потере производительности (например, из-за лишних абстракций).\n' +
        '\n' +
        ' 3. Неправильное применение:\n' +
        ' - Паттерны могут быть использованы неуместно или избыточно, приводя к усложнению проекта и неэффективной архитектуре.\n' +
        '\n' +
        ' 4. Обучаемость:\n' +
        ' - Паттерны требуют от разработчиков знаний и понимания. Это может создавать порог вхождения для новых членов команды.\n' +
        '\n' +
        ' 5. Зависимость от специфики:\n' +
        ' - Не все паттерны подходят для всех язык программирования или технологий. Их применение может зависеть от контекста.',
      active: false,
    },
    {
      level: 'Middle',
      title: ' Как вы применяли паттерны проектирования в своих проектах?',
      response:
        ' 1. Паттерн «Singleton»:\n' +
        ' Сценарий: В веб-приложении требуется глобальный доступ к конфигурациям или приложению (например, подключение к базе данных).\n' +
        ' Применение: Создание одного экземпляра класса конфигурации, который управляет параметрами приложения.' +
        ' Это может быть реализовано через статический метод или предоставление инстанса через Dependency Injection (например, в Angular).\n' +
        '\n' +
        ' ### 2. Паттерн «Factory Method»:\n' +
        ' Сценарий: Приложение должно создавать объекты различных типов, которые имеют общий интерфейс, но различаются в реализациях.\n' +
        ' Применение: Использование фабричного метода для создания экземпляров классов без указания конкретного класса.' +
        ' Например, можно создавать разных «транспортных» объектов (автомобили, велосипеды) через один общий интерфейс.\n' +
        '\n' +
        ' ### 3. Паттерн «Observer»:\n' +
        ' Сценарий: Необходимо реализовать систему уведомлений (например, в чат-приложении), где несколько объектов должны реагировать на изменения состояния другого объекта.\n' +
        ' Применение: Использование паттерна Наблюдатель для подписки компонентов на события, например, когда поступает новое сообщение, все подписанные компоненты (чаты, уведомления) получают уведомление и обновляют свое состояние.\n' +
        '\n' +
        ' ### 4. Паттерн «Strategy»:\n' +
        ' Сценарий: Нужно реализовать различные алгоритмы обработки данных (например, сортировка).\n' +
        ' Применение: Создание интерфейса для алгоритмов и их реализаций, которые можно менять в зависимости от требований пользователя, передавая нужную стратегию в метод.\n' +
        '\n' +
        ' ### 5. Паттерн «Decorator»:\n' +
        ' Сценарий: Необходимо динамически добавлять функциональность к объектам (например, в графическом редакторе).\n' +
        ' Применение: Использование декораторов для добавления функций к базовому объекту (например, добавление рамок, фильтров к изображениям).\n' +
        '\n' +
        ' ### 6. Паттерн «MVC (Model-View-Controller)»:\n' +
        ' Сценарий: Разработка веб-приложений с четким разделением логики представления и бизнес-логики.\n' +
        ' Применение: Создание структуры приложения, в которой модели управляют данными, контроллеры обрабатывают ввод пользователя, а виды отображают интерфейс, что делает код более организованным и удобным для поддержки.',
      active: false,
    },
    {
      level: 'Senior',
      title:
        ' Можете привести пример, когда использование паттерна решило конкретную проблему?',
      response:
        ' Рассмотрим пример использования паттерна «Observer» (Наблюдатель) в контексте веб-приложения, ' +
        ' где требуется реализация механизма уведомлений о новых событиях. ' +
        ' Этот паттерн может решить проблему, связанную с необходимостью синхронизации данных между различными компонентами приложения.' +
        ' В чат-приложении пользователи должны получать уведомления о новых сообщениях в реальном времени. Если одно из окон чата открыто, ' +
        ' это окно должно обновляться, показывая новые сообщения, когда они поступают.' +
        ' 1. Определение субъектов и наблюдателей:\n' +
        ' - Субъект (или Observable): это класс, который управляет состоянием (например, сообщения в чате) и уведомляет всех подписанных ' +
        ' наблюдателей о любых изменениях.\n' +
        ' - Наблюдатели: это компоненты интерфейса (например, окно чата), которые должны обновляться при поступлении новых сообщений.' +
        ' Использование паттерна «Observer» позволяет легко добавлять новые окна чата (или другие компоненты) и подписывать их на уведомления ' +
        ' о новых сообщениях. Это решение повышает гибкость и расширяемость приложения; например, ' +
        ' если вы решите добавить новые функции (например, уведомления на мобильное устройство), вы можете сделать это, не изменяя существующий код.',
      active: false,
    },
    {
      level: 'Senior',
      title: ' Еще один пример использования паттерна',
      response:
        ' Давайте рассмотрим другой пример, на этот раз с применением паттерна «Strategy» (Стратегия) в контексте электронной коммерции,' +
        ' где необходимо' +
        ' реализовать разные стратегии расчета стоимости доставки в зависимости от типа доставки.' +
        ' Проблема:\n' +
        ' В магазине предусмотрены разные способы доставки, такие как стандартная доставка, экспресс-доставка и доставка в пункт выдачи.' +
        ' Каждый способ имеет свои правила расчета стоимости. Паттерн «Strategy»' +
        ' может помочь изменить стратегию подсчета стоимости доставки в зависимости от выбранного метода, не изменяя основной бизнес-логики приложения.' +
        ' Решение с использованием паттерна «Strategy»:\n' +
        '\n' +
        ' 1. Определение интерфейса для стратегий:\n' +
        ' - Создадим интерфейс ShippingStrategy, который будет определять метод для вычисления стоимости доставки.\n' +
        '\n' +
        ' 2. Реализация конкретных стратегий:\n' +
        ' - Создадим классы для каждой стратегии доставки, реализующие этот интерфейс.\n' +
        '\n' +
        ' 3. Контекст, использующий стратегии:\n' +
        ' - Реализуем класс ShoppingCart, который будет использовать выбранную стратегию для расчета стоимости доставки.' +
        ' Результат:\n' +
        ' Использование паттерна «Strategy» позволяет:\n' +
        ' - Легко добавлять новые способы доставки, создавая новый класс, реализующий интерфейс ShippingStrategy, без изменения существующего кода.\n' +
        ' - Изменять способ доставки в любое время, просто меняя стратегию, установленную в ShoppingCart.\n' +
        ' - Избежать большого количества условных операторов, которые могут усложнить понимание кода.\n' +
        '\n' +
        ' ### Заключение:\n' +
        ' Паттерн «Strategy» предоставляет гибкий и настраиваемый способ определения поведения объектов. В данном примере он элегантно' +
        ' решает проблему управления' +
        ' различными стратегиями расчета стоимости доставки, улучшая чистоту кода и облегчая его дальнейшую поддержку и расширение.',
      active: false,
    },
    {
      level: 'Senior',
      title:
        ' Как выбрать между различными паттернами проектирования для решения одной и той же задачи?',
      response:
        ' Выбор подходящего паттерна проектирования для решения конкретной задачи может быть непростым, так как существует' +
        ' множество паттернов, каждый из которых имеет свои сильные и слабые стороны. Вот несколько шагов и факторов, которые' +
        ' помогут вам принять обоснованное решение:\n' +
        '\n' +
        ' ### 1. Определение задачи:\n' +
        ' - Четко сформулируйте проблему. Непонимание сути проблемы может привести к неправильному выбору паттерна. ' +
        ' Разбейте задачу на подзадачи, чтобы лучше понять требования.\n' +
        '\n' +
        ' ### 2. Анализ требований:\n' +
        ' - Специфика требований. Каковы функциональные и нефункциональные требования (например, производительность, ' +
        ' поддерживаемость, гибкость)?\n' +
        ' - Изменяемость. Насколько вероятно, что требования изменятся в будущем? Если изменения часты, выберите паттерн,' +
        ' который обеспечивает гибкость и расширяемость.\n' +
        '\n' +
        ' ### 3. Изучение контекста применения:\n' +
        ' - Текущая архитектура. Какой подход уже используется в проекте? Порой лучше выбрать паттерн, который будет хорошо сочетаться' +
        '  с существующей архитектурой.\n' +
        ' - Технологии и инструменты. Некоторые паттерны проще реализовать с использованием определенных языков программирования или фреймворков.\n' +
        '\n' +
        ' ### 4. Сравнение паттернов:\n' +
        '- Преимущества и недостатки. Изучите различные паттерны, которые могут подойти для вашей задачи, и сопоставьте их. Например,' +
        ' если вам нужно решить проблему создания объектов, вы можете рассмотреть паттерны «Factory Method», «Abstract Factory» и «Builder».\n' +
        '- Проблемы, которые решает паттерн. Некоторые паттерны лучше подходят для определенных проблем. Например, паттерн «Strategy» ' +
        ' хорошо справляется с изменяемыми алгоритмами, а паттерн «Decorator» — с динамическим добавлением функционала.\n' +
        '\n' +
        ' ### 5. Прототипирование:\n' +
        ' - Создание прототипа. Иногда бывает полезно реализовать небольшой прототип, чтобы проверить, как разные паттерны решают вашу' +
        '  задачу. Протестируйте их на простом примере, чтобы определить, какой из них работает лучше.\n' +
        '\n' +
        ' ### 6. Проверка на практике:\n' +
        ' - Опыт команды. Учитывайте опыт разработчиков, работающих над проектом. Лучше выбирать тот паттерн, с которым ваша команда' +
        '  уже знакома и умеет с ним работать.\n' +
        ' - Документация и примеры. Рассмотрите наличие хороших примеров и документации по паттернам, чтобы упростить реализацию.\n' +
        '\n' +
        ' ### 7. Обсуждение с командой:\n' +
        ' - Совместное обсуждение. Проведите обсуждение с командой, чтобы учесть мнения и опыт других участников. Это может привести' +
        '  к более обоснованному и выверенному решению.\n' +
        '\n' +
        ' ### 8. Поддерживаемость:\n' +
        ' - Учитывайте стоимость изменений. Подумайте о том, насколько легко будет поддерживать код после внедрения выбранного паттерна.' +
        '  Хорошо спроектированные паттерны' +
        ' упрощают поддержку и дальнейшее развитие кода.\n' +
        '\n' +
        ' ### Пример выбора паттернов:\n' +
        '\n' +
        ' Предположим, вам нужно реализовать систему управления платежами:\n' +
        '\n' +
        ' - Если вам нужно управлять различными способами оплаты (картами, электронными кошельками и т.д.), паттерн «Strategy»' +
        ' может подойти лучше всего.\n' +
        ' - Если требуется создание различных типов платежей (например, мгновенные, отложенные), то стоит рассмотреть паттерн «Factory Method».\n' +
        ' - Если вы хотите добавлять новые функции к платежам динамически (например, возможность добавления комиссии для разных' +
        ' типов карт), то паттерн «Decorator» может оказаться полезным.\n',
      active: false,
    },
    {
      level: 'Senior',
      title: ' Как вы бы выбрали между паттернами «Strategy» и «State»?',
      response:
        ' Выбор между паттернами «Strategy» и «State» может быть сложным, поскольку оба паттерна в некоторой степени управляют ' +
        ' поведением объектов, но они предназначены для решения разных задач. Давайте рассмотрим, когда и как можно выбрать один из этих паттернов.\n' +
        '\n' +
        ' ### Общая информация о паттернах:\n' +
        ' 1. Паттерн «Strategy»:\n' +
        ' - Назначение: Позволяет создавать семейство взаимозаменяемых алгоритмов и инкапсулировать каждый из них, позволяя клиенту' +
        ' выбирать, какой алгоритм использовать. Он позволяет изменять алгоритмы независимо от клиентов, которые их используют.\n' +
        ' - Используется, когда: Необходимо динамически менять поведение объекта, в зависимости от алгоритма или стратегии выполнения' +
        ' задачи (например, сортировки, маршрутизации и т.д.).\n' +
        '\n' +
        ' 2. Паттерн «State»:\n' +
        ' - Назначение: Позволяет объекту изменять свое поведение в зависимости от внутреннего состояния. Объект будет вести себя' +
        ' по-разному в зависимости от своего состояния, и состояния могут быть представлены как отдельные классы.\n' +
        ' - Используется, когда: Объект должен вести себя по-разному в зависимости от его состояния (например, состояние «открыто»,' +
        ' «закрыто» у дверей, состояние «ожидание», «выполнение» у задач и т.д.).\n' +
        '\n' +
        ' ### Критерии выбора между «Strategy» и «State»:\n' +
        ' 1. Определение задачи:\n' +
        ' - Если ваша задача связана с выбором между различными алгоритмами или способами выполнения, вам подойдет «Strategy».\n' +
        ' - Если ваша задача связана с изменением поведения объекта в зависимости от его состояния, выбирайте «State».\n' +
        '\n' +
        ' 2. Изменение поведения:\n' +
        ' - В «Strategy» объект может изменить свой алгоритм или поведение без изменения своего состояния.\n' +
        ' - В «State» объект меняет свое поведение в зависимости от того, в каком состоянии он находится, и может изменять состояние' +
        ' в процессе выполнения.\n' +
        '\n' +
        ' 3. Применение в контексте:\n' +
        ' - Представьте, что вы разрабатываете систему валидации данных, где в зависимости от типа данных (например, строка или число)' +
        ' может быть применен один из нескольких алгоритмов валидации. Здесь будет уместен паттерн «Strategy».\n' +
        ' - В другом случае, если у вас есть игровая персонаж, который может находиться в различных состояниях (например, «здоров»,' +
        ' «ранен», «в бою»), и поведение персонажа изменяется в зависимости от текущего состояния, вам подойдет паттерн «State».\n' +
        '\n' +
        ' ### Примеры:\n' +
        '\n' +
        ' Пример использования паттерна «Strategy»:\n' +
        ' Допустим, у вас есть приложение для организации поездок, которое позволяет пользователям выбирать различные маршруты (например,' +
        ' пешеходный, автобусный, велосипедный). Каждое из этих способов передвижения может иметь свой алгоритм расчета маршрута. Здесь ' +
        ' вы можете использовать паттерн «Strategy» для реализации различных маршрутов.\n' +
        '\n' +
        ' Пример использования паттерна «State»:\n' +
        ' Представьте, что вы разрабатываете автоматизированную торговую машину. Она может находиться в различных состояниях: «ожидание' +
        ' выбора», «количество монет недостаточно», «выдача товара», «возврат сдачи». В каждом состоянии машина ведет себя по-разному,' +
        ' в зависимости от текущего состояния. В этом случае паттерн «State» будет подходящим выбором.',
      active: false,
    },
  ],
  active: false,
};
