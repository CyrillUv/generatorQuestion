import { IDataQuestion } from '../question';

export const dataRxjs: IDataQuestion = {
  name: 'rxjs',
  questions: [
    {
      level: 'Junior',
      title: 'Observable и его отличие от промиса ',
      response:
        ' Объекты RxJS Observable создаются либо с использованием операторов создания (of, from, fromEvent), либо через new Observable.' +
        ' Каждый Observable может отправлять своим "потребителям" уведомления вызовом одного из трех методов:\n' +
        '\n' +
        ' next() — отправка данных, количество вызовов не ограничено;\n' +
        ' error() — генерация ошибки, параметром указываются данные любого формата (строка, объект, исключение) о причине ее возникновения;\n' +
        ' complete() — завершение исполнения Observable, не принимает никаких параметров и не передает никакого значения.\n' +
        ' Но исполнение RxJS Observable начнется только после вызова у него метода subscribe(), который принимает функцию с передаваемыми данными в качестве аргумента.' +
        ' Отличие от промиса можно несколько раз подписаться к стриму, отписаться,\n' +
        ' а промис отработает один раз и все',
      active: false,
    },
    {
      level: 'Junior',
      title: 'Subject и его разновидности',
      response:
         ' Разновидность обьектов Observable - стрим где не нужно начальное значение и возвращает последнее\n' +
        '        BehaviorSubject - есть начальное и возвращает последнее\n' +
        '         ReplaceSubject - покажет все значения которые мы ему записывали',
      active: false,
    },
    {
      level: 'Junior',
      title: 'Что можешь сказать об RXjs ?',
      response:
        ' RxJS (Reactive Extensions for JavaScript) — это библиотека для управления асинхронными и событийными данными с использованием реактивного программирования. RxJS позволяет разработчикам собирать и обрабатывать потоки данных, обеспечивая инструменты для работы с асинхронными запросами, событиями и изменениями состояния приложения.\n' +
        '\n' +
        ' ### Основные концепции RxJS\n' +
        '\n' +
        ' 1. Observable (наблюдаемый):\n' +
        ' - Это основной строительный блок RxJS. Observable представляет собой поток данных, который может эмитировать (выдавать) значения асинхронно. Компоненты, которые хотят подписаться на изменения этого потока, могут делать это и получать обновления.\n' +
        '\n' +
        ' 2. Observer (наблюдатель):\n' +
        ' - Это объект, который определяет, как реагировать на данные, эмитируемые Observable. Он может содержать методы для обработки новых значений, ошибок и завершения потока.\n' +
        '\n' +
        ' 3. Subscription (подписка):\n' +
        ' - Когда Observer подписывается на Observable, он получает объект Subscription, который можно использовать для управления подпиской (например, отмены подписки).\n' +
        '\n' +
        ' 4. Operators (операторы):\n' +
        ' - RxJS предоставляет множество операторов для работы с Observable, позволяющих трансформировать, фильтровать, комбинировать и обрабатывать потоки данных. Операторы делятся на две категории:\n' +
        ' - Pipeable operators: Эти операторы используются в цепочке, например, с методом pipe().\n' +
        ' - Creation operators: Операторы, которые используются для создания новых Observable из различных источников данных.\n' +
        '\n' +
        ' 5. Subject:\n' +
        ' - Subject — это особый тип Observable, который позволяет эмитировать значения и получать их от других Observables. Subjects могут многократно излучать один и тот же набор значений.\n' +
        '\n' +
        ' ### Преимущества RxJS\n' +
        '\n' +
        ' - Управление асинхронностью: RxJS упрощает работу с асинхронными запросами и событиями с помощью единой модели, основанной на потоках данных.\n' +
        ' - Композиция: Позволяет легко комбинировать и комбинировать потоки данных, используя операторы.\n' +
        ' - Отмена: Управление подписками позволяет отменять их, чтобы предотвратить утечки памяти.\n' +
        ' - Функциональность: Операторы RxJS предоставляют функциональный подход к обработке данных, что делает код более читаемым и управляемым.',
      active: false,
    },
    {
      level: 'Junior',
      title: 'Что такое Observables?',
      response:
        ' Observables — это один из основополагающих концептов библиотеки RxJS (Reactive Extensions for JavaScript) и являются основным строительным блоком реактивного программирования. Они представляют собой поток данных, который может эмитировать (выдавать) значения во время своей жизненного цикла. Observables позволяют работать с асинхронными данными и событиями, предоставляя простой и мощный способ управления ими.\n' +
        '\n' +
        ' Основные характеристики Observables:\n' +
        '\n' +
        ' 1. Ленивая природа:\n' +
        ' - Observable не начинает эмитировать значения до тех пор, пока на него не подпишется Observer. Это позволяет оптимизировать производительность, избегая ненужных вычислений.\n' +
        '\n' +
        ' 2. Многоразовость:\n' +
        ' - Один и тот же Observable может быть подписан несколько раз, что позволяет нескольким подписчикам получать одни и те же данные. Однако, если вы используете Subject (особый вид Observable), подписчики могут получать разные значения.\n' +
        '\n' +
        ' 3. Асинхронность:\n' +
        ' - Observables хорошо подходят для работы с асинхронными потоками данных, такими как HTTP-запросы, интерактивные события (например, клики или ввод данных), таймеры и т.д.\n' +
        '\n' +
        ' 4. Управление потоками данных:\n' +
        ' - Вы можете эмитировать одиночные значения, массивы значений или даже бесконечные последовательности значений (например, события).\n' +
        '\n' +
        ' Основные методы Observables:\n' +
        '\n' +
        ' - subscribe(observer): Позволяет подписаться на Observable и получать данные, когда они эмитируются. Observer может содержать три метода: next, error, и complete.\n' +
        '\n' +
        ' - pipe(operators): Позволяет применять операторы к Observable для обработки данных (например, map, filter, merge, и многие другие).' +
        ' Когда использовать Observables?\n' +
        '\n' +
        ' - HTTP-запросы: Они позволяют легко обрабатывать данные, возвращаемые от сервера, и управлять асинхронностью.\n' +
        ' - События UI: Например, для обработки событий клика, наведения мыши и других действий пользователя.\n' +
        ' - Timer и интервалы: При создании таймеров или периодических задач.\n' +
        ' - Архитектура приложений: Observables позволяют эффективно управлять состоянием приложений и реакцией на изменения.',
      active: false,
    },
    {
      level: 'Middle',
      title: 'Какие бывают observable?',
      response:
        ' В RxJS существует несколько видов или типов Observables, которые могут быть использованы для работы с различными сценариями и источниками данных. Вот основные типы Observables:\n' +
        '\n' +
        ' 1. Cold Observables (Холодные Observable)\n' +
        '\n' +
        ' - Описание: Холодные Observable создают новый поток данных для каждого подписчика. Каждый раз, когда подписчик подключается, он начинает получать данные с начала.' +
        ' 2. Hot Observables (Горячие Observable)\n' +
        '\n' +
        ' - Описание: Горячие Observable отправляют данные всем подписчикам, которые уже подписаны на поток. Потоки данных могут эмитироваться независимо от наличия подписчиков.' +
        ' 3. Subjects\n' +
        '\n' +
        '- Описание: Subject — это специальный тип Observable, который может одновременно быть и Observable, и Observer. Он может эмитировать значения, а также подписываться на другие Observables.\n' +
        '- Применение: Subjects часто используются для многопоточности и многократного эмитирования одного и того же значения.' +
        ' 4. BehaviorSubject\n' +
        '\n' +
        '- Описание: BehaviorSubject является подтипом Subject и требует начального значения. Он всегда возвращает последнее эмитированное значение своим подписчикам (или начальное значение, если подписчик подключается впервые).\n' +
        '- Применение: BehaviorSubject полезен, когда вам нужно хранить состояние, которое должно быть доступно подписчикам.' +
        ' 5. ReplaySubject\n' +
        '\n' +
        '- Описание: ReplaySubject позволяет хранить заданное количество предыдущих значений и воспроизводить их новым подписчикам.\n' +
        '- Применение: Полезно, когда вы хотите, чтобы новые подписчики получили последние несколько значений.' +
         '6. AsyncSubject\n' +
        '\n' +
        '- Описание: AsyncSubject эмитирует значение только после завершения Observable. Он представляет последнее значение, эмитированное до завершения, даже если этот случай единственный.\n' +
        '- Применение: AsyncSubject полезен в ситуациях, когда вы хотите получить результат только после того, как процесс завершен, например, при выполнении асинхронных операций.\n',
      active: false,
    },
    {
      level: 'Middle',
      title: ' Чем отличается map от switchmap?',
      response:
        ' map и switchMap — это два распространенных оператора в RxJS, которые применяются к Observable. Они используются для преобразования или изменения данных, но имеют разные механизмы работы и области применения. Ниже приведены основные различия между ними:\n' +
        '\n' +
        ' ### 1. Основное назначение\n' +
        ' - map:\n' +
        ' - Преобразует каждое значение, переданное через Observable, в новое значение. Сохраняет порядок и последовательно передает все значения.\n' +
        ' - Например, если вы хотите применить некоторую функцию к каждому элементу потока данных, используйте map.\n' +
        '\n' +
        '- switchMap:\n' +
        '- Преобразует значения, полученные из одного Observable, в новый Observable. Однако, если источник излучает новое значение (например, при вводе данных), switchMap автоматически отписывается от предыдущего Observable и подписывается на новый. Это позволяет избежать проблем с "задержкой" и излишней подпиской на старые значения.\n' +
        '- Например, switchMap часто используется при работе с автозаполнением, где вы хотите отправить запрос на сервер только по последнему введенному значению.\n' +
        '\n' +
        '  ### 2. Поведение при многократных эмиссиях значений\n' +
        '- map:\n' +
        '- Отправляет каждое значение, полученное от источника, через функцию преобразования. Предыдущие значения не влияют на новые. Обработанные значения поступают в том порядке, в котором они были эмитированы.\n' +
        '\n' +
        '- switchMap:\n' +
        ' - Если источник эмитирует новое значение, switchMap отменяет подписку на предыдущий Observable. Это обеспечивает всегда актуальный поток данных и убирает "старые" запросы/данные.' +
        ' Когда использовать\n' +
        '- Используйте map, когда вам нужно просто преобразовать значения, не беспокоясь о том, чтобы управлять подпиской на предыдущие Observable.\n' +
        '- Используйте switchMap, когда вам нужно работать с Observable, которые могут быстро эмитировать значения, и вам необходимо получить только последнее значение, отписываясь от предыдущих.',
      active: false,
    },
    {
      level: 'Middle',
      title:
        ' Как сделать в observable кеширование результата (бехавиор сабджект, паблиш)',
      response:
        ' Кеширование результатов в RxJS с использованием Observable, таких как BehaviorSubject, — это хороший способ избежать повторных вызовов API или других затратных операций для одних и тех же данных. В этом подходе вы можете хранить последнюю' +
        ' эмитированную величину и возвращать ее при новых подписках, чтобы обеспечить доступ к данным, которые уже загружены.' +
        ' 1. BehaviorSubject:\n' +
        ' - Мы создаём экземпляр BehaviorSubject, который будет хранить данные. Метод value позволяет нам получить текущее значение, и если оно не null, мы можем сразу вернуть его подписчикам.\n' +
        '\n' +
        ' 2. Метод getData():\n' +
        ' - При вызове метода сначала проверяем, есть ли уже кэшированные данные.\n' +
        ' - Если они существуют, мы возвращаем его в виде Observable с помощью asObservable().\n' +
        ' - Если данных нет, выполняем HTTP-запрос. После успешного выполнения запроса мы кэшируем результаты, вызывая next(data) на dataSubject.\n' +
        '\n' +
        ' 3. tap:\n' +
        ' - Оператор tap используется, чтобы выполнить действие (кэширование) без изменения данных, которые проходят по цепочке.\n' +
        ' Используя BehaviorSubject для кеширования данных, вы можете предотвратить ненужные запросы и улучшить производительность. Эта реализация также обеспечивает, чтобы все подписчики всегда получали последнее значение, даже если они подписываются после первого запроса.',
      active: false,
    },
    {
      level: 'Middle',
      title: ' Различия switchmap, exhaustMap, concatMap и тд',
      response:
        ' Операторы switchMap, exhaustMap, concatMap и другие являются частью библиотеки RxJS и используются для управления асинхронными потоками данных, особенно в контексте работы с Observables. Вот основные различия между этими операторами:\n' +
        '\n' +
        ' ### 1. map и flatMap (или mergeMap)\n' +
        '\n' +
        ' - Описание: Эти операторы не управляют проходящими потоками, а просто трансформируют каждое значение из исходного Observable.\n' +
        ' - Поведение: Каждый эмитируемый элемент отображается на новый Observable, и все эти Observables объединяются в один поток. Они работают параллельно и не ждут завершения одного потока перед тем, как запустить следующий.\n' +
        '\n' +
        ' ### 2. switchMap\n' +
        '\n' +
        ' - Описание: Используется для создания нового Observable и переключения на него каждый раз, когда поступает новое значение.\n' +
        ' - Поведение: Когда поступает новое значение, предыдущий (более старый) Observable отменяется. Это полезно, например, при обработке автозаполнения ввода, когда результаты предыдущего запроса могут быть неактуальными.\n' +
        '\n' +
        ' ### 3. concatMap\n' +
        '\n' +
        ' - Описание: Создает новый Observable для каждого значения из исходного Observable.\n' +
        ' - Поведение: Обрабатывает значения последовательно. Новый Observable запускается только после завершения предыдущего. Это полезно, когда порядок выполнения имеет значение (например, при отправке запросов к API, где нужен порядок).\n' +
        '\n' +
        ' ### 4. mergeMap\n' +
        '\n' +
        ' - Описание: Это тот же самый оператор, что и flatMap, позволяющий создавать новый Observable для каждого входного значения.\n' +
        ' - Поведение: Все новые Observables обрабатываются одновременно, и их результаты обрабатываются по мере готовности. Это хорошо подходит для ситуаций, где вам нужно получить результаты как можно быстрее, без необходимости следования порядку.\n' +
        '\n' +
        ' ### 5. exhaustMap\n' +
        '\n' +
        ' - Описание: Этот оператор также создает новый Observable, но игнорирует новые входные значения, если предыдущий Observable еще не завершен.\n' +
        ' - Поведение: Это полезно в сценариях, где вы не хотите инициировать новый процесс, пока предыдущий еще активен. Например, если пользователь многократно нажимает кнопку, и вам нужно игнорировать ненужные запросы, пока не завершится предыдущий.\n' +
        '\n' +
        ' ### Вкратце:\n' +
        ' - switchMap: отменяет прежние запросы при новом входе, переключается на последний.\n' +
        ' - concatMap: обрабатывает запросы последовательно.\n' +
        ' - mergeMap (flatMap): обрабатывает запросы параллельно.\n' +
        ' - exhaustMap: игнорирует новые запросы до завершения предыдущего',
      active: false,
    },
    {
      level: 'Middle',
      title: ' Операторы forkJoin,combineLatest,take',
      response:
        ' Оператор forkJoin принимает любой количество Observables, ожидает их завершения, а затем возвращает массив значений ' +
        ' завешенных Observables. Оператор combineLatest() - это еще один полезный оператор RxJS, который позволяет ' +
        ' объединить последние значения, отправленные несколькими потоками observable ' +
        ' , в один поток.Take возвращает Observable, который выдает только первые count значения, выданные исходным Observable. ' +
        ' Если источник выдает меньше count значений, то' +
        ' выдаются все его значения. После этого он завершается, независимо от того, завершается ли источник.',
      active: false,
    },
    {
      level: 'Middle',
      title: ' Операторы skip, tap, map, filter,',
      response:
        ' Skip Пропускает значения до тех пор, пока отправленные уведомления не будут равны или меньше указанного количества пропусков. ' +
        ' Вызывает ошибку, если количество пропусков равно или больше фактического количества эмиттов, и источник выдает ошибку.' +
        ' Tap Используется, когда вы хотите повлиять на внешнее состояние с помощью уведомления, не изменяя само уведомление.' +
        ' Map Как и Array.prototype.map() , он пропускает каждое исходное значение через функцию преобразования для получения соответствующих выходных значений.' +
        ' Filter Как и Array.prototype.filter() , он выдает значение из источника только в том случае, если оно проходит функцию критерия.',
      active: false,
    },
    {
      level: 'Middle',
      title: ' Операторы takeuntil, switchmap, mergemap, cancatmap',
      response:
        ' TakeUntil Позволяет значениям передаваться до тех пор, пока второй Observable, не выдаст значение. Затем он завершается.' +
        ' Switchmap Сопоставляет каждое значение с наблюдаемым, затем выравнивает все эти внутренние наблюдаемые с помощью switchAll(Сглаживает наблюдаемое из наблюдаемых.). ' +
        ' MergeMap Сопоставляет каждое значение с наблюдаемым, затем выравнивает все эти внутренние наблюдаемые с помощью mergeAll(Сглаживает наблюдаемое из наблюдаемых.). ' +
        ' concatMap Сопоставляет каждое значение с наблюдаемым, затем выравнивает все эти внутренние наблюдаемые с помощью concatAll(Выравнивает наблюдаемый из наблюдаемых, помещая один внутренний наблюдаемый за другим.).',
      active: false,
    },
    {
      level: 'Middle',
      title: ' Операторы exhaustMap,zip,pluck,iif',
      response:
        ' exhaustMap Сопоставляет каждое значение с наблюдаемым, затем выравнивает все эти внутренние наблюдаемые с помощью exhaustAll' +
        ' (Выравнивает Observable-of-Observables, отбрасывая следующий внутренний Observables, пока текущий внутренний Observable все еще выполняется).' +
        ' zip Объединяет несколько наблюдаемых объектов для создания наблюдаемого объекта,' +
        ' значения которого вычисляются на основе значений (по порядку) каждого из его входных наблюдаемых объектов.' +
        ' pluck Похож на map, но предназначен только для выбора одного из вложенных свойств каждого отправленного значения.' +
        ' iif Проверяет логическое значение во время подписки и выбирает один из двух наблюдаемых источников',
      active: false,
    },
    {
      level: 'Senior',
      title: ' Операторы timer,interval,of,from,fromEvent',
      response:
        ' timer Используется для отправки уведомления после задержки. ' +
        ' interval Используется для отправки уведомления через отрезки времени.' +
        ' of Преобразует аргументы в Observable последовательность.' +
        ' from Преобразует практически все в Observable объект.' +
        ' fromEvent Создает Observable, который генерирует события определенного типа, исходящие из заданной цели события.',
      active: false,
    },
    {
      level: 'Senior',
      title: ' Операторы startWith,catch,catchError,retry',
      response:
        ' startWith Сначала по порядку выдает свои аргументы, а затем все выбросы из источника. ' +
        ' debounce Выдает уведомление из исходного наблюдаемого только по истечении определенного промежутка времени,' +
        ' определенного другим наблюдаемым, без выброса другого источника.' +
        ' catchError Он только слушает канал ошибок и игнорирует уведомления. Обрабатывает ошибки из исходного наблюдаемого' +
        ' и сопоставляет их с новым наблюдаемым. Ошибка также может быть повторно выдана,' +
        ' или может быть выдана новая ошибка для выдачи ошибки из результата.' +
        ' retry Возвращает Observable, который является зеркальным отражением исходного Observable, за исключением error.' +
        ' delay Задерживает выброс элементов из источника Observable на заданное время или до заданной даты.',
      active: false,
    },
    {
      level: 'Senior',
      title: ' Операторы distinctUntilChanged,distinctUntilKeyChanged,toPromise',
      response:
        ' distinctUntilChanged Возвращает результат Observable, который выдает все значения, отправленные исходным ' +
        ' наблюдаемым объектом, если они отличаются от последнего значения, отправленного результирующим наблюдаемым объектом.' +
        ' distinctUntilKeyChanged Возвращает Observable, который выдает все элементы, выданные исходным Observable, которые отличаются' +
        ' от предыдущего элемента, используя свойство, ' +
        ' доступ к которому осуществляется с помощью предоставленного ключа, для проверки того, являются ли два элемента различными.' +
        ' toPromise',
      active: false,
    },
  ],
  active: false,
};
