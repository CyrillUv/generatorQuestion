import { IDataQuestion } from '../question/type';

export const dataAlgorithms: IDataQuestion = {
  name: 'Алгоритмы',
  questions: [
    {
      level: 'Junior',
      question: 'Что такое алгоритмы?',
      response:
        'Алгоритмы в программировании представляют собой последовательность четко определенных ' +
        'шагов или правил, которые используются для решения определенной задачи или выполнения ' +
        'определенной операции. Алгоритм можно рассматривать как набор инструкций, который переводит' +
        ' входные данные в выходные результаты. Алгоритмы широко применяются ' +
        'в программировании для выполнения различных задач, таких как сортировка данных, ' +
        'поиск информации, обработка изображений и многое другое.',
      active: false,
    },

    {
      level: 'Junior',
      question: 'Сортировка массива пузырьком ',
      response:
        ' Сортировка пузырьком (Bubble Sort) — один из самых простых алгоритмов сортировки. ' +
        'Он работает путем многократного прохода по массиву, сравнения соседних элементов и' +
        ' их обмена местами, если они находятся в неправильном порядке. Процесс продолжается до' +
        ' тех пор, пока не будет выполнен проход без обменов, что означает, что массив отсортирован.\n' +
        '\n' +
        '### Принцип работы алгоритма:\n' +
        '1. Начните с первого элемента массива.\n' +
        '2. Сравните текущий элемент с следующим.\n' +
        '3. Если текущий элемент больше следующего, обменяйте их.\n' +
        '4. Перейдите к следующему элементу и повторите шаги 2-3 до конца массива.\n' +
        '5. После завершения одного полного прохода, повторяйте процесс для всего массива, пока не будет выполнен проход без обменов.',
      active: false,
    },
    {
      level: 'Junior',
      question: 'Поиск числа в массиве',
      response:
        'Поиск числа в массиве может быть выполнен различными алгоритмами в зависимости ' +
        'от того, отсортирован массив или нет.' +
        '1. Линейный поиск (Linear Search)\n' +
        '\n' +
        'Линейный поиск — это самый простой алгоритм, который исследует каждый элемент массива по порядку.' +
        ' Он проверяет каждое значение, пока не найдет нужное число или не достигнет конца массива.' +
        '2. Бинарный поиск (Binary Search)\n' +
        '\n' +
        'Бинарный поиск — это более эффективный алгоритм, который применяется только для отсортированных массивов.' +
        ' Он работает, разбивая массив пополам и проверяя, находится ли искомый элемент в левой или правой половине.' +
        'Сравнение алгоритмов\n' +
        '\n' +
        '- Линейный поиск:\n' +
        '- Сложность времени: O(n) в худшем случае.\n' +
        '- Прост в реализации и применим для неотсортированных массивов.\n' +
        '\n' +
        '- Бинарный поиск:\n' +
        '- Сложность времени: O(log n) в худшем случае.\n' +
        '- Эффективен только для отсортированных массивов и требует меньшего числа сравнений.',
      active: false,
    },
    {
      level: 'Middle',
      question: 'Поиск в глубину',
      response:
        'Поиск в глубину (Depth-First Search, DFS) — это алгоритм для обхода или поиска в структуре данных,' +
        ' такой как граф или дерево. Основная идея алгоритма состоит в том, чтобы начинать с корневой вершины' +
        ' (или произвольной начальной вершины для графов) и как можно глубже исследовать каждую ветвь, прежде' +
        ' чем отступить. DFS может быть реализован как с помощью рекурсии, так и с помощью стека.\n' +
        '\n' +
        '### Принцип работы алгоритма DFS:\n' +
        '\n' +
        '1. Начинайте с корневой вершины и помечайте её как посещённую.\n' +
        '2. Исследуйте все непосещённые соседние вершины, переходя в одну из них и повторяя шаг 1.\n' +
        '3. Если не осталось непосещённых соседей, вернитесь (отступите) к предыдущей вершине и повторите процесс для других непосещённых соседей.\n' +
        '4. Повторяйте процесс, пока все вершины не будут посещены или пока не будет найдено нужное значение (если поиск).' +
        'Характеристики DFS:\n' +
        '- Сложность времени: O(V + E), где V — количество вершин, а E — количество рёбер в графе.\n' +
        '- Сложность по памяти: O(V), т.к. необходимо хранить стеки или рекурсивные вызовы.\n' +
        '- DFS может использоваться для решения задач вроде нахождения компонента связности, проверки простой связности графа,' +
        ' поиска циклов, топологической сортировки и других.',
      active: false,
    },
    {
      level: 'Senior',
      question: 'Обход дерева',
      response:
        '  Обходы дерева — это методы, с помощью которых можно пройти по всем узлам дерева' +
        ' в определённом порядке. Существуют три основных типа обхода для бинарных деревьев:\n' +
        '\n' +
        '1. Прямой обход (Pre-order traversal)\n' +
        'В этом методе сначала обрабатывается (или посещается) текущий узел, затем левые ' +
        'дочерние узлы, и в конце правые дочерние узлы. Этот способ полезен, например, ' +
        'для создания копии дерева или преобразования дерева в префиксную запись.' +
        '2. Центрированный обход (In-order traversal)\n' +
        'При центреходе сначала обрабатываются левые дочерние узлы, затем текущий узел,' +
        ' и в конце правые дочерние узлы. Этот метод используется в бинарных деревьях поиска,' +
        ' поскольку при его выполнении узлы будут посещаться в отсортированном порядке.\n' +
        '3. Обратный обход (Post-order traversal)\n' +
        'В этом методе сначала обрабатываются левые и правые дочерние узлы, и только после' +
        ' этого текущий узел. Этот метод часто используется, когда необходимо выполнить действия,' +
        ' зависящие от дочерних узлов, например, при удалении дерева или вычислении значения в нём.' +
        'Прямой обход подходит для случаев, когда нужно работать с родительским узлом первым, центрированный ' +
        'обход — для работы с отсортированными данными, а обратный обход — для обработки дочерних узлов перед родительскими.',
      active: false,
    },
    {
      level: 'Senior',
      question: 'Алгоритм рекурсивного спуска',
      response:
        'Алгоритм рекурсивного спуска — это метод, который применяется для решения различных задач, включая анализ и ' +
        'обработку выражений, синтаксический анализ и компиляцию языков программирования. Он используется для реализации' +
        ' рекурсивных грамматик. Рекурсивный спуск реализует синтаксический анализ программы, разбивая её на подзадачи с помощью рекурсии.\n' +
        '\n' +
        '### Основные идеи алгоритма\n' +
        '\n' +
        '1. Рекурсивные функции: Каждый элемент грамматики или конструкции языка реализуется через функцию.' +
        ' Если конструкция может быть рекурсивной, функция вызывает саму себя.\n' +
        '\n' +
        '2. Грамматика: Рекурсивный спуск легче всего реализуется для грамматик, которые не содержат левой рекурсии.' +
        ' Это означает, что рекурсивные правила не должны вызывать самих себя в левой части.\n' +
        '\n' +
        '3. Состояние: В процессе анализа алгоритм работает с состоянием, которое включает в себя текущий токен,' +
        ' индекс в исходном потоке и, возможно, дополнительные параметры для хранения промежуточных результатов.' +
        'Преимущества:\n' +
        '- Простота реализации и понимания.\n' +
        '- Хорошо подходит для задач синтаксического анализа.\n' +
        '\n' +
        'Недостатки:\n' +
        '- Неэффективен для грамматик с левой рекурсией.\n' +
        '- Может привести к переполнению стека при глубокой рекурсии.',
      active: false,
    },
  ],
  active: false,
};
