{
  "data-struct": [
    {
      "id": "d7d1"
    }
  ],
  "oop": [],
  "testing": [],
  "rxjs": [
    {
      "id": "e3b4"
    }
  ],
  "typescript": [
    {
      "id": "4162"
    }
  ],
  "patterns": [
    {
      "id": "f3f7"
    }
  ],
  "net-protocols": [
    {
      "id": "3d4d"
    }
  ],
  "angular": [
    {
      "id": "8538"
    },
    {
      "id": "82a5",
      "title": "Что такое Angular?",
      "response": "Angular – это фреймворк для создания клиентских веб-приложений, разработанный компанией Google. Он позволяет создавать динамические веб-приложения, обеспечивая высокую производительность и гибкость кода.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "52fa",
      "title": "Как на Angular2 и Angular8 при получении данных с бэка парсить их в модель?",
      "response": "На Angular (как версии 2, так и 8) процесс получения данных с бэкенда и их парсинга в модель можно описать следующими этапами:1. Определение модели данных Перед тем, как получать данные, необходимо определить, как они будут представляться в приложении. Это включает в себя создание модели, которая описывает структуру данных, получаемых от бэкенда. Например, если вы работаете с пользователями, вам нужно решить, какие свойства будут у пользователя (например, имя, email, возраст и т.д.). 2. Создание сервиса Создайте сервис, который будет отвечать за взаимодействие с API бэкенда. Этот сервис будет отправлять HTTP-запросы к серверу для получения данных. Важно, чтобы сервисы в Angular отвечали за логику работы с данными, отделяя эту логику от компонентов, которые отображают данные.3. Запрос к API Сервис использует методы для отправки запросов к API для получения данных. В ответ на запрос бэкэнд возвращает данные, обычно в формате JSON. После получения этих данных сервис должен обработать их, чтобы они соответствовали модели.4. Парсинг данных На этом этапе происходит преобразование данных, полученных с бэкенда, в объекты вашей модели. Это включает в себя сопоставление свойств, которые пришли от сервера, с полями вашей модели. Если структура данных соответствует ожидаемым полям модели, то можно создать экземпляры модели с полученными значениями.\n5. Использование данных в компоненте После того, как данные были успешно преобразованы в объекты модели, их можно использовать в компонентах Angular. Компоненты могут подписываться на сервисы, чтобы получать данные, и обновлять свое состояние, чтобы отобразить эти данные на экране. Это значит, что компоненты могут легко обновлять представление в зависимости от данных, получаемых из сервиса.6. Обработка ошибок Всегда полезно обрабатывать возможные ошибки, которые могут возникнуть при запросах к бэкенду. Это может быть сделано путем проверки ответов от сервера и добавления соответствующей обработки ошибок. Заключение: В итоге, процесс парсинга данных из бэкенда в Angular включает в себя определение модели данных, создание сервиса для работы с API, выполнение запросов, их обработку и преобразование в объекты модели, а затем использование этих данных в компонентах приложения. Такой подход позволяет поддерживать чистую архитектуру и легкость управления данными в приложении.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "7541",
      "title": "Расскажи про guardы?",
      "response": "Гарды (guards) в Angular — это механизм, который позволяет контролировать доступ к определённым маршрутам (pages) в вашем приложении. Они действуют как защитные слои, проверяя, имеет ли пользователь право переходить на определённые страницы или выполнять определённые действия. Гарды помогают реализовать маршрутизацию с учетом авторизации, аутентификации и других условий. Основные виды гардов в Angular: 1. CanActivate: - Проверяет, может ли пользователь перейти на определённый маршрут. Если метод возвращает true, переход разрешён; если false, переход отменяется.- Используется для проверки, прошел ли пользователь аутентификацию или имеет ли права доступа к определённому маршруту.2. CanActivateChild:Работает аналогично CanActivate, но применяется к дочерним маршрутам. Это позволяет контролировать доступ ко всем дочерним маршрутам конкретного родительского маршрута.3. CanDeactivate:- Переход контролируется, когда пользователь пытается покинуть текущий маршрут. Например, это может быть полезно, если у вас есть форма, и вы хотите предупредить пользователя о том, что он потеряет несохраненные данные.4. Resolve:- Используется для получения данных перед активацией маршрута. Это позволяет загружать данные заранее и передавать их в компонент, что полезно для случаев, когда вы хотите отображать данные, прежде чем пользователь увидит страницу.5. CanLoad:- Проверяет, имеет ли пользователь доступ к загрузке определённого модуля. Это используется для ленивой загрузки маршрутов, что позволяет загружать модули только при необходимости. Это помогает улучшить производительность приложения, предотвращая загрузку ненужных модулей.Как работают гарды:Гарды реализуются в виде сервисов. Чтобы создать гард, вы можете использовать Angular CLI, который автоматически создаст необходимый сервис. Каждый гард должен реализовывать интерфейс, соответствующий его типу (например, CanActivate), и реализовывать метод, который будет возвращать true или false, либо Observable boolean> или Promise boolean>.Пример использования гарда:1. Создание гарда: Вы создаете гард, который проверяет, старше ли пользователь определенного возраста.2. Имплементация логики: В методе проверяете возраст пользователя и возвращаете true или false.3. Настройка маршрутов: В маршрутах указываете, какой гард применить к конкретному маршруту, тем самым обеспечивая контроль доступа.Преимущества использования гардов:- Позволяют улучшить безопасность вашего приложения, предотвращая несанкционирован- Обеспечивают лучшую управляемость переходов между маршрутами, особенно в сложных приложениях с множеством условий доступа.- Помогают загружать необходимые данные перед тем, как пользователь увидит страницу, что улучшает пользовательский опыт.В целом, гарды в Angular являются мощным инструментом для управления доступом к маршрутам и организации логики переходов в приложении.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "6f7e",
      "title": "Использовали ли сторонние библиотеки для форм? Angular Material?",
      "response": "Да, в Angular часто используются сторонние библиотеки для работы с формами, и одной из наиболее популярных таких библиотек является Angular Material. Вот несколько аспектов, касающихся использования Angular Material и других библиотек для работы с формами:Angular Material 1. UI-компоненты: Angular Material предоставляет набор предопределённых пользовательских интерфейсных компонентов, которые соответствуют Material Design. Это включает в себя различные элементы форм, такие как текстовые поля, селекты, чекбоксы, радиокнопки и другие.3. Валидация: Angular Material делает процесс валидации форм более удобным. Компоненты формы интегрированы с механизмом валидации Angular, что позволяет легко отображать сообщения об ошибках и советы пользователям.4. Интерактивность: Angular Material поддерживает различные интерактивные возможности, такие как автозаполнение, выпадающие списки и адаптивное поведение в зависимости от размера экрана. Это улучшает взаимодействие пользователей с формами.Другие сторонние библиотеки 1. Ngx-formly: Это библиотека для создания динамических форм в Angular. Она позволяет определять формы с использованием JSON и автоматически генерировать пользовательский интерфейс на основе этого определения. Это особенно полезно для приложений с изменяемыми требованиями к формам.2. Reactive Forms: Хотя это не совсем сторонняя библиотека, это важный подход в Angular. Reactive Forms предоставляет более мощные инструменты для управления состоянием форм и их валидацией по сравнению с Template-driven Forms. Reactive Forms позволяют легче отслеживать изменения формы и управлять их состоянием.3. ngx-bootstrap и PrimeNG: Эти библиотеки также предлагают компоненты для работы с формами, в том числе таблицы, модальные окна и различные элементы управления. Они могут быть использованы в сочетании с Angular Material или другим стилем приложения в зависимости от требований проекта.Заключение:Использование сторонних библиотек, таких как Angular Material, значительно упрощает разработку форм в Angular-приложениях. Они не только предоставляют готовые компоненты, но и обеспечивают удобное взаимодействие с пользователями, улучшая общее восприятие приложения. Выбор библиотеки зависит от конкретных потребностей вашего проекта, предпочтений по стилю и дизайну, а также уровня требуемой функциональности.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "ca5b",
      "title": "Пользуетесь типизацией в typescript или используете как дефолтный инструмент для Angular?",
      "response": "Типизация в TypeScript является одной из его ключевых особенностей, и в большинстве случаев использование типизации рассматривается как важная практическая практика при разработке приложений на Angular. Вот несколько причин, почему типизация считается полезной и важной в контексте Angular:1. Улучшенная безопасность типов - Использование типизации позволяет обнаруживать ошибки на этапе компиляции вместо выполнения, что снижает вероятность возникновения ошибок во время выполнения приложения.- Это особенно полезно в крупных приложениях, где сложно отслеживать типы данных, передаваемых между компонентами, сервисами и другими частями приложения.2. Лучшее автозавершение и поддержка IDE - Типы помогают интегрированным средам разработки (IDE) предоставлять более точные подсказки, автозавершение и документацию для методов и свойств.- Это упрощает разработку, поскольку разработчики могут легче понимать структуры данных и интерфейсы, используемые в приложении.3. Чёткое определение интерфейсов и моделей - В TypeScript можно использовать интерфейсы и классы для явного определения структуры объектов и моделей данных, что делает код более понятным и поддерживаемым.- Это помогает обеспечить единообразие в использовании объектов в разных частях приложения.4. Поддержка и расширяемость - Типизация упрощает совместную работу в команде, поскольку другие разработчики могут легко понять, какие данные ожидаются, и какие структуры данных необходимы для использования.- Это делает код более удобным для тестирования и расширения, поскольку вы точно знаете, какие типы передаются в функции и компоненты.5. Использование сложных типов - TypeScript позволяет использовать сложные типы данных, такие как объединения (union types), пересечения (intersection types) и типы с помощью дженериков. Это помогает создавать более гибкие и обобщенные компоненты и сервисы.- Это особенно полезно для сложных бизнес-логик и компонентов, которые могут обрабатывать разнообразные данные. \nЗаключение:Таким образом, хотя TypeScript и является дефолтным инструментом для Angular, использование типизации в TypeScript не следует рассматривать как опцию, а как рекомендацию. Это не только улучшает надежность и читаемость кода, но и делает разработку более эффективной и управляемой, что критически важно в современных веб-приложениях.Поэтому большинство разработчиков на Angular активно используют типизацию TypeScript для повышения качества своего кода.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "8b08",
      "title": "Что такое change detection? В чём разница между default и push?",
      "response": "Change Detection (обнаружение изменений) в Angular — это механизм, который отслеживает изменения в данных и обновляет пользовательский интерфейс (UI) в соответствии с этими изменениями. Angular использует этот механизм для актуализации представления приложения, когда данные изменяются в модели. С помощью обнаружения изменений вы можете автоматически реагировать на изменения состояния приложения, обеспечивая синхронизацию между моделью и представлением.Как работает обнаружение изменений в Angular Angular обновляет представление компонентов при помощи так называемого механизма обнаружения изменений. Он основан на концепции \"потока\" данных и использует различные стратегии для определения изменений:1. Zone.js: Angular использует библиотеку Zone.js, чтобы отслеживать асинхронные операции, такие как события, таймеры и HTTP-запросы. Когда такие операции завершаются, Angular знает, что необходимо проверить, произошло ли изменение.2. Change Detection Strategy: У каждого компонента в Angular есть стратегия обнаружения изменений, которая определяет, как именно Angular будет отслеживать изменения в этом компоненте. Стратегии обнаружения изменений В Angular существуют две основные стратегии обнаружения изменений:1. Default Change Detection (Default strategy):- Это стандартная стратегия обнаружения изменений, используемая по умолчанию для всех компонентов.- Angular проверяет каждую часть дерева компонентов на изменения после каждой асинхронной операции (например, при событиях, таймерах и HTTP-запросах).- Это означает, что Angular будет периодически проверять все компоненты с целью указать, есть ли изменения в их переменных, и обновлять соответствующее представление при необходимости.- Эта стратегия проста в использовании и подходит для большинства приложений, но может привести к неэффективности в производительности, особенно в сложных приложениях с глубоким деревом компонентов.\n2. OnPush Change Detection (OnPush strategy):- Эта стратегия оптимизирует производительность компонента, проверяя только те компоненты, которые имеют изменения в своих входных параметрах (inputs), или те, которые вызывают события.- Angular не проверяет компонент, если не были выполнены изменения в его свойствах, и если он не реагирует на события в его пределах. Это означает, что если никаких изменений не произошло, компонент не будет проверяться на изменения, что снижает нагрузку на производительность.- Компоненты с OnPush должны использовать иммутабельные данные (immutable data) или производить изменения экземпляра для вызова обновлений. - OnPush может быть полезен в больших и сложных приложениях, где производительность имеет важное значение.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "19da",
      "title": "ngZone",
      "response": "NgZone — это сервис в Angular, который позволяет управлять контекстом выполнения асинхронного кода и обеспечивать обнаружение изменений. Он является частью механизма, который позволяет Angular отслеживать изменения в приложении и обновлять представление в соответствии с изменениями состояния. NgZone использует библиотеку Zone.js для работы с зонами, изолированными контекстами выполнения, которые позволяют отслеживать асинхронные операции.Основные функции NgZone:1. Обнаружение изменений:- NgZone позволяет Angular эффективно отслеживать изменения, происходящие в приложении, автоматически активируя обнаружение изменений после завершения асинхронных операций (таких как HTTP-запросы, таймеры и события). Это обеспечивает автоматическое обновление представления, когда данные меняются.2. Контроль над изменениями:- NgZone предоставляет методы для управления тем, когда Angular должен проверять изменения. Вы можете использовать его для временного выхода из зоны (например, при выполнении операций, которые не требуют изменений в UI), что может помочь улучшить производительность.3. Методы NgZone:- run(): Этот метод запускает функцию внутри контекста Angular, активируя обнаружение изменений. Это полезно, если вы хотите выполнить некоторые действия и убедиться, что изменения будут отслежены.- runOutsideAngular(): Этот метод позволяет выполнять функции вне контекста Angular. Это важно, если вы хотите избежать избыточного отслеживания изменений и улучшить производительность (например, при использовании сторонних библиотек для работы с событиями или анимациями).",
      "level": "Middle",
      "active": false
    },
    {
      "id": "68d8",
      "title": "Чем e2e-тесты отличаются от unit-тестов?",
      "response": "E2E-тесты (end-to-end тесты) и unit-тесты (модульные тесты) являются двумя различными уровнями тестирования программного обеспечения, и каждый из них имеет свои особенности, цели и области применения.Unit-тесты Определение:Unit-тесты предназначены для проверки отдельных \"единиц\" кода, таких как функции, методы или классы, в изоляции от остальной части системы.Основные характеристики:1. Изоляция: Каждый unit-тест проверяет только одну конкретную функциональность, отделённую от других частей приложения. Это достигается через использование моков (mocks), заглушек (stubs) или фейков (fakes).2. Скорость: Unit-тесты обычно выполняются быстро, так как они не требуют взаимодействия с внешними компонентами, такими как база данных или API.3. Инструменты: Для написания unit-тестов часто используются фреймворки, такие как Jasmine, Mocha, Jest и другие.4. Простота: Unit-тесты проще для реализации и отладки, так как они сосредоточены на маленьких кусках кода.5. Цели: Основная цель unit-тестов — выявление ошибок в логике отдельных модулей и обеспечение правильного функционирования этих модулей.E2E-тесты:Определение:E2E-тесты проверяют приложение в целом, имитируя поведение пользователя, чтобы убедиться, что все части системы работают вместе должным образом. Основные характеристики:1. Полное тестирование: E2E-тесты проверяют все слои приложения, включая фронтенд, бэкенд, базы данных и другие взаимодействия. Они проверяют, как различные модули и компоненты работают вместе.2. Сложность: E2E-тесты более сложные в написании и поддержке, поскольку требуют настройки тестовых данных и окружения.3. Скорость: E2E-тесты обычно медленнее, чем unit-тесты, из-за необходимости симуляции всей системы и взаимодействия с различными компонентами.4. Инструменты: Для E2E-тестирования часто используются инструменты, такие как Protractor, Cypress, Selenium и другие.5. Пользовательский опыт: E2E-тесты предназначены для проверки пользовательского опыта, начиная с загрузки страницы и заканчивая действиями пользователя, такими как нажатия кнопок и ввод данных.6. Цели: Основная цель E2E-тестов — удостовериться, что приложение работает как единое целое и что все его части правильно взаимодействуют друг с другом.Заключение:В целом, оба типа тестирования важны и дополняют друг друга в процессе разработки программного обеспечения. Unit-тесты обеспечивают проверку отдельных компонентов на грамматические ошибки и ошибки логики, тогда как E2E-тесты подтверждают , что приложение работает корректно при взаимодействии всех компонентов. Чаще всего в проектах комбинируют оба подхода, чтобы получить более полное покрытие и уверенность в качестве кода.",
      "level": "Senior",
      "active": false
    },
    {
      "id": "a203",
      "title": "Что такое pipe? Расскажите про async pipe?",
      "response": "В Angular pipe (пайп) — это специальный механизм, позволяющий трансформировать данные в шаблонах. Пайпы применяются для изменения форматирования, преобразования и фильтрации данных при их отображении в UI. Они представляют собой функции, которые могут быть использованы в выражениях Angular для изменения значений, прежде чем они будут отображены в HTML.Основные характеристики пайпов:\n1. Чистота: Пайпы могут быть чистыми или грязными. Чистые пайпы не изменяют входные данные и возвращают одно и то же значение для одного и того же входного значения. Грязные пайпы могут возвращать разные результаты при каждом вызове.2. Параметры: Пайпы могут принимать дополнительные параметры для настройки их поведения.3. Композиция: Пайпы могут быть вложены друг в друга, позволяя комбинировать их функции.Async Pipe Async Pipe — это специальный пайп в Angular, который упрощает работу с асинхронными данными, такими как результаты HTTP-запросов, промисы или потоки (Observables). Он позволяет автоматически подписываться на Observable или промис и обновлять представление, когда приходит новое значение.Основные функции Async Pipe: 1. Подписка и отписка: Async Pipe автоматически подписывается на Observable при загрузке компонента и отписывается при уничтожении компонента. Это помогает избежать утечек памяти и упрощает управление подписками.2. Актуализация данных: Async Pipe автоматически обновляет отображаемые данные в шаблоне, когда Observable эмитирует новое значение. Пайпы, в том числе Async Pipe, являются очень удобным инструментом для работы с данными в Angular. Они позволяют легко и эффективно форматировать и трансформировать данные непосредственно в шаблонах, а также упрощают работу с асинхронными данными, автоматизируя управление подписками и актуализацией данных в пользовательском интерфейсе.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "faee",
      "title": "Жизненный цикл компоненты",
      "response": "В Angular жизненный цикл компонента описывает последовательность событий и методов, через которые проходит компонент с момента его создания до уничтожения. Понимание жизненного цикла компонентов позволяет разработчикам лучше управлять состоянием и поведением компонентов, а также выполнять определенные действия на различных этапах их существования. Основные стадии жизненного цикла компонента и их хуки 1. Создание - ngOnChanges(): Вызывается при изменении входных свойств компонента. Этот хук получает объект SimpleChanges, который содержит информацию о предыдущих и текущих значениях входных свойств. Используется для реакции на изменения входных данных.2. Изменение - ngDoCheck(): Вызывается во время каждого цикла обнаружения изменений и позволяет разработчику реагировать на изменения, которые Angular не может отследить автоматически. 3. Отображение - ngAfterContentInit(): Вызывается после того, как контент (ng-content) был проинициализирован. Это позволяет выполнять действия, которые зависят от наличия содержимого в компоненте.- ngAfterContentChecked(): Вызывается после проверки содержания компонента. Здесь можно выполнять действия, зависимые от изменений в контенте.- ngAfterViewInit(): Вызывается после инициализации представления компонента и всех дочерних представлений. Здесь можно выполнять действия, которые требуют доступа к дочерним компонентам.- ngAfterViewChecked(): Вызывается после проверки представления и дочерних представлений. Этот метод можно использовать для выполнения дополнительных действий после каждой проверки.4. Уничтожение:- ngOnDestroy(): Вызывается перед уничтожением компонента. Здесь можно выполнять финальную уборку, освобождать ресурсы, такие как подписки на события или таймеры, для предотвращения утечек памяти.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "35d6",
      "title": "Почему change работает раньше onInit (чендж детекшн)",
      "response": "Почему изменение данных может вызвать обнаружение изменений до выполнения метода ngOnInit.1. Состояние данных перед ngOnInit():- Когда компонент инициализируется, его свойства могут быть уже установлены в определенные значения. Если эти свойства изменяются до вызова ngOnInit, Angular запускает обнаружение изменений, чтобы отражать эти изменения в интерфейсе.2. Процесс обнаружения изменений:- Angular использует механизм изменений, чтобы отслеживать изменения состояния в приложении. Этот механизм реагирует на изменения, происходящие в свойствах компонента.3. Очередность вызовов:- Как только Angular заметит изменения входных данных или состояния, он инициирует обнаружение изменений, что может привести к перерисовке компонента, даже если метод ngOnInit еще не был вызван. Однако, после этого Angular также вызовет ngOnInit() для выполнения дополнительной логики и инициализации.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "99ed",
      "title": "Viewchild от contentChild",
      "response": "В Angular @ViewChild и @ContentChild — это декораторы, которые используются для получения ссылок на компоненты, директивы или элементы DOM, но у них есть разные области применения и методы работы. Давайте рассмотрим каждую из этих аннотаций более подробно.@ViewChild Определение:@ViewChild позволяет получить доступ к дочерним компонентам, директивам или элементам шаблона, которые находятся в пределах самого компонента. Это означает, что @ViewChild используется для доступа к элементам, которые находятся в шаблоне текущего компонента.@ContentChild Определение:\n@ContentChild позволяет получить доступ к дочерним компонентам или элементам, которые были переданы в родительский компонент через ng-content>. Это означает, что @ContentChild используется для доступа к элементам, которые находятся вне шаблона текущего компонента, но были вставлены в него. Как использовать: Для использования @ContentChild необходимо вставить элемент в родительский компонент, проделав это с помощью ng-content. <br><app-parent><br>  <child-component></child-component><br></app-parent><br> Основные отличия 1. Положение элементов:- @ViewChild: Получает доступ к дочерним компонентам, директивам или элементам, которые находятся внутри текущего компонента. - @ContentChild: Получает доступ к элементам, которые были переданы в текущий компонент через ng-content.2. Событие инициализации:- @ViewChild: Необходимо использовать в методах жизненного цикла, таких как ngAfterViewInit, чтобы быть уверенным, что элемент инициализирован.- @ContentChild: Обычно используется в ngAfterContentInit, поскольку контент может быть вставлен после инициализации компонента.3. Контекст использования:- @ViewChild: Используется для взаимодействия с элементами/компонентами, которые являются частью самого компонента (например, элементы формы, дочерние компоненты).- @ContentChild: Используется для получения доступа к элементам, которые вставлены в компонент извне, например, элементы, переданные через контент.",
      "level": "Middle",
      "active": true
    },
    {
      "id": "05c6",
      "title": "Как стили навесить на viewChild (renderer2) ",
      "response": "В Angular, чтобы навесить стили на элемент, полученный с помощью @ViewChild, вы можете использовать Renderer2. Это позволяет вам динамически изменять стили элемента в безопасном и независимом от платформы способом. Ниже приведен пример того, как это можно сделать.Шаги для изменения стилей с помощью Renderer2 и @ViewChild 1. Импортируйте необходимые модули.2. Получите ссылку на элемент через @ViewChild.3. Используйте сервис Renderer2 для управления стилями.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "7ead",
      "title": "У нас есть код модули, как разбить код на модули ",
      "response": "Разбиение кода на модули - это важный аспект организации и управления проектом в Angular. Модули позволяют вам структурировать приложение, улучшить его читаемость и повторное использование кода. Вот шаги и рекомендации о том, как разбить код на модули в Angular:Причины для разбивки на модули 1. Структурирование кода: Модули помогают организовать код по функциональным направлениям.2. Улучшение производительности: Модули могут загружаться лениво (lazy loading), что ускоряет начальную загрузку приложения.3. Повторное использование: Модули можно использовать в разных частях приложения или даже в других проектах.Шаги для разбиения кода на модули 1. Определите функциональные области Сначала разделите приложение на логические секции. Например:- Пользовательский интерфейс (UI)- Аутентификация - Продукты или товары - Заказы или корзина - Админ-панель 2. Создайте модули 3. Переместите компоненты и сервисы 4. Настройте маршрутизацию 5. Импортируйте общий модуль 6. Настройте ленивую загрузку (если необходимо)",
      "level": "Junior",
      "active": false
    },
    {
      "id": "0e9a",
      "title": " Стал бы ты провайдить сервисы в шаред модуль",
      "response": "Да, обычно сервисы провайдятся в shared модуль, чтобы их можно было использовать в разных модулях приложения. Это помогает избежать дублирования кода и упрощает управление  зависимостями. Убедитесь, что сервисы являются stateless (без состояния) или могут безопасно работать с состоянием, если это необходимо",
      "level": "Middle",
      "active": false
    },
    {
      "id": "db83",
      "title": "Реактивные формы плюсы в чем плюсы",
      "response": "Плюсы реактивных форм в Angular:1. Контроль состояния: Обеспечивает строгий контроль над состоянием формы и её элементами.2. Модульность: Упрощает разделение форм на мелкие, управляемые компоненты.3. Тестируемость: Упрощает тестирование, так как логика формы отделена от представления.4. Удобное управление валидаторами: Легко добавлять и изменять валидаторы в реальном времени.5. Лучше с асинхронными данными: Удобнее работать с асинхронными операциями, такими как запросы к серверу.6. Императивный подход: Позволяет управлять формами через программный код, что может быть более понятно для разработчиков.'7. Динамическое изменение форм: Упрощает создание форм с динамическим набором полей и зависимостями между ними.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "46e1",
      "title": "Разница между 6-ым и 9-ым Angular? Что поменялось в плане работы с backEnd",
      "response": "Angular активно развивается, и между версиями 6 и 9 были внесены значительные изменения и улучшения. Вот основные изменения и отличия между Angular 6 и Angular 9, особенно в контексте работы с бэкендом:1. Ivy Renderer - Angular 9: Одной из самых заметных изменений в Angular 9 стал новый рендерер под названием Ivy. Ivy улучшает производительность, уменьшает размер бандла и значительно ускоряет время компиляции. Благодаря Ivy теперь проще и быстрее оптимизировать загрузку приложений.- Angular 6: Использовал стандартный рендерер.2. Анализ времени сборки - Angular 9: Новый рендерер Ivy предоставляет улучшенные возможности для анализа приложения и позволяет лучше оптимизировать время сборки и размеры финального бандла.3. Упрощение использования Angular для работы с HTTP - Angular 6: В этой версии были введены улучшения в модуле HttpClient, но основные изменения в основном касались улучшения обращений к API.- Angular 9: Были улучшены возможности работы с HttpClient и добавлены дополнительные возможности, такие как более удобные инструменты для использования RxJS на уровне сервисов. Более гибкие механизмы для обработки ошибок и применения интерсепторов.4. Ручное указание зависимостей - Angular 9: Улучшена поддержка \"Ручного указания зависимостей\" через providedIn на уровне сервиса, что делает внедрение зависимостей более простым и понятным. Это улучшает работу с DI и некоторыми сценариями, которые могут возникнуть при взаимодействии с бэкендом.5. Улучшения в CLI - Angular 9: Улучшены инструменты Angular CLI, которые обеспечивают более простой и быстрый процесс создания приложений и управления зависимостями. Новые функции, такие как возможность создания компонентов без необходимости вручную обновлять модули, делают разработку быстрее.6. Зависимости на уровне библиотеки - Angular 9: Старая структура зависимостей была улучшена для библиотек, что сделало процесс работы с библиотеками более интуитивным. Это упрощает интеграцию сторонних библиотек и работу с API, обеспечивая более гладкое взаимодействие с бэкендом.7. Поддержка Internationalization (i18n) - Angular 9: Улучшение системы локализации, что позволяет проще работать с многоязычными приложениями.Заключение: общем,Angular 9 обеспечивает более удобную компиляцию, лучшую производительность и оптимизацию. Работая с бэкендом, у разработчиков теперь есть дополнительные инструменты, которые упрощают процесс интеграции с API и обработку данных. Улучшенная отдача от Ivy также делает общую производительность приложений выше по сравнению с Angular 6.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "9cb9",
      "title": "Что такое компонент в Angular?",
      "response": "Компоненты являются основными строительными блоками Angular-приложений и содержат логику и представление.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "12dd",
      "title": "Что такое сервисы и как их использовать?",
      "response": "Сервисы — это классы, которые предоставляют определённый функционал и могут быть использованы для  обмена данными и выполнения логики, которая не привязана к конкретному компоненту. Сервисы помогают реализовать архитектуру, при которой код становится более модульным, переиспользуемым и легче поддерживаемым.Обычно они используются для взаимодействия с API, хранения и обработки данных, а также для реализации различных функций,таких как маршрутизация, аутентификация и т.д. Основные характеристики сервисов:1. Инъекция зависимостей: Angular использует механизм инъекции зависимостей для создания экземпляров сервисов,что позволяет автоматически управлять их жизненным циклом и зависимостями.2. Переиспользуемость: Сервисы могут быть использованы в разных компонентах, что повышает переиспользуемость кода.3. Модульность: Сервисы способствуют разделению бизнес-логики и логики представления (UI), что улучшает структуру кода.4. Тестируемость: Благодаря высокой модульности, сервисы легче тестировать отдельно от компонентов.Как правило, сервис регистрируется автоматически при использовании декоратора @Injectable с свойством providedIn: 'root'. Это делает его доступным в корневом модуле вашего приложения. Вы также можете зарегистрировать сервис в конкретном модуле или компоненте,добавив его в массив providers соответствующего декоратора.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "efc2",
      "title": "Каковы основные характеристики Angular?",
      "response": "1. Компонентный подход Angular основан на компонентной архитектуре, что позволяет разбивать интерфейс приложения на управляемые и переиспользуемые компоненты. Каждый компонент инкапсулирует свою логику, шаблон и стили, что упрощает разработку и сопровождение приложения.2. Двусторонняя привязка данных Angular поддерживает двустороннюю привязку данных (two-way data binding), что позволяет автоматически синхронизировать данные между моделью и представлением. Это упрощает взаимодействие между компонентами и инкапсулирует обновления данных, что делает разработку более интуитивной.3. Модули Angular использует систему модулей, что позволяет организовать код в независимые и логически связанные группы. Каждый модуль может содержать компоненты, директивы, сервисы и другие модули, что способствует модульному подходу и лучшей управляемости кода.4. Инъекция зависимостей (Dependency Injection) Angular предоставляет встроенную поддержку инъекции зависимостей, что упрощает управление зависимостями между классами и улучшает тестируемость приложения. Это позволяет легче управлять жизненным циклом объектов и их взаимодействием.  5. Маршрутизация Angular включает встроенный модуль маршрутизации, который позволяет организовать навигацию между различными представлениями или страницами приложения. Это делает приложения более удобными для пользователей и улучшает организацию кода.6. Реактивные формы Angular позволяет работать с формами через реактивные формы или шаблонные формы, что обеспечивает  мощные инструменты для валидации и отслеживания состояния. Реактивные формы позволяют динамически управлять формами в приложении, облегчая их настройку и валидацию. 7. RxJS и реактивное программирование Angular активно использует библиотеку RxJS, которая предоставляет инструменты для работы с асинхронными данными и потоками событий. Это дает разработчикам возможность эффективно управлять потоками данных и событий с использованием Observable.8. Генерация и сборка с помощью CLI Angular CLI (Command Line Interface) позволяет быстро создавать и управлять Angular приложениями. Он предлагает команды для создания новых компонентов, сервисов, модулей и т.д., а также автоматизирует процесс сборки, тестирования и развертывания.9. Тестируемость Angular разработан с учетом тестируемости. Он поддерживает юнит-тестирование компонентов и сервисов с помощью таких инструментов, как Jasmine и Karma. Это позволяет легко писать и запускать тесты, что способствует повышению качества кода.  10. Поддержка Progressive Web Apps (PWA) Angular обеспечивает поддержку создания прогрессивных веб-приложений, которые могут работать как нативные приложения на мобильных устройствах. PWA имеют повышенную скорость загрузки,работоспособность в оффлайн-режиме и возможность установки на домашний экран.11. Поддержка SEO Angular предоставляет механизмы для улучшения поисковой оптимизации (SEO) приложений, включая серверный  рендеринг с использованием Angular Universal. Это помогает приложениям эффективно индексироваться поисковыми системами.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "3b48",
      "title": "Что такое NgModule?",
      "response": "NgModule — это основной строительный блок приложения в Angular, который используется для организации и структурирования кода. Он позволяет группировать связанные компоненты, директивы, пайпы и сервисы в единое целое. Основная цель NgModule — определить область видимости и зависимости для различных частей вашего приложения. Вот основные аспекты NgModule:Основные характеристики NgModule:1. Определение модуля:Каждый Angular-модуль определяется с помощью декоратора @NgModule, который принимает объект конфигурации.Этот объект содержит метаданные, описывающие модуль.2. Импортируемые и экспортируемые модули:- Imports: Позволяет модулю импортировать другие модули, что делает доступными их компоненты, директивы и пайпы. Это позволяет разделять функциональность на разные модули и повторно использовать код.- Exports: Позволяет экспортировать компоненты, директивы и пайпы, чтобы они были доступны в других модулях, которые импортируют текущий модуль.3. Область видимости:Модули определяют область видимости для компонентов и сервисов. Компоненты, указанные в разделе  declarations, могут быть использованы только внутри этого модуля, если не экспортированы.4. Декларации:В разделе declarations указываются компоненты, директивы и пайпы, которые принадлежат этому модулю.5. Сервис и DI:Модули могут предоставлять сервисы через секцию providers. Angular автоматически создает экземпляр сервиса  и обеспечивает его инъекцию в компоненты, пользовательские директивы и другие сервисы.6. Основной модуль:Каждое Angular-приложение имеет как минимум один корневой модуль, обычно называемый AppModule, который инициализирует приложение.NgModule играет жизненно важную роль в организации Angular-приложений. Он обеспечивает модульность, упрощая управление зависимостями, структурирование кода и повторное использование компонентов. Правильное использование NgModule помогает создавать масштабируемые и поддерживаемые приложения.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "eb3b",
      "title": "Data binding (привязка к данным)",
      "response": "В шаблоне Angular привязка создает живую связь между частью пользовательского интерфейса, созданной из шаблона (элемент DOM, директива или компонент), и моделью (экземпляр компонента,к которому принадлежит шаблон). Эту связь можно использовать для синхронизации представления с моделью, для уведомления модели о том, что в представлении происходит событие или действие пользователя, или для того и другого. Алгоритм обнаружения изменений Angular отвечает за поддержание синхронизации представления и модели.Примеры связывания включают в себя:интерполяции текста {{value}},свойство связывание [value] привязка событий (click) двусторонняя привязка [{ngModel}] Привязки всегда состоят из двух частей: цели , которая будет получать связанное значение, и шаблонного выражения , которое создает значение из модели.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "7fae",
      "title": "Что такое @Pipe",
      "response": "функция которая преобразует разметку через | если есть доп свойства то через : есть pure и impure pipe - у него есть метод трансформ Pipe (или \"трубка\") в Angular — это специальный механизм, который позволяет преобразовывать данные в шаблонах приложения. Pipes используются для обработки и изменения данных перед их отображением пользователю. Они могут применяться для форматирования текста, преобразования дат, чисел, массивов и многого другого.Основные характеристики Pipe:1. Простота использования:- Pipes можно легко использовать в шаблонах Angular. Для этого достаточно указать название pipe и передать ему необходимые параметры в интерполяции или директиве. 2. Чистые и не чистые Pipes:- Пайпы могут быть чистыми и не чистыми. Чистые Pipes возвращают один и тот же результат при одинаковых входных данных, а не чистые могут выдавать разные результаты с одинаковыми входными данными (например,если они зависят от динамических данных, таких как текущее время).3. Встроенные Pipes:- Angular предоставляет несколько встроенных pipes, например:- DatePipe: преобразует дату в заданный формат.- CurrencyPipe: форматирует число в валюту.- DecimalPipe: форматирует число в десятичный формат.- JsonPipe: преобразует объект в JSON-строку для отладки.Пользовательские Pipes:- Вы можете создавать свои собственные pipes, чтобы реализовать специфическую логику преобразования  данных. Для этого необходимо использовать декоратор @Pipe и реализовать метод transform(value: any, ...args: any[]): any.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "7140",
      "title": "Хуки жизненного цикла",
      "response": "1.OnChanges - вызывается каждый раз, при установлении свойства 2.OnInit - один раз при инициализации компонента 3.DoCheck - при каждом проверки  изменении свойств 4.AfterContentInit - после проецирования контента в компоненте, вставка в html 5.AfterContentChecket - после проверки изменения проецируемого контент в шаблон 6.AfterViewInit - после инициализации представления родительского или дочернего компонента 7.AfterViewChecket - после проверки представления родительского или дочернего  компонента 8.OnDestroy - один раз после уничтожения компонента",
      "level": "Junior",
      "active": false
    },
    {
      "id": "0ea7",
      "title": "Модуль и его свойства",
      "response": "6.Модуль - класс с декоратором @ngModule - обьединяющая структура  для компонент, сервисов, пайпов, директив свойства - 1.Импорт - массив модулей нужных для нашего 2.Экспорт - массив компонент, пайпов, директив для экспорта 3.declaration - массив компонент, пайп, директив 4.providers - сервисы",
      "level": "Junior",
      "active": false
    },
    {
      "id": "95e7",
      "title": "Lazy loading",
      "response": "Асинхронная маршрутизация, позволяет не сразу создавать модуль, а когда пользователь переходит по определённому роутингу",
      "level": "Junior",
      "active": false
    },
    {
      "id": "768c",
      "title": "Что такое интерсепторы (interceptors) в Angular?",
      "response": "Интерсепторы (interceptors) в Angular являются частью модуля HttpClient и предоставляют мощный механизм для перехвата и обработки HTTP-запросов и ответов. Они позволяют разработчикам добавлять функциональность для каждого запроса и ответа на глобальном уровне, не изменяя сами компоненты или сервисы. Это может быть полезно для обработки заголовков, управления ошибками, добавления токенов аутентификации, логирования, кеширования и других задач.Интерсепторы являются классами, которые реализуют интерфейс HttpInterceptor. Для их создания необходимо выполнить следующие шаги:1. Создание класса интерсептора. Он должен реализовать метод intercept, который принимает два параметра: объект HttpRequest и объект HttpHandler. Этот метод должен возвращать объект Observable, который представляет ответ от сервера.2. Регистрация интерсептора. Интерсептор необходимо зарегистрировать в корневом модуле приложения или в соответствующем модуле, добавив его в массив providers.Применение интерсепторов:Интерсепторы могут использоваться для различных задач:1. Добавление токенов авторизации. Например, вы можете добавлять JWT-токены в заголовки каждого  защищенного запроса.2. Обработка ошибок. Интерсептор может обрабатывать ошибки от сервера и предоставлять единый подход к этому, вместо необходимости делать это в каждом сервисе или компоненте.3. Логирование. Вы можете записывать все исходящие запросы и входящие ответы для отладки или аудита.4. Модификация запросов и ответов. Интерсепторы могут изменять или фильтровать данные запроса и ответа перед их отправкой или после получения.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "befa",
      "title": "Взаимодействие с формами",
      "response": "В Angular взаимодействие с формами осуществляется с помощью двух основных подходов: реактивные формы и шаблонные формы.Оба подхода позволяют обрабатывать пользовательский ввод и валидировать данные, но используют разные механизмы и подходы.1. Шаблонные формы (Template-driven Forms)Шаблонные формы ориентированы на использование декларативного подхода и позволяют управлять формами через HTML-шаблоны.Для работы с ними нужно импортировать модуль FormsModule.2. Реактивные формы (Reactive Forms) Реактивные формы ориентированы на использование императивного подхода, предоставляя большую гибкость и контроль над формами.Для работы с реактивными формами нужно импортировать модуль ReactiveFormsModule.Оба подхода поддерживают валидацию форм. В шаблонных формах валидация осуществляется через атрибуты (например, required),а в реактивных формах — через встроенные валидаторы или пользовательские валидаторы.Шаблонные формы проще и быстрее в реализации, в то время как реактивные формы предоставляют  больше контроля и гибкости, особенно для сложных сценариев.",
      "level": "Middle",
      "active": false
    }
  ],
  "algorithms": [
    {
      "id": "41d7"
    },
    {
      "id": "b117",
      "title": "Что такое алгоритмы?",
      "response": "Алгоритмы в программировании представляют собой последовательность четко определенных шагов или правил, которые используются для решения определенной задачи или выполнения определенной операции. Алгоритм можно рассматривать как набор инструкций, который переводит входные данные в выходные результаты. Алгоритмы широко применяются в программировании для выполнения различных задач, таких как сортировка данных, поиск информации, обработка изображений и многое другое.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "42c0",
      "title": "Сортировка массива пузырьком",
      "response": " Сортировка пузырьком (Bubble Sort) — один из самых простых алгоритмов сортировки. Он работает путем многократного прохода по массиву, сравнения соседних элементов и их обмена местами, если они находятся в неправильном порядке. Процесс продолжается до тех пор, пока не будет выполнен проход без обменов, что означает, что массив отсортирован. Принцип работы алгоритма:1. Начните с первого элемента массива.2. Сравните текущий элемент с следующим.3. Если текущий элемент больше следующего, обменяйте их.4. Перейдите к следующему элементу и повторите шаги 2-3 до конца массива.5. После завершения одного полного прохода, повторяйте процесс для всего массива, пока не будет выполнен проход без обменов.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "3607",
      "title": "Поиск числа в массиве",
      "response": "Поиск числа в массиве может быть выполнен различными алгоритмами в зависимости от того, отсортирован массив или нет.1. Линейный поиск (Linear Search) Линейный поиск — это самый простой алгоритм, который исследует каждый элемент массива по порядку. Он проверяет каждое значение, пока не найдет нужное число или не достигнет конца массива.2. Бинарный поиск (Binary Search) Бинарный поиск — это более эффективный алгоритм, который применяется только для отсортированных массивов. Он работает, разбивая массив пополам и проверяя, находится ли искомый элемент в левой или правой половине. Сравнение алгоритмов \n- Линейный поиск:\n- Сложность времени: O(n) в худшем случае.\n- Прост в реализации и применим для неотсортированных массивов.- Бинарный поиск:- Сложность времени: O(log n) в худшем случае.- Эффективен только для отсортированных массивов и требует меньшего числа сравнений.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "bfc8",
      "title": "Поиск в глубину",
      "response": "Поиск в глубину (Depth-First Search, DFS) — это алгоритм для обхода или поиска в структуре данных ,такой как граф или дерево. Основная идея алгоритма состоит в том, чтобы начинать с корневой вершины (или произвольной начальной вершины для графов) и как можно глубже исследовать каждую ветвь, прежде чем отступить. DFS может быть реализован как с помощью рекурсии, так и с помощью стека. Принцип работы алгоритма DFS:1. Начинайте с корневой вершины и помечайте её как посещённую.2. Исследуйте все непосещённые соседние вершины, переходя в одну из них и повторяя шаг 1. 3. Если не осталось непосещённых соседей, вернитесь (отступите) к предыдущей вершине и повторите процесс для других непосещённых соседей.4. Повторяйте процесс, пока все вершины не будут посещены или пока не будет найдено нужное значение (если поиск).Характеристики DFS:- Сложность времени: O(V + E), где V — количество вершин, а E — количество рёбер в графе.- Сложность по памяти: O(V), т.к. необходимо хранить стеки или рекурсивные вызовы.- DFS может использоваться для решения задач вроде нахождения компонента связности, проверки простой связности графа,поиска циклов, топологической сортировки и других.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "7157",
      "title": "Обход дерева",
      "response": "Обходы дерева — это методы, с помощью которых можно пройти по всем узлам дерева в определённом порядке. Существуют три основных типа обхода для бинарных деревьев:1. Прямой обход (Pre-order traversal) В этом методе сначала обрабатывается (или посещается) текущий узел, затем левые дочерние узлы, и в конце правые дочерние узлы. Этот способ полезен, например, для создания копии дерева или преобразования дерева в префиксную запись.2. Центрированный обход (In-order traversal) При центреходе сначала обрабатываются левые дочерние узлы, затем текущий узел,и в конце правые дочерние узлы. Этот метод используется в бинарных деревьях поиска,поскольку при его выполнении узлы будут посещаться в отсортированном порядке.3. Обратный обход (Post-order traversal) В этом методе сначала обрабатываются левые и правые дочерние узлы, и только после этого текущий узел. Этот метод часто используется, когда необходимо выполнить действия, зависящие от дочерних узлов, например, при удалении дерева или вычислении значения в нём. Прямой обход подходит для случаев, когда нужно работать с родительским узлом первым, центрированный обход — для работы с отсортированными данными, а обратный обход — для обработки дочерних узлов перед родительскими.",
      "level": "Senior",
      "active": false
    },
    {
      "id": "7355",
      "title": "Алгоритм рекурсивного спуска",
      "response": "Алгоритм рекурсивного спуска — это метод, который применяется для решения различных задач, включая анализ и обработку выражений, синтаксический анализ и компиляцию языков программирования. Он используется для реализации рекурсивных грамматик. Рекурсивный спуск реализует синтаксический анализ программы, разбивая её на подзадачи с помощью рекурсии. Основные идеи алгоритма 1. Рекурсивные функции: Каждый элемент грамматики или конструкции языка реализуется через функцию. Если конструкция может быть рекурсивной, функция вызывает саму себя. 2. Грамматика: Рекурсивный спуск легче всего реализуется для грамматик, которые не содержат левой рекурсии. Это означает, что рекурсивные правила не должны вызывать самих себя в левой части.3. Состояние: В процессе анализа алгоритм работает с состоянием, которое включает в себя текущий токен, индекс в исходном потоке и, возможно, дополнительные параметры для хранения промежуточных  результатов.Преимущества:- Простота реализации и понимания.- Хорошо подходит для задач синтаксического анализа.Недостатки: - Неэффективен для грамматик с левой рекурсией.- Может привести к переполнению стека при глубокой рекурсии.",
      "level": "Senior",
      "active": false
    }
  ],
  "linux": [
    {
      "id": "22a9"
    }
  ],
  "categories": [
    {
      "id": "0",
      "name": "Структуры данных",
      "endpoint": "/data-struct"
    },
    {
      "id": "1",
      "name": "JavaScript",
      "endpoint": "/javascript"
    },
    {
      "id": "2",
      "name": "Обьектно-ориентированное программирование",
      "endpoint": "/oop"
    },
    {
      "id": "3",
      "name": "Тестирование",
      "endpoint": "/testing"
    },
    {
      "id": "4",
      "name": "Angular",
      "endpoint": "/angular"
    },
    {
      "id": "5",
      "name": "TypeScript",
      "endpoint": "/typescript"
    },
    {
      "id": "6",
      "name": "Паттерны проектирования",
      "endpoint": "/patterns"
    },
    {
      "id": "7",
      "name": "Сетевые протоколы",
      "endpoint": "/net-protocols"
    },
    {
      "id": "8",
      "name": "Алгоритмы",
      "endpoint": "/algorithms"
    },
    {
      "id": "9",
      "name": "Linux",
      "endpoint": "/linux"
    },
    {
      "id": "10",
      "name": "rxjs",
      "endpoint": "/rxjs"
    },
    {
      "id": "11",
      "name": "Git",
      "endpoint": "/git"
    },
    {
      "id": "12",
      "name": "CSS",
      "endpoint": "/css"
    }
  ],
  "javascript": [
    {
      "id": "86a3",
      "title": "222",
      "response": "222",
      "level": "Junior",
      "active": false
    },
    {
      "id": "51a9",
      "title": "cxvdsf",
      "response": "asdfqw",
      "level": "Junior",
      "active": false
    },
    {
      "id": "9ed8",
      "title": "qwezx",
      "response": "zxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcvzxcv",
      "level": "Junior",
      "active": true
    },
    {
      "id": "3115",
      "title": "asd",
      "response": "zvxzxc",
      "level": "Junior",
      "active": false
    },
    {
      "id": "b4b0",
      "title": "afed",
      "response": "zv",
      "level": "Junior",
      "active": false
    },
    {
      "id": "afeb",
      "title": "фыва",
      "response": "ясм",
      "level": "Junior",
      "active": false
    },
    {
      "id": "c821",
      "title": "123ыфва",
      "response": "мя",
      "level": "Junior",
      "active": false
    },
    {
      "id": "512d",
      "title": "qwewqe",
      "response": "zxcxzcxz",
      "level": "Junior",
      "active": false
    },
    {
      "id": "cf66",
      "title": "vccv",
      "response": "qwe",
      "level": "Junior",
      "active": false
    },
    {
      "id": "76f7",
      "title": "йуццйу",
      "response": "фывфыввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввв",
      "level": "Junior",
      "active": false
    }
  ],
  "css": [
    {
      "id": "500f",
      "title": "adqwd",
      "response": "ddddddddd",
      "level": "Junior",
      "active": false
    }
  ],
  "git": [
    {
      "id": "968a",
      "title": "Основные понятия Git",
      "response": "1. Репозиторий (repository): Это основное хранилище для вашего проекта, где хранится вся история изменений.2. Коммит (commit): Это сохранение изменений в репозитории. Каждый коммит содержит сообщение о том, что было изменено.3. Ветка (branch): Это параллельная линия разработки, позволяющая работать над новыми функциями или исправлениями без влияния на основную ветку.4. Слияние (merge): Это процесс объединения изменений из одной ветки в другую.5. Конфликты (conflicts): Возникают, когда изменения в двух ветках конфликтуют, и Git не может автоматически объединить их.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "13aa",
      "title": "Основные команды Git",
      "response": "1. git init: Инициализация нового репозитория.2. git clone [url]: Клонирование существующего репозитория.3. git add [file]: Добавление файлов к индексации (подготовка к коммиту).4. git commit -m \"message\": Сохранение изменений с сообщением.5. git status: Проверка статуса файлов в репозитории.6. git log: Просмотр истории коммитов.7. git branch: Просмотр существующих веток.8. git checkout [branch]: Переключение на другую ветку.9. git merge [branch]: Слияние указанной ветки с текущей.10. git pull: Получение последних изменений из удалённого репозитория и автоматическое слияние.11. git push: Отправка коммитов на удалённый репозиторий.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "ab6a",
      "title": "Git hookss",
      "response": "Git hooks — это специальные скрипты, которые выполняются автоматически при выполнении определённых действий с репозиторием Git. Они позволяют настраивать процессы автоматизации и улучшать рабочий процесс разработки. Git поддерживает хуки для различных событий, таких как коммиты, слияния, и отправка данных в удалённый репозиторий. Эти хуки написаны в языке сценариев,таком как Bash, и могут быть настроены в зависимости от ваших нужд.Основные виды хуков 1. pre-commit: Выполняется перед созданием коммита. Используется для проверки кода на ошибки,форматирования, запуска тестов и т.д. Если скрипт завершится с ненулевым кодом, коммит не будет выполнен.2. prepare-commit-msg: Запускается перед открытием редактора для ввода сообщения коммита.Используется для изменения или дополнения стандартного сообщения о коммите.3. commit-msg: Выполняется после того, как сообщение коммита было введено, но перед его сохранением. Полезно для проверки формата сообщения коммита.4. post-commit: Выполняется после завершения коммита. Может использоваться для уведомлений,запуска сборки или других задач, которые должны выполняться после коммита.5. pre-push: Выполняется перед отправкой данных в удалённый репозиторий. Этот хук может использоваться для проверки, что все тесты проходят, прежде чем выполнить git push.6. post-merge: Выполняется после успешного слияния веток. Может использоваться для выполнения дополнительных действий, таких как установка зависимостей или очистка.7. pre-receive, update, post-receive: Эти хуки выполняются на стороне сервера при получении изменений от клиента. Используются для проверки входящих изменений, обеспечения соблюдения политик разработки и т.д.\nКак настроить хуки 1. Путь к хукам: Хуки располагаются в директории вашего Git-репозитория по пути .git/hooks/.По умолчанию в этой директории находятся примеры хуков с расширением .sample, которые можно использовать как шаблоны.2. Создание хука: Чтобы создать хук, просто переименуйте файл, удалив расширение .sample и добавьте ваш код. Например, для создания хуку pre-commit создайте файл с именем pre-commit в директории .git/hooks/.3.После создания хуков не забудьте сделать файл исполняемым, выполнив команду +x .git/hooks/pre-commit Примеры применения хуков - Автоматическое форматирование кода с использованием линтеров. - Запуск тестов перед коммитом или отправкой изменений. - Обработка и проверка сообщений коммита на соответствие стандартам.- Уведомление разработчиков через электронную почту о завершении коммитов или слияний.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "cdc8",
      "title": " Рабочие пространства (Worktrees)",
      "response": "Рабочие пространства (Worktrees) в Git \nпозволяют вам создавать несколько рабочих каталогов для одного\n     репозитория, что позволяет одновременно работать над несколькими ветками         без необходимости переключения между ними. Это особенно полезно для разработчиков, \n        которые хотят разрабатывать или тестировать разные изменения в отдельных ветках одновременно.\n        Основные преимущества Worktrees\n        1. Одновременная работа с несколькими ветками: Вы можете иметь активные копии различных веток в разных каталогах, что позволяет вам работать над несколькими задачами одновременно.2. Изолированное окружение: Каждое рабочее пространство является количеством независимым,что помогает избежать конфликтов и путаницы между изменениями и состояниями веток.\n       3. Упрощение тестирования и деплоя: Рабочие пространства позволяют легко протестировать изменения в одной ветке, не затрагивая другие ветки и не переключаясь между ними.\n        Основные команды для работы с Worktrees 1. Создание нового рабочего пространства:Чтобы создать новое рабочее пространство на основе существующей ветки, используйте команду:git worktree add (путь_к_новому_рабочему_каталогу) (ветка) Эта команда создаст новое рабочее пространство в каталоге ../new-feature-branch на основе ветки feature-branch.2. Просмотр существующих рабочих пространств:Для просмотра всех рабочих пространств в вашем репозитории выполните команду:git worktree list 3. Удаление рабочего пространства:Если вам больше не нужно рабочее пространство, вы можете удалить его с помощью команды:git worktree remove (путь_к_рабочему_каталогу) Обратите внимание, что для успешного удаления рабочего пространства необходимо, чтобы оно было пустым (т.е. в нём не должно быть несохранённых изменений).4. Переключение между рабочими пространствами:После создания рабочего пространства вы можете просто перейти в его каталог и работать, как если бы вы находились в обычном репозитории.Примеры применения Worktrees - Работа над несколькими функциональностями: Если у вас есть несколько функциональностей, которые вы хотите разработать одновременно, вы можете создать отдельные рабочие пространства для каждой из них.- Проверка состояния ветки: Вы можете тестировать изменения в одной ветке, не боясь привести в замешательство незафиксированные изменения в текущей ветке.- Облегчение командной работы: Когда несколько разработчиков работают над проектом, каждый из них может создать своё рабочее пространство для своей задачи, что облегчает совместную работу.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "e3ac",
      "title": "Отмена изменений",
      "response": "Git предоставляет несколько способов отмены изменений:git checkout, git revert и git reset. Это позволяет разработчикам гибко обрабатывать различные ошибки или откатывать изменения.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "95e7",
      "title": "daswqeerfqwer",
      "response": "asd",
      "level": "Junior",
      "active": false
    },
    {
      "id": "3c28",
      "title": "фы",
      "response": "асмясчм",
      "level": "Junior",
      "active": false
    },
    {
      "id": "a77e",
      "title": " asd",
      "response": " d",
      "level": "Junior",
      "active": false
    },
    {
      "id": "aeff",
      "title": "фыв",
      "response": "вввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввв",
      "level": "Junior",
      "active": false
    },
    {
      "id": "0b5c",
      "title": "asdasd",
      "response": "ddddddasdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd",
      "level": "Junior",
      "active": true
    },
    {
      "id": "7685",
      "title": "йцуйцу",
      "response": "фыцввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввв",
      "level": "Junior",
      "active": false
    },
    {
      "id": "d250",
      "title": "цйуцу",
      "response": "вввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввв\n",
      "level": "Junior",
      "active": false
    },
    {
      "id": "a75e",
      "title": "edsadasdasd",
      "response": "edsadasdasd dsdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasd\n",
      "level": "Junior",
      "active": false
    }
  ]
}