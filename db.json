{
  "profile": [
    {
      "id": "921s",
      "userId": "0eed",
      "name": "Matrix",
      "role": "admin",
      "image": "avatar.png"
    }
  ],
  "users": [
    {
      "id": "83d5",
      "login": "Machina",
      "password": "PasswordModer1",
      "secretWord": "smoke",
      "admin": false,
      "moderator": false
    },
    {
      "id": "93a7",
      "login": "Matrix",
      "password": "",
      "secretWord": "black",
      "admin": true,
      "moderator": false
    },
    {
      "id": "488b",
      "login": "Jopashnik",
      "password": "alaBama1",
      "secretWord": "hui",
      "admin": false,
      "moderator": false,
      "image": ""
    }
  ],
  "current-user": [
    {
      "id": "0eed",
      "login": "Matrix",
      "password": "",
      "admin": true,
      "moderator": false,
      "image": ""
    }
  ],
  "data-struct": [],
  "oop": [],
  "testing": [
    {
      "id": "6d2e",
      "title": "rwadsasd",
      "response": "zxcsadad",
      "level": "Junior",
      "active": false
    }
  ],
  "rxjs": [
    {
      "id": "e3b4"
    }
  ],
  "typescript": [
    {
      "id": "4162"
    }
  ],
  "patterns": [
    {
      "id": "f3f7"
    }
  ],
  "net-protocols": [
    {
      "id": "3d4d"
    }
  ],
  "angular": [
    {
      "id": "82a5",
      "title": "Что такое Angular?",
      "response": "Angular – это фреймворк для создания клиентских веб-приложений, разработанный компанией Google. Он позволяет создавать динамические веб-приложения, обеспечивая высокую производительность и гибкость кода.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "52fa",
      "title": "Как на Angular2 и Angular8 при получении данных с бэка парсить их в модель?",
      "response": "На Angular (как версии 2, так и 8) процесс получения данных с бэкенда и их парсинга в модель можно описать следующими этапами:1. Определение модели данных Перед тем, как получать данные, необходимо определить, как они будут представляться в приложении. Это включает в себя создание модели, которая описывает структуру данных, получаемых от бэкенда. Например, если вы работаете с пользователями, вам нужно решить, какие свойства будут у пользователя (например, имя, email, возраст и т.д.). 2. Создание сервиса Создайте сервис, который будет отвечать за взаимодействие с API бэкенда. Этот сервис будет отправлять HTTP-запросы к серверу для получения данных. Важно, чтобы сервисы в Angular отвечали за логику работы с данными, отделяя эту логику от компонентов, которые отображают данные.3. Запрос к API Сервис использует методы для отправки запросов к API для получения данных. В ответ на запрос бэкэнд возвращает данные, обычно в формате JSON. После получения этих данных сервис должен обработать их, чтобы они соответствовали модели.4. Парсинг данных На этом этапе происходит преобразование данных, полученных с бэкенда, в объекты вашей модели. Это включает в себя сопоставление свойств, которые пришли от сервера, с полями вашей модели. Если структура данных соответствует ожидаемым полям модели, то можно создать экземпляры модели с полученными значениями.\n5. Использование данных в компоненте После того, как данные были успешно преобразованы в объекты модели, их можно использовать в компонентах Angular. Компоненты могут подписываться на сервисы, чтобы получать данные, и обновлять свое состояние, чтобы отобразить эти данные на экране. Это значит, что компоненты могут легко обновлять представление в зависимости от данных, получаемых из сервиса.6. Обработка ошибок Всегда полезно обрабатывать возможные ошибки, которые могут возникнуть при запросах к бэкенду. Это может быть сделано путем проверки ответов от сервера и добавления соответствующей обработки ошибок. Заключение: В итоге, процесс парсинга данных из бэкенда в Angular включает в себя определение модели данных, создание сервиса для работы с API, выполнение запросов, их обработку и преобразование в объекты модели, а затем использование этих данных в компонентах приложения. Такой подход позволяет поддерживать чистую архитектуру и легкость управления данными в приложении.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "7541",
      "title": "Расскажи про guardы?",
      "response": "Гарды (guards) в Angular — это механизм, который позволяет контролировать доступ к определённым маршрутам (pages) в вашем приложении. Они действуют как защитные слои, проверяя, имеет ли пользователь право переходить на определённые страницы или выполнять определённые действия. Гарды помогают реализовать маршрутизацию с учетом авторизации, аутентификации и других условий. Основные виды гардов в Angular: 1. CanActivate: - Проверяет, может ли пользователь перейти на определённый маршрут. Если метод возвращает true, переход разрешён; если false, переход отменяется.- Используется для проверки, прошел ли пользователь аутентификацию или имеет ли права доступа к определённому маршруту.2. CanActivateChild:Работает аналогично CanActivate, но применяется к дочерним маршрутам. Это позволяет контролировать доступ ко всем дочерним маршрутам конкретного родительского маршрута.3. CanDeactivate:- Переход контролируется, когда пользователь пытается покинуть текущий маршрут. Например, это может быть полезно, если у вас есть форма, и вы хотите предупредить пользователя о том, что он потеряет несохраненные данные.4. Resolve:- Используется для получения данных перед активацией маршрута. Это позволяет загружать данные заранее и передавать их в компонент, что полезно для случаев, когда вы хотите отображать данные, прежде чем пользователь увидит страницу.5. CanLoad:- Проверяет, имеет ли пользователь доступ к загрузке определённого модуля. Это используется для ленивой загрузки маршрутов, что позволяет загружать модули только при необходимости. Это помогает улучшить производительность приложения, предотвращая загрузку ненужных модулей.Как работают гарды:Гарды реализуются в виде сервисов. Чтобы создать гард, вы можете использовать Angular CLI, который автоматически создаст необходимый сервис. Каждый гард должен реализовывать интерфейс, соответствующий его типу (например, CanActivate), и реализовывать метод, который будет возвращать true или false, либо Observable boolean> или Promise boolean>.Пример использования гарда:1. Создание гарда: Вы создаете гард, который проверяет, старше ли пользователь определенного возраста.2. Имплементация логики: В методе проверяете возраст пользователя и возвращаете true или false.3. Настройка маршрутов: В маршрутах указываете, какой гард применить к конкретному маршруту, тем самым обеспечивая контроль доступа.Преимущества использования гардов:- Позволяют улучшить безопасность вашего приложения, предотвращая несанкционирован- Обеспечивают лучшую управляемость переходов между маршрутами, особенно в сложных приложениях с множеством условий доступа.- Помогают загружать необходимые данные перед тем, как пользователь увидит страницу, что улучшает пользовательский опыт.В целом, гарды в Angular являются мощным инструментом для управления доступом к маршрутам и организации логики переходов в приложении.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "6f7e",
      "title": "Использовали ли сторонние библиотеки для форм? Angular Material?",
      "response": "Да, в Angular часто используются сторонние библиотеки для работы с формами, и одной из наиболее популярных таких библиотек является Angular Material. Вот несколько аспектов, касающихся использования Angular Material и других библиотек для работы с формами:Angular Material 1. UI-компоненты: Angular Material предоставляет набор предопределённых пользовательских интерфейсных компонентов, которые соответствуют Material Design. Это включает в себя различные элементы форм, такие как текстовые поля, селекты, чекбоксы, радиокнопки и другие.3. Валидация: Angular Material делает процесс валидации форм более удобным. Компоненты формы интегрированы с механизмом валидации Angular, что позволяет легко отображать сообщения об ошибках и советы пользователям.4. Интерактивность: Angular Material поддерживает различные интерактивные возможности, такие как автозаполнение, выпадающие списки и адаптивное поведение в зависимости от размера экрана. Это улучшает взаимодействие пользователей с формами.Другие сторонние библиотеки 1. Ngx-formly: Это библиотека для создания динамических форм в Angular. Она позволяет определять формы с использованием JSON и автоматически генерировать пользовательский интерфейс на основе этого определения. Это особенно полезно для приложений с изменяемыми требованиями к формам.2. Reactive Forms: Хотя это не совсем сторонняя библиотека, это важный подход в Angular. Reactive Forms предоставляет более мощные инструменты для управления состоянием форм и их валидацией по сравнению с Template-driven Forms. Reactive Forms позволяют легче отслеживать изменения формы и управлять их состоянием.3. ngx-bootstrap и PrimeNG: Эти библиотеки также предлагают компоненты для работы с формами, в том числе таблицы, модальные окна и различные элементы управления. Они могут быть использованы в сочетании с Angular Material или другим стилем приложения в зависимости от требований проекта.Заключение:Использование сторонних библиотек, таких как Angular Material, значительно упрощает разработку форм в Angular-приложениях. Они не только предоставляют готовые компоненты, но и обеспечивают удобное взаимодействие с пользователями, улучшая общее восприятие приложения. Выбор библиотеки зависит от конкретных потребностей вашего проекта, предпочтений по стилю и дизайну, а также уровня требуемой функциональности.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "ca5b",
      "title": "Пользуетесь типизацией в typescript или используете как дефолтный инструмент для Angular?",
      "response": "Типизация в TypeScript является одной из его ключевых особенностей, и в большинстве случаев использование типизации рассматривается как важная практическая практика при разработке приложений на Angular. Вот несколько причин, почему типизация считается полезной и важной в контексте Angular:1. Улучшенная безопасность типов - Использование типизации позволяет обнаруживать ошибки на этапе компиляции вместо выполнения, что снижает вероятность возникновения ошибок во время выполнения приложения.- Это особенно полезно в крупных приложениях, где сложно отслеживать типы данных, передаваемых между компонентами, сервисами и другими частями приложения.2. Лучшее автозавершение и поддержка IDE - Типы помогают интегрированным средам разработки (IDE) предоставлять более точные подсказки, автозавершение и документацию для методов и свойств.- Это упрощает разработку, поскольку разработчики могут легче понимать структуры данных и интерфейсы, используемые в приложении.3. Чёткое определение интерфейсов и моделей - В TypeScript можно использовать интерфейсы и классы для явного определения структуры объектов и моделей данных, что делает код более понятным и поддерживаемым.- Это помогает обеспечить единообразие в использовании объектов в разных частях приложения.4. Поддержка и расширяемость - Типизация упрощает совместную работу в команде, поскольку другие разработчики могут легко понять, какие данные ожидаются, и какие структуры данных необходимы для использования.- Это делает код более удобным для тестирования и расширения, поскольку вы точно знаете, какие типы передаются в функции и компоненты.5. Использование сложных типов - TypeScript позволяет использовать сложные типы данных, такие как объединения (union types), пересечения (intersection types) и типы с помощью дженериков. Это помогает создавать более гибкие и обобщенные компоненты и сервисы.- Это особенно полезно для сложных бизнес-логик и компонентов, которые могут обрабатывать разнообразные данные. \nЗаключение:Таким образом, хотя TypeScript и является дефолтным инструментом для Angular, использование типизации в TypeScript не следует рассматривать как опцию, а как рекомендацию. Это не только улучшает надежность и читаемость кода, но и делает разработку более эффективной и управляемой, что критически важно в современных веб-приложениях.Поэтому большинство разработчиков на Angular активно используют типизацию TypeScript для повышения качества своего кода.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "8b08",
      "title": "Что такое change detection? В чём разница между default и push?",
      "response": "Change Detection (обнаружение изменений) в Angular — это механизм, который отслеживает изменения в данных и обновляет пользовательский интерфейс (UI) в соответствии с этими изменениями. Angular использует этот механизм для актуализации представления приложения, когда данные изменяются в модели. С помощью обнаружения изменений вы можете автоматически реагировать на изменения состояния приложения, обеспечивая синхронизацию между моделью и представлением.Как работает обнаружение изменений в Angular Angular обновляет представление компонентов при помощи так называемого механизма обнаружения изменений. Он основан на концепции \"потока\" данных и использует различные стратегии для определения изменений:1. Zone.js: Angular использует библиотеку Zone.js, чтобы отслеживать асинхронные операции, такие как события, таймеры и HTTP-запросы. Когда такие операции завершаются, Angular знает, что необходимо проверить, произошло ли изменение.2. Change Detection Strategy: У каждого компонента в Angular есть стратегия обнаружения изменений, которая определяет, как именно Angular будет отслеживать изменения в этом компоненте. Стратегии обнаружения изменений В Angular существуют две основные стратегии обнаружения изменений:1. Default Change Detection (Default strategy):- Это стандартная стратегия обнаружения изменений, используемая по умолчанию для всех компонентов.- Angular проверяет каждую часть дерева компонентов на изменения после каждой асинхронной операции (например, при событиях, таймерах и HTTP-запросах).- Это означает, что Angular будет периодически проверять все компоненты с целью указать, есть ли изменения в их переменных, и обновлять соответствующее представление при необходимости.- Эта стратегия проста в использовании и подходит для большинства приложений, но может привести к неэффективности в производительности, особенно в сложных приложениях с глубоким деревом компонентов.\n2. OnPush Change Detection (OnPush strategy):- Эта стратегия оптимизирует производительность компонента, проверяя только те компоненты, которые имеют изменения в своих входных параметрах (inputs), или те, которые вызывают события.- Angular не проверяет компонент, если не были выполнены изменения в его свойствах, и если он не реагирует на события в его пределах. Это означает, что если никаких изменений не произошло, компонент не будет проверяться на изменения, что снижает нагрузку на производительность.- Компоненты с OnPush должны использовать иммутабельные данные (immutable data) или производить изменения экземпляра для вызова обновлений. - OnPush может быть полезен в больших и сложных приложениях, где производительность имеет важное значение.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "19da",
      "title": "ngZone",
      "response": "NgZone — это сервис в Angular, который позволяет управлять контекстом выполнения асинхронного кода и обеспечивать обнаружение изменений. Он является частью механизма, который позволяет Angular отслеживать изменения в приложении и обновлять представление в соответствии с изменениями состояния. NgZone использует библиотеку Zone.js для работы с зонами, изолированными контекстами выполнения, которые позволяют отслеживать асинхронные операции.Основные функции NgZone:1. Обнаружение изменений:- NgZone позволяет Angular эффективно отслеживать изменения, происходящие в приложении, автоматически активируя обнаружение изменений после завершения асинхронных операций (таких как HTTP-запросы, таймеры и события). Это обеспечивает автоматическое обновление представления, когда данные меняются.2. Контроль над изменениями:- NgZone предоставляет методы для управления тем, когда Angular должен проверять изменения. Вы можете использовать его для временного выхода из зоны (например, при выполнении операций, которые не требуют изменений в UI), что может помочь улучшить производительность.3. Методы NgZone:- run(): Этот метод запускает функцию внутри контекста Angular, активируя обнаружение изменений. Это полезно, если вы хотите выполнить некоторые действия и убедиться, что изменения будут отслежены.- runOutsideAngular(): Этот метод позволяет выполнять функции вне контекста Angular. Это важно, если вы хотите избежать избыточного отслеживания изменений и улучшить производительность (например, при использовании сторонних библиотек для работы с событиями или анимациями).",
      "level": "Middle",
      "active": false
    },
    {
      "id": "68d8",
      "title": "Чем e2e-тесты отличаются от unit-тестов?",
      "response": "E2E-тесты (end-to-end тесты) и unit-тесты (модульные тесты) являются двумя различными уровнями тестирования программного обеспечения, и каждый из них имеет свои особенности, цели и области применения.Unit-тесты Определение:Unit-тесты предназначены для проверки отдельных \"единиц\" кода, таких как функции, методы или классы, в изоляции от остальной части системы.Основные характеристики:1. Изоляция: Каждый unit-тест проверяет только одну конкретную функциональность, отделённую от других частей приложения. Это достигается через использование моков (mocks), заглушек (stubs) или фейков (fakes).2. Скорость: Unit-тесты обычно выполняются быстро, так как они не требуют взаимодействия с внешними компонентами, такими как база данных или API.3. Инструменты: Для написания unit-тестов часто используются фреймворки, такие как Jasmine, Mocha, Jest и другие.4. Простота: Unit-тесты проще для реализации и отладки, так как они сосредоточены на маленьких кусках кода.5. Цели: Основная цель unit-тестов — выявление ошибок в логике отдельных модулей и обеспечение правильного функционирования этих модулей.E2E-тесты:Определение:E2E-тесты проверяют приложение в целом, имитируя поведение пользователя, чтобы убедиться, что все части системы работают вместе должным образом. Основные характеристики:1. Полное тестирование: E2E-тесты проверяют все слои приложения, включая фронтенд, бэкенд, базы данных и другие взаимодействия. Они проверяют, как различные модули и компоненты работают вместе.2. Сложность: E2E-тесты более сложные в написании и поддержке, поскольку требуют настройки тестовых данных и окружения.3. Скорость: E2E-тесты обычно медленнее, чем unit-тесты, из-за необходимости симуляции всей системы и взаимодействия с различными компонентами.4. Инструменты: Для E2E-тестирования часто используются инструменты, такие как Protractor, Cypress, Selenium и другие.5. Пользовательский опыт: E2E-тесты предназначены для проверки пользовательского опыта, начиная с загрузки страницы и заканчивая действиями пользователя, такими как нажатия кнопок и ввод данных.6. Цели: Основная цель E2E-тестов — удостовериться, что приложение работает как единое целое и что все его части правильно взаимодействуют друг с другом.Заключение:В целом, оба типа тестирования важны и дополняют друг друга в процессе разработки программного обеспечения. Unit-тесты обеспечивают проверку отдельных компонентов на грамматические ошибки и ошибки логики, тогда как E2E-тесты подтверждают , что приложение работает корректно при взаимодействии всех компонентов. Чаще всего в проектах комбинируют оба подхода, чтобы получить более полное покрытие и уверенность в качестве кода.",
      "level": "Senior",
      "active": false
    },
    {
      "id": "a203",
      "title": "Что такое pipe? Расскажите про async pipe?",
      "response": "В Angular pipe (пайп) — это специальный механизм, позволяющий трансформировать данные в шаблонах. Пайпы применяются для изменения форматирования, преобразования и фильтрации данных при их отображении в UI. Они представляют собой функции, которые могут быть использованы в выражениях Angular для изменения значений, прежде чем они будут отображены в HTML.Основные характеристики пайпов:\n1. Чистота: Пайпы могут быть чистыми или грязными. Чистые пайпы не изменяют входные данные и возвращают одно и то же значение для одного и того же входного значения. Грязные пайпы могут возвращать разные результаты при каждом вызове.2. Параметры: Пайпы могут принимать дополнительные параметры для настройки их поведения.3. Композиция: Пайпы могут быть вложены друг в друга, позволяя комбинировать их функции.Async Pipe Async Pipe — это специальный пайп в Angular, который упрощает работу с асинхронными данными, такими как результаты HTTP-запросов, промисы или потоки (Observables). Он позволяет автоматически подписываться на Observable или промис и обновлять представление, когда приходит новое значение.Основные функции Async Pipe: 1. Подписка и отписка: Async Pipe автоматически подписывается на Observable при загрузке компонента и отписывается при уничтожении компонента. Это помогает избежать утечек памяти и упрощает управление подписками.2. Актуализация данных: Async Pipe автоматически обновляет отображаемые данные в шаблоне, когда Observable эмитирует новое значение. Пайпы, в том числе Async Pipe, являются очень удобным инструментом для работы с данными в Angular. Они позволяют легко и эффективно форматировать и трансформировать данные непосредственно в шаблонах, а также упрощают работу с асинхронными данными, автоматизируя управление подписками и актуализацией данных в пользовательском интерфейсе.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "faee",
      "title": "Жизненный цикл компоненты",
      "response": "В Angular жизненный цикл компонента описывает последовательность событий и методов, через которые проходит компонент с момента его создания до уничтожения. Понимание жизненного цикла компонентов позволяет разработчикам лучше управлять состоянием и поведением компонентов, а также выполнять определенные действия на различных этапах их существования. Основные стадии жизненного цикла компонента и их хуки 1. Создание - ngOnChanges(): Вызывается при изменении входных свойств компонента. Этот хук получает объект SimpleChanges, который содержит информацию о предыдущих и текущих значениях входных свойств. Используется для реакции на изменения входных данных.2. Изменение - ngDoCheck(): Вызывается во время каждого цикла обнаружения изменений и позволяет разработчику реагировать на изменения, которые Angular не может отследить автоматически. 3. Отображение - ngAfterContentInit(): Вызывается после того, как контент (ng-content) был проинициализирован. Это позволяет выполнять действия, которые зависят от наличия содержимого в компоненте.- ngAfterContentChecked(): Вызывается после проверки содержания компонента. Здесь можно выполнять действия, зависимые от изменений в контенте.- ngAfterViewInit(): Вызывается после инициализации представления компонента и всех дочерних представлений. Здесь можно выполнять действия, которые требуют доступа к дочерним компонентам.- ngAfterViewChecked(): Вызывается после проверки представления и дочерних представлений. Этот метод можно использовать для выполнения дополнительных действий после каждой проверки.4. Уничтожение:- ngOnDestroy(): Вызывается перед уничтожением компонента. Здесь можно выполнять финальную уборку, освобождать ресурсы, такие как подписки на события или таймеры, для предотвращения утечек памяти.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "35d6",
      "title": "Почему change работает раньше onInit (чендж детекшн)",
      "response": "Почему изменение данных может вызвать обнаружение изменений до выполнения метода ngOnInit.1. Состояние данных перед ngOnInit():- Когда компонент инициализируется, его свойства могут быть уже установлены в определенные значения. Если эти свойства изменяются до вызова ngOnInit, Angular запускает обнаружение изменений, чтобы отражать эти изменения в интерфейсе.2. Процесс обнаружения изменений:- Angular использует механизм изменений, чтобы отслеживать изменения состояния в приложении. Этот механизм реагирует на изменения, происходящие в свойствах компонента.3. Очередность вызовов:- Как только Angular заметит изменения входных данных или состояния, он инициирует обнаружение изменений, что может привести к перерисовке компонента, даже если метод ngOnInit еще не был вызван. Однако, после этого Angular также вызовет ngOnInit() для выполнения дополнительной логики и инициализации.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "99ed",
      "title": "Viewchild от contentChild",
      "response": "В Angular @ViewChild и @ContentChild — это декораторы, которые используются для получения ссылок на компоненты, директивы или элементы DOM, но у них есть разные области применения и методы работы. Давайте рассмотрим каждую из этих аннотаций более подробно.@ViewChild Определение:@ViewChild позволяет получить доступ к дочерним компонентам, директивам или элементам шаблона, которые находятся в пределах самого компонента. Это означает, что @ViewChild используется для доступа к элементам, которые находятся в шаблоне текущего компонента.@ContentChild Определение:\n@ContentChild позволяет получить доступ к дочерним компонентам или элементам, которые были переданы в родительский компонент через ng-content>. Это означает, что @ContentChild используется для доступа к элементам, которые находятся вне шаблона текущего компонента, но были вставлены в него. Как использовать: Для использования @ContentChild необходимо вставить элемент в родительский компонент, проделав это с помощью ng-content. <br><app-parent><br>  <child-component></child-component><br></app-parent><br> Основные отличия 1. Положение элементов:- @ViewChild: Получает доступ к дочерним компонентам, директивам или элементам, которые находятся внутри текущего компонента. - @ContentChild: Получает доступ к элементам, которые были переданы в текущий компонент через ng-content.2. Событие инициализации:- @ViewChild: Необходимо использовать в методах жизненного цикла, таких как ngAfterViewInit, чтобы быть уверенным, что элемент инициализирован.- @ContentChild: Обычно используется в ngAfterContentInit, поскольку контент может быть вставлен после инициализации компонента.3. Контекст использования:- @ViewChild: Используется для взаимодействия с элементами/компонентами, которые являются частью самого компонента (например, элементы формы, дочерние компоненты).- @ContentChild: Используется для получения доступа к элементам, которые вставлены в компонент извне, например, элементы, переданные через контент.",
      "level": "Middle",
      "active": true
    },
    {
      "id": "05c6",
      "title": "Как стили навесить на viewChild (renderer2) ",
      "response": "В Angular, чтобы навесить стили на элемент, полученный с помощью @ViewChild, вы можете использовать Renderer2. Это позволяет вам динамически изменять стили элемента в безопасном и независимом от платформы способом. Ниже приведен пример того, как это можно сделать.Шаги для изменения стилей с помощью Renderer2 и @ViewChild 1. Импортируйте необходимые модули.2. Получите ссылку на элемент через @ViewChild.3. Используйте сервис Renderer2 для управления стилями.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "7ead",
      "title": "У нас есть код модули, как разбить код на модули ",
      "response": "Разбиение кода на модули - это важный аспект организации и управления проектом в Angular. Модули позволяют вам структурировать приложение, улучшить его читаемость и повторное использование кода. Вот шаги и рекомендации о том, как разбить код на модули в Angular:Причины для разбивки на модули 1. Структурирование кода: Модули помогают организовать код по функциональным направлениям.2. Улучшение производительности: Модули могут загружаться лениво (lazy loading), что ускоряет начальную загрузку приложения.3. Повторное использование: Модули можно использовать в разных частях приложения или даже в других проектах.Шаги для разбиения кода на модули 1. Определите функциональные области Сначала разделите приложение на логические секции. Например:- Пользовательский интерфейс (UI)- Аутентификация - Продукты или товары - Заказы или корзина - Админ-панель 2. Создайте модули 3. Переместите компоненты и сервисы 4. Настройте маршрутизацию 5. Импортируйте общий модуль 6. Настройте ленивую загрузку (если необходимо)",
      "level": "Junior",
      "active": false
    },
    {
      "id": "0e9a",
      "title": " Стал бы ты провайдить сервисы в шаред модуль",
      "response": "Да, обычно сервисы провайдятся в shared модуль, чтобы их можно было использовать в разных модулях приложения. Это помогает избежать дублирования кода и упрощает управление  зависимостями. Убедитесь, что сервисы являются stateless (без состояния) или могут безопасно работать с состоянием, если это необходимо",
      "level": "Middle",
      "active": false
    },
    {
      "id": "db83",
      "title": "Реактивные формы плюсы в чем плюсы",
      "response": "Плюсы реактивных форм в Angular:1. Контроль состояния: Обеспечивает строгий контроль над состоянием формы и её элементами.2. Модульность: Упрощает разделение форм на мелкие, управляемые компоненты.3. Тестируемость: Упрощает тестирование, так как логика формы отделена от представления.4. Удобное управление валидаторами: Легко добавлять и изменять валидаторы в реальном времени.5. Лучше с асинхронными данными: Удобнее работать с асинхронными операциями, такими как запросы к серверу.6. Императивный подход: Позволяет управлять формами через программный код, что может быть более понятно для разработчиков.'7. Динамическое изменение форм: Упрощает создание форм с динамическим набором полей и зависимостями между ними.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "46e1",
      "title": "Разница между 6-ым и 9-ым Angular? Что поменялось в плане работы с backEnd",
      "response": "Angular активно развивается, и между версиями 6 и 9 были внесены значительные изменения и улучшения. Вот основные изменения и отличия между Angular 6 и Angular 9, особенно в контексте работы с бэкендом:1. Ivy Renderer - Angular 9: Одной из самых заметных изменений в Angular 9 стал новый рендерер под названием Ivy. Ivy улучшает производительность, уменьшает размер бандла и значительно ускоряет время компиляции. Благодаря Ivy теперь проще и быстрее оптимизировать загрузку приложений.- Angular 6: Использовал стандартный рендерер.2. Анализ времени сборки - Angular 9: Новый рендерер Ivy предоставляет улучшенные возможности для анализа приложения и позволяет лучше оптимизировать время сборки и размеры финального бандла.3. Упрощение использования Angular для работы с HTTP - Angular 6: В этой версии были введены улучшения в модуле HttpClient, но основные изменения в основном касались улучшения обращений к API.- Angular 9: Были улучшены возможности работы с HttpClient и добавлены дополнительные возможности, такие как более удобные инструменты для использования RxJS на уровне сервисов. Более гибкие механизмы для обработки ошибок и применения интерсепторов.4. Ручное указание зависимостей - Angular 9: Улучшена поддержка \"Ручного указания зависимостей\" через providedIn на уровне сервиса, что делает внедрение зависимостей более простым и понятным. Это улучшает работу с DI и некоторыми сценариями, которые могут возникнуть при взаимодействии с бэкендом.5. Улучшения в CLI - Angular 9: Улучшены инструменты Angular CLI, которые обеспечивают более простой и быстрый процесс создания приложений и управления зависимостями. Новые функции, такие как возможность создания компонентов без необходимости вручную обновлять модули, делают разработку быстрее.6. Зависимости на уровне библиотеки - Angular 9: Старая структура зависимостей была улучшена для библиотек, что сделало процесс работы с библиотеками более интуитивным. Это упрощает интеграцию сторонних библиотек и работу с API, обеспечивая более гладкое взаимодействие с бэкендом.7. Поддержка Internationalization (i18n) - Angular 9: Улучшение системы локализации, что позволяет проще работать с многоязычными приложениями.Заключение: общем,Angular 9 обеспечивает более удобную компиляцию, лучшую производительность и оптимизацию. Работая с бэкендом, у разработчиков теперь есть дополнительные инструменты, которые упрощают процесс интеграции с API и обработку данных. Улучшенная отдача от Ivy также делает общую производительность приложений выше по сравнению с Angular 6.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "9cb9",
      "title": "Что такое компонент в Angular?",
      "response": "Компоненты являются основными строительными блоками Angular-приложений и содержат логику и представление.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "12dd",
      "title": "Что такое сервисы и как их использовать?",
      "response": "Сервисы — это классы, которые предоставляют определённый функционал и могут быть использованы для  обмена данными и выполнения логики, которая не привязана к конкретному компоненту. Сервисы помогают реализовать архитектуру, при которой код становится более модульным, переиспользуемым и легче поддерживаемым.Обычно они используются для взаимодействия с API, хранения и обработки данных, а также для реализации различных функций,таких как маршрутизация, аутентификация и т.д. Основные характеристики сервисов:1. Инъекция зависимостей: Angular использует механизм инъекции зависимостей для создания экземпляров сервисов,что позволяет автоматически управлять их жизненным циклом и зависимостями.2. Переиспользуемость: Сервисы могут быть использованы в разных компонентах, что повышает переиспользуемость кода.3. Модульность: Сервисы способствуют разделению бизнес-логики и логики представления (UI), что улучшает структуру кода.4. Тестируемость: Благодаря высокой модульности, сервисы легче тестировать отдельно от компонентов.Как правило, сервис регистрируется автоматически при использовании декоратора @Injectable с свойством providedIn: 'root'. Это делает его доступным в корневом модуле вашего приложения. Вы также можете зарегистрировать сервис в конкретном модуле или компоненте,добавив его в массив providers соответствующего декоратора.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "efc2",
      "title": "Каковы основные характеристики Angular?",
      "response": "1. Компонентный подход Angular основан на компонентной архитектуре, что позволяет разбивать интерфейс приложения на управляемые и переиспользуемые компоненты. Каждый компонент инкапсулирует свою логику, шаблон и стили, что упрощает разработку и сопровождение приложения.2. Двусторонняя привязка данных Angular поддерживает двустороннюю привязку данных (two-way data binding), что позволяет автоматически синхронизировать данные между моделью и представлением. Это упрощает взаимодействие между компонентами и инкапсулирует обновления данных, что делает разработку более интуитивной.3. Модули Angular использует систему модулей, что позволяет организовать код в независимые и логически связанные группы. Каждый модуль может содержать компоненты, директивы, сервисы и другие модули, что способствует модульному подходу и лучшей управляемости кода.4. Инъекция зависимостей (Dependency Injection) Angular предоставляет встроенную поддержку инъекции зависимостей, что упрощает управление зависимостями между классами и улучшает тестируемость приложения. Это позволяет легче управлять жизненным циклом объектов и их взаимодействием.  5. Маршрутизация Angular включает встроенный модуль маршрутизации, который позволяет организовать навигацию между различными представлениями или страницами приложения. Это делает приложения более удобными для пользователей и улучшает организацию кода.6. Реактивные формы Angular позволяет работать с формами через реактивные формы или шаблонные формы, что обеспечивает  мощные инструменты для валидации и отслеживания состояния. Реактивные формы позволяют динамически управлять формами в приложении, облегчая их настройку и валидацию. 7. RxJS и реактивное программирование Angular активно использует библиотеку RxJS, которая предоставляет инструменты для работы с асинхронными данными и потоками событий. Это дает разработчикам возможность эффективно управлять потоками данных и событий с использованием Observable.8. Генерация и сборка с помощью CLI Angular CLI (Command Line Interface) позволяет быстро создавать и управлять Angular приложениями. Он предлагает команды для создания новых компонентов, сервисов, модулей и т.д., а также автоматизирует процесс сборки, тестирования и развертывания.9. Тестируемость Angular разработан с учетом тестируемости. Он поддерживает юнит-тестирование компонентов и сервисов с помощью таких инструментов, как Jasmine и Karma. Это позволяет легко писать и запускать тесты, что способствует повышению качества кода.  10. Поддержка Progressive Web Apps (PWA) Angular обеспечивает поддержку создания прогрессивных веб-приложений, которые могут работать как нативные приложения на мобильных устройствах. PWA имеют повышенную скорость загрузки,работоспособность в оффлайн-режиме и возможность установки на домашний экран.11. Поддержка SEO Angular предоставляет механизмы для улучшения поисковой оптимизации (SEO) приложений, включая серверный  рендеринг с использованием Angular Universal. Это помогает приложениям эффективно индексироваться поисковыми системами.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "3b48",
      "title": "Что такое NgModule?",
      "response": "NgModule — это основной строительный блок приложения в Angular, который используется для организации и структурирования кода. Он позволяет группировать связанные компоненты, директивы, пайпы и сервисы в единое целое. Основная цель NgModule — определить область видимости и зависимости для различных частей вашего приложения. Вот основные аспекты NgModule:Основные характеристики NgModule:1. Определение модуля:Каждый Angular-модуль определяется с помощью декоратора @NgModule, который принимает объект конфигурации.Этот объект содержит метаданные, описывающие модуль.2. Импортируемые и экспортируемые модули:- Imports: Позволяет модулю импортировать другие модули, что делает доступными их компоненты, директивы и пайпы. Это позволяет разделять функциональность на разные модули и повторно использовать код.- Exports: Позволяет экспортировать компоненты, директивы и пайпы, чтобы они были доступны в других модулях, которые импортируют текущий модуль.3. Область видимости:Модули определяют область видимости для компонентов и сервисов. Компоненты, указанные в разделе  declarations, могут быть использованы только внутри этого модуля, если не экспортированы.4. Декларации:В разделе declarations указываются компоненты, директивы и пайпы, которые принадлежат этому модулю.5. Сервис и DI:Модули могут предоставлять сервисы через секцию providers. Angular автоматически создает экземпляр сервиса  и обеспечивает его инъекцию в компоненты, пользовательские директивы и другие сервисы.6. Основной модуль:Каждое Angular-приложение имеет как минимум один корневой модуль, обычно называемый AppModule, который инициализирует приложение.NgModule играет жизненно важную роль в организации Angular-приложений. Он обеспечивает модульность, упрощая управление зависимостями, структурирование кода и повторное использование компонентов. Правильное использование NgModule помогает создавать масштабируемые и поддерживаемые приложения.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "eb3b",
      "title": "Data binding (привязка к данным)",
      "response": "В шаблоне Angular привязка создает живую связь между частью пользовательского интерфейса, созданной из шаблона (элемент DOM, директива или компонент), и моделью (экземпляр компонента,к которому принадлежит шаблон). Эту связь можно использовать для синхронизации представления с моделью, для уведомления модели о том, что в представлении происходит событие или действие пользователя, или для того и другого. Алгоритм обнаружения изменений Angular отвечает за поддержание синхронизации представления и модели.Примеры связывания включают в себя:интерполяции текста {{value}},свойство связывание [value] привязка событий (click) двусторонняя привязка [{ngModel}] Привязки всегда состоят из двух частей: цели , которая будет получать связанное значение, и шаблонного выражения , которое создает значение из модели.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "7fae",
      "title": "Что такое @Pipe",
      "response": "функция которая преобразует разметку через | если есть доп свойства то через : есть pure и impure pipe - у него есть метод трансформ Pipe (или \"трубка\") в Angular — это специальный механизм, который позволяет преобразовывать данные в шаблонах приложения. Pipes используются для обработки и изменения данных перед их отображением пользователю. Они могут применяться для форматирования текста, преобразования дат, чисел, массивов и многого другого.Основные характеристики Pipe:1. Простота использования:- Pipes можно легко использовать в шаблонах Angular. Для этого достаточно указать название pipe и передать ему необходимые параметры в интерполяции или директиве. 2. Чистые и не чистые Pipes:- Пайпы могут быть чистыми и не чистыми. Чистые Pipes возвращают один и тот же результат при одинаковых входных данных, а не чистые могут выдавать разные результаты с одинаковыми входными данными (например,если они зависят от динамических данных, таких как текущее время).3. Встроенные Pipes:- Angular предоставляет несколько встроенных pipes, например:- DatePipe: преобразует дату в заданный формат.- CurrencyPipe: форматирует число в валюту.- DecimalPipe: форматирует число в десятичный формат.- JsonPipe: преобразует объект в JSON-строку для отладки.Пользовательские Pipes:- Вы можете создавать свои собственные pipes, чтобы реализовать специфическую логику преобразования  данных. Для этого необходимо использовать декоратор @Pipe и реализовать метод transform(value: any, ...args: any[]): any.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "7140",
      "title": "Хуки жизненного цикла",
      "response": "1.OnChanges - вызывается каждый раз, при установлении свойства 2.OnInit - один раз при инициализации компонента 3.DoCheck - при каждом проверки  изменении свойств 4.AfterContentInit - после проецирования контента в компоненте, вставка в html 5.AfterContentChecket - после проверки изменения проецируемого контент в шаблон 6.AfterViewInit - после инициализации представления родительского или дочернего компонента 7.AfterViewChecket - после проверки представления родительского или дочернего  компонента 8.OnDestroy - один раз после уничтожения компонента",
      "level": "Junior",
      "active": false
    },
    {
      "id": "0ea7",
      "title": "Модуль и его свойства",
      "response": "6.Модуль - класс с декоратором @ngModule - обьединяющая структура  для компонент, сервисов, пайпов, директив свойства - 1.Импорт - массив модулей нужных для нашего 2.Экспорт - массив компонент, пайпов, директив для экспорта 3.declaration - массив компонент, пайп, директив 4.providers - сервисы",
      "level": "Junior",
      "active": false
    },
    {
      "id": "95e7",
      "title": "Lazy loading",
      "response": "Асинхронная маршрутизация, позволяет не сразу создавать модуль, а когда пользователь переходит по определённому роутингу",
      "level": "Junior",
      "active": false
    },
    {
      "id": "768c",
      "title": "Что такое интерсепторы (interceptors) в Angular?",
      "response": "Интерсепторы (interceptors) в Angular являются частью модуля HttpClient и предоставляют мощный механизм для перехвата и обработки HTTP-запросов и ответов. Они позволяют разработчикам добавлять функциональность для каждого запроса и ответа на глобальном уровне, не изменяя сами компоненты или сервисы. Это может быть полезно для обработки заголовков, управления ошибками, добавления токенов аутентификации, логирования, кеширования и других задач.Интерсепторы являются классами, которые реализуют интерфейс HttpInterceptor. Для их создания необходимо выполнить следующие шаги:1. Создание класса интерсептора. Он должен реализовать метод intercept, который принимает два параметра: объект HttpRequest и объект HttpHandler. Этот метод должен возвращать объект Observable, который представляет ответ от сервера.2. Регистрация интерсептора. Интерсептор необходимо зарегистрировать в корневом модуле приложения или в соответствующем модуле, добавив его в массив providers.Применение интерсепторов:Интерсепторы могут использоваться для различных задач:1. Добавление токенов авторизации. Например, вы можете добавлять JWT-токены в заголовки каждого  защищенного запроса.2. Обработка ошибок. Интерсептор может обрабатывать ошибки от сервера и предоставлять единый подход к этому, вместо необходимости делать это в каждом сервисе или компоненте.3. Логирование. Вы можете записывать все исходящие запросы и входящие ответы для отладки или аудита.4. Модификация запросов и ответов. Интерсепторы могут изменять или фильтровать данные запроса и ответа перед их отправкой или после получения.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "befa",
      "title": "Взаимодействие с формами",
      "response": "В Angular взаимодействие с формами осуществляется с помощью двух основных подходов: реактивные формы и шаблонные формы.Оба подхода позволяют обрабатывать пользовательский ввод и валидировать данные, но используют разные механизмы и подходы.1. Шаблонные формы (Template-driven Forms)Шаблонные формы ориентированы на использование декларативного подхода и позволяют управлять формами через HTML-шаблоны.Для работы с ними нужно импортировать модуль FormsModule.2. Реактивные формы (Reactive Forms) Реактивные формы ориентированы на использование императивного подхода, предоставляя большую гибкость и контроль над формами.Для работы с реактивными формами нужно импортировать модуль ReactiveFormsModule.Оба подхода поддерживают валидацию форм. В шаблонных формах валидация осуществляется через атрибуты (например, required),а в реактивных формах — через встроенные валидаторы или пользовательские валидаторы.Шаблонные формы проще и быстрее в реализации, в то время как реактивные формы предоставляют  больше контроля и гибкости, особенно для сложных сценариев.",
      "level": "Middle",
      "active": false
    }
  ],
  "algorithms": [
    {
      "id": "b117",
      "title": "Что такое алгоритмы?",
      "response": "Алгоритмы в программировании представляют собой последовательность четко определенных шагов или правил, которые используются для решения определенной задачи или выполнения определенной операции. Алгоритм можно рассматривать как набор инструкций, который переводит входные данные в выходные результаты. Алгоритмы широко применяются в программировании для выполнения различных задач, таких как сортировка данных, поиск информации, обработка изображений и многое другое.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "42c0",
      "title": "Сортировка массива пузырьком",
      "response": " Сортировка пузырьком (Bubble Sort) — один из самых простых алгоритмов сортировки. Он работает путем многократного прохода по массиву, сравнения соседних элементов и их обмена местами, если они находятся в неправильном порядке. Процесс продолжается до тех пор, пока не будет выполнен проход без обменов, что означает, что массив отсортирован. Принцип работы алгоритма:1. Начните с первого элемента массива.2. Сравните текущий элемент с следующим.3. Если текущий элемент больше следующего, обменяйте их.4. Перейдите к следующему элементу и повторите шаги 2-3 до конца массива.5. После завершения одного полного прохода, повторяйте процесс для всего массива, пока не будет выполнен проход без обменов.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "3607",
      "title": "Поиск числа в массиве",
      "response": "Поиск числа в массиве может быть выполнен различными алгоритмами в зависимости от того, отсортирован массив или нет.1. Линейный поиск (Linear Search) Линейный поиск — это самый простой алгоритм, который исследует каждый элемент массива по порядку. Он проверяет каждое значение, пока не найдет нужное число или не достигнет конца массива.2. Бинарный поиск (Binary Search) Бинарный поиск — это более эффективный алгоритм, который применяется только для отсортированных массивов. Он работает, разбивая массив пополам и проверяя, находится ли искомый элемент в левой или правой половине. Сравнение алгоритмов \n- Линейный поиск:\n- Сложность времени: O(n) в худшем случае.\n- Прост в реализации и применим для неотсортированных массивов.- Бинарный поиск:- Сложность времени: O(log n) в худшем случае.- Эффективен только для отсортированных массивов и требует меньшего числа сравнений.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "bfc8",
      "title": "Поиск в глубину",
      "response": "Поиск в глубину (Depth-First Search, DFS) — это алгоритм для обхода или поиска в структуре данных ,такой как граф или дерево. Основная идея алгоритма состоит в том, чтобы начинать с корневой вершины (или произвольной начальной вершины для графов) и как можно глубже исследовать каждую ветвь, прежде чем отступить. DFS может быть реализован как с помощью рекурсии, так и с помощью стека. Принцип работы алгоритма DFS:1. Начинайте с корневой вершины и помечайте её как посещённую.2. Исследуйте все непосещённые соседние вершины, переходя в одну из них и повторяя шаг 1. 3. Если не осталось непосещённых соседей, вернитесь (отступите) к предыдущей вершине и повторите процесс для других непосещённых соседей.4. Повторяйте процесс, пока все вершины не будут посещены или пока не будет найдено нужное значение (если поиск).Характеристики DFS:- Сложность времени: O(V + E), где V — количество вершин, а E — количество рёбер в графе.- Сложность по памяти: O(V), т.к. необходимо хранить стеки или рекурсивные вызовы.- DFS может использоваться для решения задач вроде нахождения компонента связности, проверки простой связности графа,поиска циклов, топологической сортировки и других.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "7157",
      "title": "Обход дерева",
      "response": "Обходы дерева — это методы, с помощью которых можно пройти по всем узлам дерева в определённом порядке. Существуют три основных типа обхода для бинарных деревьев:1. Прямой обход (Pre-order traversal) В этом методе сначала обрабатывается (или посещается) текущий узел, затем левые дочерние узлы, и в конце правые дочерние узлы. Этот способ полезен, например, для создания копии дерева или преобразования дерева в префиксную запись.2. Центрированный обход (In-order traversal) При центреходе сначала обрабатываются левые дочерние узлы, затем текущий узел,и в конце правые дочерние узлы. Этот метод используется в бинарных деревьях поиска,поскольку при его выполнении узлы будут посещаться в отсортированном порядке.3. Обратный обход (Post-order traversal) В этом методе сначала обрабатываются левые и правые дочерние узлы, и только после этого текущий узел. Этот метод часто используется, когда необходимо выполнить действия, зависящие от дочерних узлов, например, при удалении дерева или вычислении значения в нём. Прямой обход подходит для случаев, когда нужно работать с родительским узлом первым, центрированный обход — для работы с отсортированными данными, а обратный обход — для обработки дочерних узлов перед родительскими.",
      "level": "Senior",
      "active": false
    },
    {
      "id": "7355",
      "title": "Алгоритм рекурсивного спуска",
      "response": "Алгоритм рекурсивного спуска — это метод, который применяется для решения различных задач, включая анализ и обработку выражений, синтаксический анализ и компиляцию языков программирования. Он используется для реализации рекурсивных грамматик. Рекурсивный спуск реализует синтаксический анализ программы, разбивая её на подзадачи с помощью рекурсии. Основные идеи алгоритма 1. Рекурсивные функции: Каждый элемент грамматики или конструкции языка реализуется через функцию. Если конструкция может быть рекурсивной, функция вызывает саму себя. 2. Грамматика: Рекурсивный спуск легче всего реализуется для грамматик, которые не содержат левой рекурсии. Это означает, что рекурсивные правила не должны вызывать самих себя в левой части.3. Состояние: В процессе анализа алгоритм работает с состоянием, которое включает в себя текущий токен, индекс в исходном потоке и, возможно, дополнительные параметры для хранения промежуточных  результатов.Преимущества:- Простота реализации и понимания.- Хорошо подходит для задач синтаксического анализа.Недостатки: - Неэффективен для грамматик с левой рекурсией.- Может привести к переполнению стека при глубокой рекурсии.",
      "level": "Senior",
      "active": false
    }
  ],
  "linux": [
    {
      "id": "22a9"
    }
  ],
  "categories": [
    {
      "id": "1",
      "name": "JavaScript",
      "endpoint": "/javascript"
    },
    {
      "id": "2",
      "name": "Обьектно-ориентированное программирование",
      "endpoint": "/oop"
    },
    {
      "id": "3",
      "name": "Тестирование",
      "endpoint": "/testing"
    },
    {
      "id": "4",
      "name": "Angular",
      "endpoint": "/angular"
    },
    {
      "id": "5",
      "name": "TypeScript",
      "endpoint": "/typescript"
    },
    {
      "id": "6",
      "name": "Паттерны проектирования",
      "endpoint": "/patterns"
    },
    {
      "id": "7",
      "name": "Сетевые протоколы",
      "endpoint": "/net-protocols"
    },
    {
      "id": "8",
      "name": "Алгоритмы",
      "endpoint": "/algorithms"
    },
    {
      "id": "9",
      "name": "Linux",
      "endpoint": "/linux"
    },
    {
      "id": "10",
      "name": "rxjs",
      "endpoint": "/rxjs"
    },
    {
      "id": "11",
      "name": "Git",
      "endpoint": "/git"
    },
    {
      "id": "12",
      "name": "CSS",
      "endpoint": "/css"
    },
    {
      "id": "13",
      "name": "Структуры данных",
      "endpoint": "/Структуры данных"
    },
    {
      "id": "13",
      "name": "html",
      "endpoint": "/html"
    }
  ],
  "html": [
    {
      "id": "f9cd",
      "title": "Что такое HTML и для чего он используется?",
      "response": "HTML (HyperText Markup Language) — это стандартный язык разметки,используемый для создания и структурирования контента на веб-страницах.Он описывает структуру веб-документа с помощью различных элементов, тегов и атрибутов.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "e988",
      "title": "Объясните структуру базового HTML-документа. Каковы обязательные элементы?",
      "response": "Базовый HTML-документ состоит из набора стандартных элементов, которые определяют структуру и содержание веб-страницы. Основные элементы HTML-документа включают в себя метаданные, заголовки, тело страницы и другие ключевые компоненты.Рассмотрим структуру базового HTML-документа и обязательные элементы более подробно.Структура базового HTML-документа:(!DOCTYPE html)   Определяет тип документа и версию HTML (html lang=\"en\")   Корневой элемент документа, указывает язык (head)   Содержит метаданные и ссылки на ресурсы (meta charset=\"UTF-8\")   Указывает кодировку документа (meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\") (title)Название страницы(/title)   Заголовок, отображается на вкладке браузера (link rel=\"stylesheet\" href=\"styles.css\")   Подключение CSS-файла (/head) (body)   Содержит содержимое страницы (h1>Заголовок первого уровня(/h1)   Заголовки от h1 до h6  (p)Это пример параграфа.(/p)   Простой параграф текста  (a href=\"https://example.com\">Ссылка на пример(/a)   Ссылка на другую страницу --> (/body) (/html) Обязательные элементы HTML-документа:1. !DOCTYPE html>: Указывает, что документ является HTML5. Это обязательный элемент, который должен быть на первой строке файла. 2. html>: Корневой элемент всего HTML-документа. Он может содержать атрибуты, такие как lang, который указывает на язык содержимого (например, lang=\"en\" для английского).3. head>: Содержит метаданные о документе, которые не отображаются на странице, но полезны для браузеров и поисковых систем. В head> создаются следующие обязательные элементы:- meta charset=\"UTF-8\">: Указывает кодировку документа. Использование UTF-8 рекомендуется для поддержки большинства символов.- title>: Задает заголовок страницы, который отображается на вкладке браузера.4. body>: Основной элемент, который содержит видимое содержимое страницы. Внутри body> могут находиться различные элементы, такие как заголовки, параграфы, изображения и ссылки.Дополнительные элементы - link>: Используется для подключения внешних ресурсов, таких как CSS-стили.- meta name=\"viewport\": Необязательный, но важный для адаптивного дизайна, позволяет контролировать, как сайт отображается на мобильных устройствах.- script>: Для подключения JavaScript-файлов, которые могут быть размещены в head> или в конце body> для оптимизации загрузки страницы.Заключение html>, head>, body> и !DOCTYPE>) позволит разработчику строить корректные и валидные документации, что важно для обеспечения совместимости с веб-браузерами и лучшего индексирования в поисковых системах.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "ec18",
      "title": "Что такое теги и атрибуты в HTML? Приведите примеры.",
      "response": "В HTML теги и атрибуты являются основными строительными блоками для создания веб-страниц.Они позволяют описывать структуру, содержание и внешний вид документа.Давайте рассмотрим, что такое теги и атрибуты, и приведем примеры их использования.Теги Тег — это основной элемент в HTML, который указывает браузерам,как обрабатывать и отображать содержание. Каждый тег состоит из  открывающего и закрывающего элемента, а также может содержать текст или другие вложенные теги.Атрибуты Атрибуты служат для добавления дополнительной информации к тегам. Они обычно определяются в открывающем теге и могут изменять поведение или внешний вид элемента. Атрибуты имеют имя и значение, которые отделены знаком равно.Таким образом, теги и атрибуты в HTML — это основные элементы для создания разметки веб-страниц.Теги определяют тип контента, а атрибуты задают дополнительные характеристики и поведение этих тегов, что позволяет разработчикам создавать структурированные и функциональные веб-страницы.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "5f50",
      "title": "Каковы различия между блочными и строчными элементами в HTML?",
      "response": "В HTML элементы можно классифицировать на блочные (block-level) и строчные (inline) элементы. Они различаются по своему поведению, отображению на странице и тому, как они взаимодействуют друг с другом. Давайте рассмотрим основные различия между ними.Блочные элементы (block-level elements) 1. Отображение: - Блочные элементы занимают всю доступную ширину своего родительского контейнера. Каждый блочный элемент начинается с новой строки, что приводит к разрыву строки до и после элемента.2. Примеры:- <div> - <p> - <h1> - <h6> - <ul>, <ol>, <li>  header>, footer>, section> 3. Свойства:- Блочные элементы могут иметь установленные размеры (ширину и высоту). - Могут содержать как блочные, так и строчные элементы внутри себя.- Обычно используются для структурирования макета страницы.Строчные элементы (inline elements) 1. Отображение:- Строчные элементы занимают только необходимую ширину для своего содержимого и не создают разрывов строки до и после. Они располагаются в строке рядом с другими строчными элементами.2. Примеры:- span> - a> - strong>, em> - img> - label> 3. Свойства:- Строчные элементы не могут иметь установленные размеры (ширину или высоту), они просто занимают пространство, необходимое для их содержимого.- Они могут содержать только строчные элементы внутри себя, но не могут содержать блочные элементы.- Используются для стилизации или добавления контента внутри блочных элементов.",
      "level": "Junior",
      "active": true
    },
    {
      "id": "85be",
      "title": "Что такое DOCTYPE, и почему он важен?",
      "response": "<!DOCTYPE> является декларацией, которая определяет версию HTML, используемую в документе. Она должна находиться в самом начале HTML-файла, перед тегом html>. Основная цель DOCTYPE заключается в том, чтобы сообщить браузерам, как правильно обрабатывать и отображать содержащийся в документе код.Важность DOCTYPE:1. Соответствие стандартам: DOCTYPE помогает браузерам понять, какой стандарт HTML следует использовать для рендеринга документа. Это позволяет избежать ошибок и неправильного отображения содержимого.2. Режимы рендеринга (Quirks Mode и Standards Mode):- Если DOCTYPE отсутствует или указан неправильно, браузеры могут переключиться в *Quirks Mode*.В этом режиме браузеры применяют старые, устаревшие способы обработки HTML и CSS, что может привести к несовместимости между различными браузерами.- При правильном DOCTYPE браузеры переходят в *Standards Mode*, что обеспечивает большую последовательность и предсказуемость в отображении страниц на разных браузерах.3. Упрощение разработки: Использование правильного DOCTYPE облегчает разработчикам работу с современными стандартамии спецификациями веб-разработки, позволяя избежать многих проблем с компоновкой и совместимостью.4. SEO и доступность: Хотя сам по себе DOCTYPE не влияет на SEO, следование стандартам HTML в целом положительно сказывается на индексировании поисковыми системами. Он также может улучшить доступность для пользователей с ограниченными возможностями,так как обеспечивает более точное структурирование документа",
      "level": "Junior",
      "active": false
    },
    {
      "id": "daec",
      "title": "Какие теги используются для создания заголовков (H1-H6) в HTML?",
      "response": "В HTML для создания заголовков используются теги от <h1> до <h6>.Эти теги используются для определения заголовков разных уровней и помогают структурировать содержимое веб-страницы. Каждый из этих  тегов имеет свое назначение и уровни важности, с <h1> как самым важным заголовком и <h6> как самым менее важным.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "f043",
      "title": "Какой атрибут делает поле формы обязательным для заполнения?",
      "response": "Атрибут, который делает поле формы обязательным для заполнения, называется required. Этот атрибут может быть применён к различным элементам формы, таким как <input>, <select> и <textarea>.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "31af",
      "title": "Как решалась проблема с SEO-оптимизацией",
      "response": "Проблемы с SEO-оптимизацией решаются множеством методов и стратегий, которые помогают улучшить видимость сайта в поисковых системах и повысить его рейтинг. Вот основные способы, которыми организации и веб-мастера решают проблемы с SEO:1. Анализ и исследование ключевых слов - Поиск ключевых слов: Использование инструментов для исследования ключевых слов (например, Google Keyword Planner, SEMrush, Ahrefs) для определения наиболее подходящих и высоко востребованных ключевых слов.2. Оптимизация на странице (On-page SEO) - Качество контента: Создание уникального, полезного и информативного контента, который отвечает на вопросы пользователей и обеспечивает удовлетворение их потребностей.- Мета-теги: Оптимизация мета-заголовков и мета-описаний, чтобы они соответствовали содержанию страниц и вызывали интерес пользователей.- Заголовки и структура: Использование правильной структуры заголовков (H1, H2, H3 и т.д.) для лучшего понимания контента как пользователями, так и поисковыми системами.3. Техническое SEO - Скорость загрузки страницы: Оптимизация скорости загрузки страниц с помощью сжатия изображений, использования кеширования, минимизации CSS и JavaScript.- Мобильная адаптация: Создание отзывчивого дизайна для обеспечения удобного просмотра сайта на мобильных устройствах, что становится все более важным для поисковых систем.- XML-карты сайта: Создание и отправка карты сайта (sitemap.xml) в поисковые системы для улучшения индексации.4. Внешняя оптимизация (Off-page SEO) - Ссылочное продвижение: Увеличение количества обратных ссылок (backlinks) через публикацию статей, гостевое блоггинг и другие методы, чтобы повысить авторитет сайта.- Социальные сигналы: Активное участие в социальных сетях и деление контентом, что может привести к росту трафика и повышению видимости.5. Аналитика и мониторинг - Отслеживание производительности: Использование инструментов аналитики, таких как Google Analytics и Google Search Console, для отслеживания трафика, позиций в поисковой выдаче и других важных метрик.- А/B тестирование: Проведение тестов на различных элементах страницы, чтобы определить, какие изменения повышают конверсию и улучшают SEO.6. Обновление и оптимизация контента - Обновление старого контента: Регулярное обновление устаревшего контента, добавление новых данных и улучшение его качества для поддержания актуальности.- Углубленный анализ: Анализ, какой контент работает лучше всего и его оптимизация для улучшения результатов.7. Использование структурированных данных - Schema Markup: Внедрение структурированных данных, чтобы помочь поисковым системам лучше понимать содержание и контекст страниц, что может привести к улучшению отображения в поисковой выдаче",
      "level": "Senior",
      "active": false
    },
    {
      "id": "a257",
      "title": "Различия между html4 и html5",
      "response": "HTML4 и HTML5 — это две версии языка разметки HTML (HyperText Markup Language), которые используются для создания веб-страниц. HTML5 предоставляет множество усовершенствований и новых возможностей по сравнению с HTML4. Вот основные различия между ними:1. Стандарты и спецификации - HTML4: Введён в 1997 году, и его основное внимание было сосредоточено на структуре документа и разметке.- HTML5: Больше внимания уделяется семантике, доступности и разнообразию возможностей для разработки современных веб-приложений.2. Поддержка мультимедиа - HTML4: Не поддерживает встроенные медиа (аудио и видео) без использования сторонних плагинов, таких как Flash.- HTML5: Включает встроенные элементы <audio> и <video>, которые позволяют воспроизводить медиафайлы без необходимости дополнительных плагинов.3. Семантические элементы - HTML4: Осуществляется с помощью общих элементов, таких как <div> и <span>, что затрудняет понимание структуры документа. - HTML5: Введены новые семантические теги, такие как <header>, <nav>, <article>, <section>,<footer>, которые улучшает структуру и доступность веб-контента.4. Формы и элементы ввода - HTML4: Имеет ограниченный набор элементов форм и атрибутов.- HTML5: Расширяет возможности форм, включая новые типы ввода, такие как email, date, number, range, и новые атрибуты, такие как placeholder, autofocus, и required, а также поддержку валидации на стороне клиента.5. Канвас и графика - HTML4: Не поддерживает встроенную графику или рисование.- HTML5: Включает элемент canvas>, который позволяет рисовать графику и создавать игры с помощью JavaScript.6. API и функциональность - HTML4: Основной функционал ограничен основами разметки.- HTML5: Вводит множество новых API для работы с веб-приложениями, такие как API для локального хранения (localStorage), геолокации, WebSockets для построения реального времени и другие функциональные возможности.7. Доктрины и типы документов - HTML4: Имеет различные типа документа для разных спецификаций, что может быть запутанным.- HTML5: Объединяет тип документа в один простой DOCTYPE html>, что упрощает разметку и использование.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "56f0",
      "title": "Ретина. Что это такое, как используются варианты изображения для обычного экрана и для ретины в html|css ",
      "response": "Retina — это термин, введенный компанией Apple, обозначающий дисплеи с высокой плотностью пикселей (DPI), которые могут отображать более четкие и детализированные изображения по сравнению с обычными экранами. На Retina-дисплеях пиксели малы и их много, что позволяет добиться более высокой четкости текста и изображений. Термин стал широко использоваться для любых устройств с аналогичными характеристиками, включая мобильные телефоны, планшеты и ноутбуки от других производителей.Чтобы обеспечить качественное отображение изображений на Retina-дисплеях, необходимо использовать специальные подходы, которые позволяют загружать изображения с более высоким разрешением. Вот основные методы работы с изображениями для обычных и Retina-экранов в HTML и CSS:1. Использование изображений различных разрешений На популярном уровне подход заключается в использовании изображений с высоким разрешением для Retina-устройств и обычных изображений для стандартных экранов. Например, если вы используете изображение размером 100x100 пикселей для обычного экрана, вы можете создать его версию размера 200x200 пикселей для Retina-дисплеев.2. Использование CSS и медиа-запросов Вы также можете использовать CSS для определения различных изображений в зависимости от разрешения экрана с помощью медиа-запросов 3. Использование picture и <source> Элемент picture> в HTML5 позволяет задавать различные источники изображений для разных условий, включая размер, формат и DPI. Это даёт разработчикам больше контроля над тем, какое изображение отображать на разных устройствах.Использование изображений подходящего разрешения для Retina и обычных дисплеев критически важно для обеспечения качества пользовательского опыта. Применение методов, таких как srcset, CSS медиа-запросы и элемент <picture>, позволяет создавать адаптивные изображения, которые будут правильно отображаться на любых устройствах, обеспечивая при этом оптимальную производительность и качество.",
      "level": "Senior",
      "active": false
    },
    {
      "id": "4d17",
      "title": "SVG. Для чего нужен, как используется, приемы применения",
      "response": "SVG (Scalable Vector Graphics) — это формат векторной графики на основе XML, который используется для описания двухмерной графики. Он обладает рядом преимуществ по сравнению с растровыми изображениями и широко применяется в веб-дизайне и разработке.Для чего нужен SVG 1. Масштабируемость: SVG-графика не теряет качества при масштабировании. Это делает её идеальной для адаптивных веб-дизайнов и различных устройств с разными размероми экрана.2. Неограниченные стили: SVG позволяет применять CSS и JavaScript для стилизации и анимации графики. Это даёт возможность создавать интерактивные элементы.3. Маленький размер файлов: В большинстве случаев SVG-файлы имеют меньший размер по сравнению с растровыми изображениями, что уменьшает время загрузки страницы.4. Редактируемость: SVG-файлы могут быть созданы и обработаны с помощью текстовых редакторов, что облегчает редактирование и изменение элементов.5. Идеален для веб: SVG хорошо интегрируется с HTML и CSS, что делает его удобным для веб-разработчиков.Основные способы использования SVG - Встраивание SVG в HTML: SVG может быть встроено непосредственно в HTML-код.Как изображение: SVG может быть использовано как обычное изображение с помощью тега <img>.- Фоновое изображение в CSS: SVG может использоваться как фоновое изображение в стилях CSS.Приемы применения SVG 1. Изображения и иконки: SVG часто используется для создания иконок и простых графических элементов, так как они сохраняют четкость на любом разрешении.2. Анимация: SVG поддерживает анимацию с помощью CSS и JavaScript, что позволяет создавать динамичные и интерактивные элементы.3. Интерактивные графики: С помощью JavaScript можно сделать элементы SVG интерактивными, добавляя обработчики событий.4. Воздействие на стили: SVG элементы могут быть стилизованы с помощью CSS, что позволяет управлять их внешним видом через стили.5. Масштабируемые графики: SVG идеально подходит для создания графиков и диаграмм на веб-страницах, использование библиотек, таких как D3.js, для визуализации данных.6. Логотипы: SVG — отличный выбор для логотипов, так как они масштабируются без потери качества и легко редактируются.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "aeab",
      "title": "Что такое параграфы в HTML, и какой тег используется для их создания?",
      "response": "В HTML параграфы используются для организации текста в четкие и логически обособленные блоки. Параграфы помогают улучшить читаемость и восприятие текста на веб-странице,разделяя его на отдельные смысловые единицы.Тег для создания параграфов Для создания параграфа в HTML используется тег p>. Этот тег является блочным элементом, что означает,что каждый параграф занимает всю доступную ширину своего родительского контейнера и начинается с новой строки.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "f664",
      "title": "Как вставить изображения в HTML? Каковы атрибуты для тега img?",
      "response": "В HTML для вставки изображений используется тег img>. Это самозакрывающийся  тег, то есть он не требует закрывающего тега. Тег img> позволяет вставлять изображения с различных источников, таких как локальные файлы или удалённые URL. Вот основной синтаксис для вставки изображения:img src=\"путь_к_изображению\" alt=\"текст_альтернативы\"> Основные атрибуты тега img> 1. src (source):- Указывает путь к изображению, которое нужно отобразить. Может быть абсолютным (URL) или относительным (путь к файлу на сервере).2. alt (alternative text):- Предоставляет альтернативный текст для изображения, если оно не может быть отображено.Также используется для обеспечения доступности для людей с ограниченными возможностями, улучшает SEO.3. width (ширина):- Задает ширину изображения в пикселях или процентах. Может быть использован для изменения размера изображения при отображении,но не рекомендуем использовать его вместо правильной пропорции размеров самих изображений.4. height (высота):- Указывает высоту изображения в пикселях или процентах. Работает аналогично атрибуту width.5. title:- Предоставляет дополнительную информацию о изображении, которая отображается в виде всплывающей подсказки,когда пользователь наводит курсор на изображение.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "d914",
      "title": "Что такое атрибут placeholder, и как его использовать?",
      "response": "Атрибут placeholder в HTML используется для отображения текстовой подсказки внутри элемента управления формы, такого как текстовое поле input>) или многострочное текстовое поле textarea>).Этот текст служит указанием для пользователя, предоставляя информацию о том,что должно быть введено в это поле. Когда пользователь начинает вводить текст,содержимое атрибута placeholder исчезает.1. Подсказка: Помогает пользователю понять, какую информацию следует ввести в данное поле.2. Визуальное оформление: Текст в этом атрибуте обычно отображается светлым или серым цветом и стилизуется так, чтобы отличаться от введенного текста.3. Невидимость при вводе: Как только пользователь начнет вводить текст в поле, текст подсказки исчезает.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "141e",
      "title": "Как создать ссылки в HTML? Каковы основные атрибуты тега a?",
      "response": "В HTML для создания ссылок используется тег a>, который обозначает анкор (или ссылку).Этот тег позволяет пользователям переходить на другие страницы, секции той же страницы или внешние ресурсы. Синтаксис тега a>Основной синтаксис для создания ссылки выглядит следующим образом:a href=\"URL\">Текст ссылки/a>Основные атрибуты тега a> 1. href:- Обязательный атрибут, который указывает URL-адрес, на который ведет ссылка. Это может быть абсолютный URL  (полный адрес, включая протокол, например, https://) или относительный URL (путь к страницам на том же сайте).2.target:- Опциональный атрибут, который определяет, как будет открываться ссылка. Наиболее распространенные значения:- _self: открыть в том же окне или вкладке (по умолчанию).- _blank: открыть в новом окне или вкладке.3. rel:- Опциональный атрибут, который определяет отношение между текущей страницей и целевой страницей. Например, rel=\"noopener\" и rel=\"noreferrer\" используются в сочетании с target=\"_blank\" для повышения безопасности.- Опциональный атрибут, который предоставляет дополнительную информацию о ссылке. Этот текст отображается в виде  всплывающей подсказки, когда пользователь наводит курсор на ссылку.5. id:- Уникальный идентификатор для ссылки, который может быть использован для ссылок внутри страницы или в CSS.Тег a> является важным инструментом в HTML для создания гиперссылок, что позволяет пользователям перемещаться по контенту. Правильное использование атрибутов,таких как href, target, rel, и title, улучшает функциональность и удобство использования ссылок на веб-странице.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "d90e",
      "title": "Какие теги используются для создания списков в HTML и в чем разница между маркированным и нумерованным списками?",
      "response": "В HTML для создания списков используются следующие теги:1. Маркированные списки: Для создания маркированных списков (или списков с неупорядоченными элементами) используется тег ul> (unordered list). Каждый элемент списка обозначается тегом li> (list item). 2. Нумерованные списки: Для создания нумерованных списков (или списков с упорядоченными элементами) используется тег ol> (ordered list). Каждый элемент списка также обозначается тегом li>.Основные отличия между маркированными и нумерованными списками:1. Отображение:- Маркированный список (ul>): Элементы списка представляются с помощью маркеров (обычно, точек, но могут быть и другие символы, в зависимости от CSS-стилей).- Нумерованный список (ol>): Элементы списка пронумерованы, и каждое число или буква отображается перед элементом списка.2. Использование:- Маркированный список: Используется в тех случаях, когда порядок элементов не имеет значения,и нужно просто перечислить неупорядоченные элементы.- Нумерованный список: Применяется, когда порядок элементов важен, например, инструкции, шаги процесса или последовательность действий.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "5899",
      "title": "Что такое форма в HTML и зачем она нужна?",
      "response": "Форма в HTML — это специальная структура, предназначенная для сбора данных от пользователей.Формы являются ключевым элементом взаимодействия между пользователем и веб-приложением, позволяя отправлять информацию, такую как текстовые поля, кнопки, радиокнопки и другие элементы управления. Формы могут использоваться для различных целей,включая регистрацию пользователей, вход в систему, отправку комментариев, поиск информации и заказ услуг или товаров.Основные функции форм:1. Сбор данных: Формы позволяют пользователям вводить данные, такие как имя, адрес электронной почты, номер телефона и другую необходимую информацию.2. Отправка данных на сервер: После заполнения формы и нажатия кнопки отправки, данные могут быть отправлены на сервер для обработки. Сервер может затем сохранить эти данные, отправить подтверждение или выполнить другие действия, основанные на введенной информации.3. Взаимодействие с пользователем: Формы могут включать различные элементы управления, такие как текстовые поля,флажки, выпадающие списки и кнопки, что позволяет пользователю взаимодействовать с веб-страницей более эффективно.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "cb1b",
      "title": "Как создать текстовое поле, радио-кнопки и выпадающий список в HTML? Приведите примеры.",
      "response": "В HTML для создания различных элементов управления, таких как текстовые поля, радио-кнопки и выпадающие списки, используются теги input>, textarea> и select>.1. Текстовое поле Для создания текстового поля используется тег input> с атрибутом type, установленным в значение text.2. Радио-кнопки Для создания группы радио-кнопок используется тег input> с атрибутом type, установленным в значение radio.Все радио-кнопки в группе должны иметь один и тот же атрибут name, чтобы их можно было выбрать только по одному.3. Выпадающий список Для создания выпадающего списка используется тег select>, внутри которого размещаются теги option>,представляющие элементы списка.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "1530",
      "title": "Как работают атрибуты action и method в теге form",
      "response": "Атрибуты action и method в теге form> в HTML играют важную роль в определении того,как данные формы будут обрабатываться и куда они будут отправлены. Давайте рассмотрим каждый из этих атрибутов подробнее.1. Атрибут actionАтрибут action указывает URL-адрес, на который будут отправлены данные формы после ее отправки.Это может быть адрес сервера, который обрабатывает данные, или другой URL, если необходимо перенаправить на другую страницу.2. Атрибут method Атрибут method определяет способ отправки данных формы. Существует два основных значения для этого атрибута:1. GET: Данные формы будут добавлены к URL-адресу как строка запроса. Это полезно для запросов, которые не изменяют состояние данных на сервере (например, для поиска). Однако стоит отметить, что данные будут видны в адресной строке и имеют ограничение по размеру (в зависимости от браузера и сервера).2. POST: Данные формы отправляются в теле HTTP-запроса. Этот метод более безопасен для  передачи конфиденциальной информации,так как данные не отображаются в адресной строке. Обычно используется для отправки данных,которые изменяют состояние на сервере, например, регистрации или логина.- Атрибут action определяет, куда отправляются данные формы, в то время как атрибут method определяет,как они будут отправлены (метод отправки данных).Выбор правильного метода важен в зависимости от требований вашего приложения и безопасности передачи данных.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "4ddc",
      "title": "Как создать кнопку отправки формы в HTML? Каковы основные атрибуты тега button?",
      "response": "Кнопка отправки формы в HTML создается с использованием тега button> или тега input> с атрибутом type установленным в значение submit. Оба подхода позволяют пользователю отправить данные формы на сервер.  1. Создание кнопки отправки формы с помощью тега button>  2. Создание кнопки отправки формы с помощью тега input>\n Также можно создать кнопку отправки формы с помощью тега input>  Основные атрибуты тега button> Тег button> имеет несколько основных атрибутов, которые могут быть полезны при создании кнопки: 1. type: Определяет действие кнопки. Основные типы: - submit: Отправляет форму (это значение по умолчанию).- button: Обычная кнопка, не связанная с отправкой формы.- reset: Сбрасывает значения всех полей формы к их первоначальному состоянию. 2. name: Имя кнопки, которое может быть передано на сервер при отправке формы. 3. value: Значение кнопки, которое будет отправлено на сервер при её нажатии. Это актуально для кнопок типа submit. 4. disabled: Если указан, кнопка будет недоступна для нажатия. 5. onclick: JavaScript обработчик события при нажатии на кнопку.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "b3fc",
      "title": "Что такое семантические элементы в HTML5?",
      "response": "Семантические элементы в HTML5 — это элементы, которые передают значение и структуру содержимого, делая его более понятным как для разработчиков, так и для браузеров и поисковых систем.Эти элементы несут с собой информацию о значении и роли содержащегося текста или других элементов,что улучшает доступность и SEO (поисковую оптимизацию) веб-страницы. Семантические элементы   позволяют создать более читаемую и организованную структуру документа, что важно для поддержания кодовой базы в будущем.  Вот несколько основных семантических элементов, введенных в HTML5: 1. header>: Определяет верхнюю часть документа или раздела страницы, содержащую заголовки, логотипы, навигации и другие вводные элементы. 2. nav>: Используется для определения блока навигации, содержащего ссылки на другие страницы или  разделы в рамках текущего документа. 3. article>: Представляет независимый фрагмент контента, который может быть переработан или повторно  использован вне контекста, как например пост в блоге или статья. 4. section>: Определяет тематическую секцию документа.  Обычно содержит заголовок и другие элементы, связанные с этой темой. 5. aside>: Используется для обозначения контента, который является второстепенным по отношению к  основному содержимому (например, боковая колонка с дополнительной информацией или ссылки). 6. footer>: Определяет нижнюю часть документа или раздела, может содержать информацию об авторских правах, ссылки на политику конфиденциальности и другую вспомогательную информацию. 7. figure> и figcaption>: Используются для описания медиа-объектов (например, изображений, диаграмм) и их подписей. Преимущества семантических элементов  1. Улучшение доступности: Семантические элементы делают контент более доступным для пользователей с ограниченными возможностями, так как экранирующие технологии могут лучше интерпретировать и представлять эти элементы. 2. SEO: Поисковые системы лучше понимают структуру и содержание страницы, что может улучшить ее рейтинг в результатах поиска. 3. Читаемость кода: Семантические элементы делают код более структурированным и понятным для разработчиков, облегчая поддержку и обновление кода в будущем.\n\n\n\n",
      "level": "Middle",
      "active": false
    },
    {
      "id": "6854",
      "title": "Что такое адаптивный веб-дизайн, и как HTML может помочь в его реализации?",
      "response": " Адаптивный веб-дизайн (Adaptive Web Design, AWD) представляет собой подход к веб-разработке, который позволяет веб-сайту оптимально отображаться на устройствах с различными размерами экранов  и характеристиками. Задача адаптивного дизайна — обеспечить отличный пользовательский опыт независимо  от устройства, с которого осуществляется доступ к сайту, будь то настольный компьютер, ноутбук, планшет или смартфон.### Основные аспекты адаптивного веб-дизайна  1. Гибкие сетки: Использование процентных значений для ширины элементов, а не фиксированных значений в пикселях, позволяет создавать более гибкие и отзывчивые макеты. 2. Медиа-запросы: Это правило CSS, которое позволяет применять разные стили в зависимости от размера экрана  или других характеристик устройства. Благодаря медиа-запросам можно изменять внешний вид и поведение элементов \n в зависимости от устройства. 3. Управление изображениями: Использование изображений, которые могут адаптироваться к размерам экрана, чтобы  обеспечить быстрое загрузку и избежать искажения. HTML играет важную роль в реализации адаптивного веб-дизайна. Вот некоторые способы, как это достигается: 1. Структурирование контента: - Правильное использование семантических элементов HTML (таких как header>, nav>, article>, section>, footer>) помогает организовать контент и облегчить его стилизацию с помощью CSS. Это делает адаптацию контента более понятной и управляемой. 2. Ввод метатега viewport: - Добавление метатега viewport в секцию head> помогает контролировать масштабирование и размер страницы на мобильных устройствах:   meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"> 3. Гибкие изображения и медиа: - Использование атрибута srcset и sizes в элементах img> позволяет браузеру загружать версии изображений, оптимизированные для разных размеров экранов:   img src=\"small.jpg\" srcset=\"medium.jpg 768w, large.jpg 1200w\" sizes=\"(max-width: 768px) 100vw, 50vw\" alt=\"Описание изображения\"> 4. Гибкие таблицы: - С помощью HTML и CSS можно создавать таблицы, которые могут адаптироваться к различным размерам экранов, например, с помощью медиазапросов для изменения стилей таблицы.\n 5. Использование ARIA: - HTML может включать атрибуты ARIA (Accessible Rich Internet Applications), которые помогают сделать веб-сайты более доступными для людей с ограниченными возможностями. Это особенно важно для адаптивного дизайна, где структура и доступность контента на разных устройствах должны быть гармонированы.\n\n\n\n\n\n\n\n\n\n",
      "level": "Middle",
      "active": false
    },
    {
      "id": "4ced",
      "title": " Как использовать теги article, section, nav и aside в HTML5?",
      "response": "В HTML5 теги article>, section>, nav> и aside> являются семантическими элементами, которые помогают  структурировать и организовывать контент на веб-странице. Каждый из этих тегов имеет свое предназначение  и полезен для создания более понятного и доступного кода.1. article>  Тег article> используется для определения независимого фрагмента контента,  который может быть переиспользован или прочитан отдельно от остальной части документа.  Это может быть статья блога, новости, посты на форумах и т. д.2. section>  Тег section> используется для группировки тематически связанных контентов. Секция может содержать заголовок и другие   элементы, относящиеся к одной теме. Используйте его, чтобы разделять главные части вашего документа. 3. nav>  Тег nav> обозначает секцию, содержащую ссылки на другие страницы или разделы внутри одного документа. Это помогает пользователям легко ориентироваться по сайту. 4. aside>  Тег aside> используется для обозначения контента, который является второстепенным или вспомогательным по отношению к основному содержимому. Это может быть боковая панель, заметки, ссылки или любая другая информация, связанная с основным контентом, но не являющаяся частью него.Заключение Использование семантических тегов, таких как article>, section>, nav> и aside>, улучшает структуру вашего HTML-кода, делает его более понятным и доступным как для пользователей, так и для поисковых систем. Это способствует лучшему  восприятию контента и улучшает SEO.\n\n\n",
      "level": "Senior",
      "active": false
    },
    {
      "id": "0f2f",
      "title": " Что такое canvas, и как его использовать для рисования графики на веб-странице?",
      "response": "canvas> — это HTML-элемент, который представляет собой прямоугольную область на веб-странице,предназначенную для рисования графики с помощью JavaScript. Он позволяет динамически создавать графику, анимации, картинки и даже игры. canvas> обеспечивается в HTML5 и не требует использования дополнительных плагинов, таких как Flash, что делает его доступным  для большинства современных браузеров.Параметры использования canvas>Вот основные шаги для использования canvas> для рисования графики:1. Добавление элемента canvas> в HTML:Вы определяете размер области, задавая атрибуты width и height. Если эти атрибуты не указаны, canvas> будет иметь размер 300 пикселей шириной и 150 пикселей высотой по умолчанию.2. Получение контекста рисования:Для рисования на canvas> вам необходимо получить его контекст. Это можно сделать с помощью метода getContext().Обычно используется 2D-контекст для рисования двумерной графики.Рисование графики:Используя методы контекста, можно рисовать различные фигуры, линии, текстура, изображения и многое другое.4. Добавление изображений:Вы можете загружать и выводить изображения на стене canvas>.5. Рисование текста:Вы можете добавлять текст на canvas>.Элемент canvas> — мощный инструмент для создания динамичной графики на веб-странице.С его помощью вы можете создавать простые фигуры, сложные анимации и даже игры. Благодаря сочетанию HTML5 и JavaScript возможности canvas> очень широки, и его можно использовать в самых разных проектах,от базового рисования до полноценных приложений.",
      "level": "Senior",
      "active": false
    },
    {
      "id": "ff58",
      "title": " Что такое video и audio элементы в HTML5? Как их использовать?",
      "response": "Элементы video> и audio> в HTML5 позволяют встраивать и воспроизводить мультимедийные файлы (видео и аудио) непосредственно на веб-странице без необходимости использования сторонних плагинов,таких как Flash. Это делает воспроизведение медиафайлов более доступным и совместимым с различными устройствами и браузерами.Элемент video> Элемент video> используется для встраивания видеоконтента. Он поддерживает несколько форматов, таких как MP4, WebM и Ogg.Описание атрибутов:- width и height: задают ширину и высоту видео.- controls: отображает стандартные элементы управления (плей, пауза, громкость и т.д.). - source: позволяет указать разные видеоформаты для обеспечения совместимости с различными браузерами. - Вы можете также использовать атрибуты autoplay, loop, muted, poster: - autoplay: видео начинает воспроизводиться автоматически (включает звук и без него, в зависимости от настройки браузера). - loop: видео будет воспроизводиться в цикле.\n - muted: видео будет воспроизводиться без звука. - poster: задаёт изображение, которое будет отображаться до начала воспроизведения видео.Элемент audio>  Элемент audio> используется для встраивания аудиофайлов. Поддерживаемые форматы могут включать MP3, Ogg и WAV. Описание атрибутов: - controls: отображает стандартные элементы управления для воспроизведения аудио. - source: как и в видео, указывает разные форматы аудиофайлов для обеспечения совместимости с различными браузерами. - Вы также можете использовать атрибуты autoplay, loop, muted: - autoplay: аудио начинает воспроизводиться автоматически (может быть отключено в некоторых браузерах). - loop: аудиофайл будет воспроизводиться в цикле. - muted: аудио будет воспроизводиться без звука. Элементы video> и audio> в HTML5 обеспечивают легкий и эффективный способ встраивания мультимедийного контента  на веб-страницы, улучшая пользовательский интерфейс и доступность. Их использование требует минимальных усилий и кодирования, что делает их важными инструментами для современных веб-разработчиков.",
      "level": "Senior",
      "active": false
    }
  ],
  "javascript": [
    {
      "id": "4acf",
      "title": "Что такое JavaScript?",
      "response": "Это язык программирования с динамической типизацией, однопоточный",
      "level": "Junior",
      "active": true
    },
    {
      "id": "2eec",
      "title": "Типы данных",
      "response": "1.Строка2.Число3.BigInt(большое число)4.Boolean(логическое)5.Null 6.Undefined(не определено) 7.Symbol(символ) 8.Object(обьект)",
      "level": "Junior",
      "active": false
    },
    {
      "id": "484b",
      "title": "Отличие null от undefined",
      "response": "undefined - отсутствие значение, null - намеренное присвоение undefined:- Обычно используется системой или движком JavaScript, чтобы указать, что что-то не было инициализировано или не было установлено.- Это может происходить, когда функция не возвращает значение (в этом случае возвращается undefined по умолчанию).- null:- Используется программистами для указания на отсутствие значения.- Чаще всего применяется в логике программы, чтобы обозначить, что значение было удалено или не установлено по какой-то причине.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "6861",
      "title": "Какие из типов данных являются ссылочными типами в JavaScript?",
      "response": "1. Объекты (Objects) - Объекты являются основным типом данных и могут содержать множество значений в виде пар ключ-значение. Каждый объект является ссылочным типом.2. Массивы (Arrays) - Массивы являются специализированным типом объектов и могут содержать упорядоченные коллекции значений. Массивы также являются ссылочными.3. Функции (Functions) - Функции в JavaScript также являются объектами, и их можно рассматривать как ссылочные типы данных. Это означает, что функции могут быть присвоены переменным, переданы в другие функции и возвращены из других функций.Даты (Dates)- Объект Date используется для работы с датами и временем, и он также является ссылочным типом данных.Регулярные выражения (Regular Expressions) - Регулярные выражения используются для работы с текстом и также являются объектами, следовательно, они относятся к ссылочным типам данных.Классы (Classes) - Классы в JavaScript являются конструкторами, которые можно использовать для создания объектов. При создании экземпляра класса создается ссылочный тип.Особенности ссылочных типов данных - Ссылки vs. Значения: При присвоении или передаче ссылочных типов данных, передается не само значение, а ссылка на объект. Это означает, что изменения в одном месте могут повлиять на объект в другом месте, где используется эта ссылка.- Проверка на равенство: При использовании оператора строгого равенства === для сравнения двух объектов, будет возвращено true только если оба объекта ссылаются на один и тот же экземпляр в памяти.В заключение, ссылочные типы данных в JavaScript включают объекты, массивы, функции, даты, регулярные выражения и классы. Они позволяют более гибко управлять данными и делают JavaScript мощным инструментом для разработки.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "7dfb",
      "title": "Symbol, что такое, когда и для чего используется? ",
      "response": "Symbol — это примитивный тип данных в JavaScript, который был введен в ECMAScript 2015 (ES6). Он представляет уникальные и неизменяемые идентификаторы, которые могут быть использованы как ключи для свойств объектов. Вот основные аспекты использования Symbol: 1. Уникальность Каждый символ создается с помощью функции Symbol(), и каждый раз, когда вы вызываете эту функцию , создается новый символ. Даже если вы создаете символы с одинаковыми описаниями, они все равно будут уникальными.2. Использование в качестве ключей свойств объектов Символы часто используются в качестве уникальных ключей для свойств объектов. Это помогает избежать конфликтов имен, особенно если вы работаете с объектами, расширяемыми другими библиотеками или кодом.3. Для создания приватных свойств Символы создают свойства, которые труднее случайно перезаписать или переопределить, что делает их хорошими для создания приватных свойств внутри объектов.Однако следует отметить, что символы не являются полностью приватными; они могут быть доступны через рефлексию.4. Символы и встроенные методы В JavaScript существуют несколько встроенных символов (например, Symbol.iterator, Symbol.asyncIterator, Symbol.toStringTag и других), которые предоставляют специальные функции для встроенных объектов. Например, Symbol.iterator позволяет определить, как объект должен быть итерирован с использованием конструкций, таких как for...of.5. Применение в библиотеках  Символы также используются в современных библиотеках и фреймворках для реализации таких функций, как \"переопределение методов\" и \"расширение интерфейсов\".Заключение  Символы в JavaScript предоставляют способ создания уникальных идентификаторов и помогают избегать конфликтов имен в объектах. Они особенно полезны для создания приватных свойств и методов, а также для определения собственного поведения объектов в конструкциях итерирования.\n",
      "level": "Junior",
      "active": false
    },
    {
      "id": "d729",
      "title": "Генераторы/итераторы?",
      "response": " Генераторы и итераторы — это понятия, связанные с обходом коллекций данных в JavaScript, но они представляют разные концепции.\nИтераторы  Итератор — это объект, который позволяет последовательно обходить коллекцию данных (например, массивы, строки и другие структуры данных). Итераторы реализуют метод next(), который возвращает объект с двумя свойствами: 1. value: текущее значение, которое возвращается итератором. 2. done: логическое значение, которое указывает, завершен ли обход коллекции (если true, это означает, что итерация завершена).Генераторы  Генераторы — это специальный вид функций, который упрощает создание итераторов. Генераторы объявляются с использованием   синтаксиса function* (обратите внимание на звёздочку после function). Генераторы могут использовать ключевое слово yield  для возврата значения. После каждого вызова yield функция приостанавливается, сохраняя свое состояние, и возобновляется   при следующем вызове. Преимущества генераторов 1. Состояние: Генераторы сами управляют своим состоянием, приостанавливая выполнение и продолжая его при каждом вызове next(). 2. Упрощение кода: С помощью генераторов можно легко создавать итераторы без необходимости явно реализовывать интерфейс итератора.\n 3. Ленивая оценка (Lazy Evaluation): Генераторы могут производить значения по мере необходимости, что позволяет экономить память и время.Итераторы и протокол итерации  Протокол итерации определяет стандартный способ обхода объектов в JavaScript. Каждый объект, который реализует протокол итерации, должен иметь метод   Symbol.iterator, который возвращает объект-итератор. Это позволяет использовать конструкции типа for...of.\n\n\n\n\n",
      "level": "Middle",
      "active": false
    },
    {
      "id": "0881",
      "title": "Как работает наследование в JS?",
      "response": " Наследование в JavaScript представляет собой механизм, позволяющий создавать новые объекты на основе существующих, унаследуя их свойства и методы. Этот подход широко используется для организации кода и повторного использования его частей.1. Прототипное наследование  JavaScript использует прототипное наследование. Каждой функции (включая функции-конструкторы) в JavaScript  присваивается свойство prototype, которое указывает на объект, из которого будут унаследованы свойства и методы новых объектов. Когда вы обращаетесь к свойству объекта, JavaScript сначала ищет его в самом объекте, а затем в его прототипах.2. Классы и наследование  С введением ES6 (ECMAScript 2015) в JavaScript был добавлен синтаксис классов, который позволяет более удобно и понятно создавать классы и наследование.  Классы являются синтаксическим сахаром над прототипным наследованием. 3. Прототип и Object.create() Наследование также можно реализовать с помощью функции Object.create(), которая позволяет создавать объект с указанным прототипом.4. Наследование свойств  Наследование в JavaScript также позволяет передавать не только методы, но и свойства: - При создании объекта на основе другого объекта, новый объект может добавлять свои собственные методы и свойства, а также переопределять унаследованные. 5. Ограничения и нюансы  - В JavaScript можно создать объект из другого объекта с помощью прототипного наследования, но все свойства и методы передаются по ссылке. Это означает, что если вы измените метод в родительском объекте, все потомки также получат это изменение. - Если свойство переопределено в дочернем объекте, оно будет скрывать унаследованное свойство (собственное свойство имеет приоритет).\n\n\n\n\n\n",
      "level": "Middle",
      "active": false
    },
    {
      "id": "6f7c",
      "title": "Прототипная модель. Что это? Как организуется родительская цепочка?",
      "response": "1. Прототипы и прототипная цепочка Каждый объект в JavaScript имеет внутреннее свойство [[Prototype]], которое ссылается на другой объект (прототип). Это позволяет создавать цепочку объектов, называемую прототипной цепочкой. - Когда вы обращаетесь к свойству или методу объекта, JavaScript сначала ищет это свойство в самом объекте. Если оно не найдено, JavaScript следует прототипной цепочке, проверяя каждый объект, пока не найдет свойство или не дойдет до конца цепочки (где [[Prototype]] равен null).2. Создание объектов и прототипов  Существует несколько методов создания объектов, которые инициализируют прототипный механизм: 2.1. Создание объекта через литерал  2.2. Конструкторы и new\n Вы можете создавать объекты с помощью функции-конструктора  3. Классовый синтаксис.С введением ECMAScript 2015 (ES6) был введен синтаксис классов, который обеспечивает более удобный способ работы с прототипным наследованием  4. Организация родительской цепочки  Цепочка наследования организуется через свойство prototype. Каждый раз, когда вы создаете объект через конструктор, JavaScript создает внутреннее свойство [[Prototype]], указывающее на prototype конструктора.\n При использовании Object.create() вы явно задаете прототип для нового объекта, в то время как при использовании синтаксиса классов и конструкторов это делается автоматически через prototype. Прототипное наследование позволяет: - Разделять память: При использовании методов, определенных на прототипе, вы экономите память, не создавая копию методов в каждом экземпляре. - Гибкость: Если вы измените метод на прототипе, все экземпляры объектов автоматически получат новое поведение. - Динамическое добавление свойств и методов: Вы можете добавлять свойства и методы к прототипу после создания объектов, и все существующие экземпляры будут иметь доступ к ним.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "d623",
      "title": "Чем отличается __proto__ от prototype?",
      "response": "В JavaScript __proto__ и prototype — это два разных, но связанных понятия, которые касаются прототипного наследования.1. prototype prototype — это специальное свойство, которое существует на функциях-конструкторах. Каждый раз,когда вы создаете объект с помощью конструкции new, объекту будет автоматически присвоено свойство prototype конструктора,из которого он был создан. Это свойство определяет, какие методы и свойства должны быть доступны для экземпляров этого конструктора.- Когда используется?Используется для добавления методов и свойств, которые будут доступны всем экземплярам, созданным с помощью данного конструктора.2. __proto__ __proto__ — это свойство объекта, которое указывает на его прототип. Каждое создаваемое в JavaScript значение (объект) имеет внутреннее свойство [[Prototype]], к которому вы можете получить доступ через __proto__. Это свойство ссылается на объект, из которого были унаследованы  его свойства и методы. Доступ к __proto__ обычно используется для проверки или изменения прототипа объекта во время выполнения.- Когда используется?Используется для получения доступа к прототипу объекта, чтобы проверить, какие методы и свойства объект унаследовал от своего прототипа.Основные отличия:- prototype существует только у функций-конструкторов, а __proto__ существует у всех объектов.- prototype используется для определения свойств и методов, которые будут унаследованы экземплярами, в то время как __proto__ используется для доступа к прототипу существующего объекта.- Придерживайтесь использования prototype для добавления методов к конструкторам, а __proto__ — в основном для поиска или изменения цепочки прототипов (хотя рекомендуется использовать метод bject.getPrototypeOf() и Object.setPrototypeOf() вместо __proto__).",
      "level": "Middle",
      "active": false
    },
    {
      "id": "1894",
      "title": "Как узнать есть ли св-во у объекта или оно находится в цепочке прототипов?",
      "response": "В JavaScript для проверки наличия свойства у объекта и его прототипов есть несколько подходов. Основными методами являются использование оператора in, метода hasOwnProperty, а также метода Object.getOwnPropertyDescriptor. Рассмотрим каждый из них.1. Оператор in Оператор in проверяет, существует ли указанное свойство в объекте или в его цепочке прототипов. Он возвращает true, если свойство найдено, и false, если нет. 2. Метод hasOwnProperty Метод hasOwnProperty проверяет, принадлежит ли данное свойство непосредственно объекту, не обращая внимания на свойства в цепочке прототипов. Он возвращает true, если свойство принадлежит объекту.3. Метод Object.getOwnPropertyDescriptor Этот метод позволяет получить дескриптор свойства для объекта, и его использование может быть полезным для последних проверок свойств. Если свойство не существует, он вернет undefined.4. Сравнение методов - Используйте in, если хотите проверить, существует ли свойство в объекте или его прототипах.- Используйте hasOwnProperty, если вам нужно знать, принадлежит ли свойство непосредственно объекту.- Используйте Object.getOwnPropertyDescriptor, если вам нужно получить информацию о конкретном свойстве.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "b7d5",
      "title": "Сколько может быть прототипов у одного объекта? Какой существует подход для реализации двух прототипов у объекта?",
      "response": "В JavaScript каждый объект имеет свойство [[Prototype]], которое указывает на его прототип, и образует цепочку прототипов.Однако, в JavaScript не существует множественного наследования, поэтому у одного объекта может быть только один прототип. Это свойство родительской цепочки и называется \"прототипное наследование\" (prototypal inheritance).Тем не менее, есть несколько способов реализации поведения, похожего на многопрототипное наследование, хотя  на самом деле это не предполагает истинного множественного наследования, а скорее комбинирование свойств или методик. Вот основные подходы:1. Композиция объектов Вы можете создать несколько объектов с необходимыми свойствами и методами и затем комбинировать их в одном объекте.Например, вы можете использовать функции для создания объектов и добавления методов:2. Использование классов и миксинов В ES6 можно использовать классы и методы, которые можно объединять с помощью простых миксинов.3. Создание объектов с помощью конструкций Object.create() При создании объекта с помощью Object.create() вы можете создать новую цепочку прототипов сверху на старом объекте",
      "level": "Middle",
      "active": false
    },
    {
      "id": "a274",
      "title": "Что делает instanceof? Когда он может быть полезен?",
      "response": "Оператор instanceof в JavaScript используется для проверки, является ли объект экземпляром определённого класса или конструктора. Он возвращает логическое значение (true или false), указывающее, находится ли объект в цепочке прототипов функции-конструктора.1. Проверка типа объектов:- Оператор instanceof позволяет определить, к какому классу или родительскому классу принадлежит объект, что полезно, когда вы работаете с множеством типов объектов.- Например, вы можете использовать его в функциях для проверки, передан ли правильный тип данных.2. Реализация полиморфизма:- При создании объектов, расширяющих другие классы, instanceof может помочь стилю полиморфного поведения, обеспечивая возможность обработки объектов по их классам.3. Проверка пользовательских событий:- В приложениях, работающих с пользовательскими событиями или кастомными объектами, instanceof может помочь в идентификации и обработке этих событий в зависимости от их типа.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "c7e5",
      "title": "Какие типы копируются по ссылке, а какие по значению?",
      "response": "- Примитивные типы (string, number, boolean, undefined, null, symbol и bigint) копируются по значению. - Объекты (включая массивы и функции) копируются по ссылке.Объекты могут быть:1. Object (обычные объекты)2. Array (массивы)3. Function (функции)4. Date (даты)5. RegExp (регулярные выражения)",
      "level": "Junior",
      "active": false
    },
    {
      "id": "8ddf",
      "title": "Разница между == и ===?",
      "response": "1. Нестрогое равенство (==)Оператор == сравнивает значения, выполняя неявное преобразование типов, если типы значений не совпадают.Это означает, что JavaScript попытается привести типы операндов к одному и тому же типу перед сравнением.2. Строгое равенство (===)Оператор === сравнивает значения без выполнения неявного преобразования типов.Это означает, что если типы операндов не совпадают, результат всегда будет false.Всегда используйте ===: В большинстве случаев рекомендуется использовать строгое равенство (===), поскольку оно более предсказуемо и безопасно. Оно поможет избежать неожиданных результатов, которые могут возникнуть из-за неявного преобразования типов.- Оператор == можно использовать в специфических ситуациях, когда нужно учитывать преобразование типов, но такие случаи обычно редки.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "abcc",
      "title": "Как изменить свойство объекта возвращая новый объект? (Object.DefineProperty) ",
      "response": "В JavaScript вы можете использовать метод Object.defineProperty() для изменения или создания свойств объекта. Этот метод позволяет вам определять,как свойства работают, в том числе, делают ли они доступными для записи, перечисления и конфиденциальности.Примечания:- Object.defineProperty() может быть использован для создания свойств, которые могут быть скрыты от перечисления (если установить enumerable: false), или настроены как нерекомендуемые в будущем (если установить configurable: false).- Если вы хотите просто создать новый объект с изменёнными значениями и без необходимости контроля над свойством, более удобным может быть использование стандартного оператора распространения (...) без Object.defineProperty(). Использование Object.defineProperty() нужно, если у вас есть особые требования во время создания или изменения свойств.Альтернативный подход:Если вам не нужно устанавливать специальные параметры для свойства, вы также можете просто создать новый объект, используя оператор распространения",
      "level": "Middle",
      "active": false
    },
    {
      "id": "2b65",
      "title": "Сколько потоков в JavaScript?",
      "response": "JavaScript является однопоточным языком программирования, что означает, что он выполняет операции  последовательно в одном потоке. Это позволяет избежать проблем, связанных с многопоточностью, такими как гонки данных и состояние гонки. Однако, несмотря на однопоточную природу, JavaScript имеет механизмы для асинхронного выполнения кода, что позволяет эффективно обрабатывать операции ввода/вывода  без блокировки выполнения.Основные аспекты однопоточности JavaScript:1. Основной поток: В JavaScript всё выполняется в едином основном потоке, и этот поток отвечает за выполнение всех скриптов, обработку событий и работу с DOM. Это означает, что операции выполняются последовательно, одна за другой.2. Асинхронность через колбэки и промисы: JavaScript позволяет выполнять асинхронные операции, такие как HTTP-запросы или таймеры, через колбэк-функции, промисы и async/await. Хотя сам JavaScript остаётся однопоточным, асинхронное выполнение позволяет эффективно управлять задачами, ожидая завершения операций без блокировки основного потока.3. Event Loop: Этот механизм управляет очередями задач и синхронизацией между асинхронными операциями.Он позволяет JavaScript обрабатывать множество операций, таких как ввод/вывод, события пользователей и таймеры, более эффективно, чем если бы подавляющее большинство операций выполнялось синхронно.4. Web Workers: Хотя JavaScript является однопоточным, есть возможность использовать Web Workers для выполнения операций в фоновом режиме. Web Workers позволяют запускать скрипты в отдельных потоках, что даёт возможность выполнять ресурсоёмкие задачи, не блокируя основной поток. Однако Web Workers имеют свои собственные контексты и не могут напрямую взаимодействовать с DOM.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "365f",
      "title": "Как реализована и работает асинхронность? (В браузере и под капотом)",
      "response": "1. Основные механизмы асинхронности a. Callbacks (колбек-функции) Это самый базовый способ работы с асинхронными операциями. Во время выполнения асинхронного кода вы передаёте функцию (колбек), которая будет вызвана после завершения операции. Когда операция завершена, вызывается колбек с результатами.Promises (промисы) Промисы представляют собой более современный и удобный способ работы с асинхронным кодом, позволяя избавиться от \"адских колбеков\" (callback hell).  Промисы могут находиться в одном из трёх состояний: разрешён (fulfilled), отклонён (rejected) или ожидающий (pending).Async/Await  Cинтаксис async/await основан на промисах, но делает код более читаемым и похожим на синхронный. Объявляя функцию как async, вы можете использовать await, чтобы подождать завершения промиса.2. Event Loop (событийный цикл)a. Как работает Event Loop Event Loop — арбитр между основным потоком, очередями задач (callback queue) и очередями микротасков (microtask queue). Он контролирует выполнение JavaScript, гарантируя, что всё выполняется корректно, не блокируя UI.1. Стек вызовов (Call Stack): Это структура данных, которая хранит функции для выполнения. Когда функция вызывается, она помещается в стек, а когда выполнение заканчивается, она удаляется из стека. 2. Очередь колбеков (Callback Queue): Когда асинхронная операция завершена, её колбек помещается в эту очередь. Как только стек вызовов пуст, Event Loop извлекает колбек из очереди и помещает его в стек для выполнения.3. Очередь микротасков (Microtask Queue): Это специальная очередь для промисов и других микротасков. Все задачи в этой очереди выполняются перед следующей задачей из очереди колбеков. Это означает, что если в процессе выполнения строки кода вы создаёте промис, его колбек будет выполнен до того, как будут обработаны события из очереди колбеков. 3. Под капотом (инфраструктура)В основном, асинхронные операции обрабатываются браузером и его внутренним API, которые взаимодействуют с JavaScript:- API браузера: Многие асинхронные операции (например, HTTP-запросы через fetch, таймеры через setTimeout, работа с событиями) обрабатываются не самим JavaScript, а браузером. Когда вы вызываете fetch, браузер выполняет HTTP-запрос, а JavaScript продолжает выполнение.- Web APIs: Браузеры реализуют такие API, как XMLHttpRequest, fetch, setTimeout и многие другие, которые могут выполнять операции вне основного потока JavaScript.- Программное взаимодействие: Когда завершается асинхронная операция, браузер помещает соответствующий колбек в очередь задач, оповещая Event Loop о необходимости выполнения.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "109d",
      "title": "Чем отличается асинхронность от многопоточности? ",
      "response": "Асинхронность:- Асинхронный подход позволяет программе выполнять операции, не блокируя основной поток выполнения.Например, в JavaScript, когда идет выполнение долгой асинхронной операции (например, HTTP-запрос или таймер), основной поток не останавливается, и код продолжает выполняться.- При завершении асинхронной операции (например, получение ответа от сервера) результат передаётсяобратно (например, через колбек функцию, промис или async/await).- Многопоточность:- Многопоточность предполагает наличие нескольких потоков, которые могут выполняться одновременно.Каждый поток может выполнять свою собственную задачу, что позволяет использовать ресурсы системы более эффективно, особенно на многоядерных процессорах. - Многопоточность позволяет одновременно обрабатывать несколько задач в разных потоках, каждый из которых может взаимодействовать с общим состоянием программы, что приводит к необходимости управления поведением потоков и синхронизации.Асинхронный подход позволит обрабатывать операции без блокировки потока, в то время как многопоточность позволяет выполнять несколько операций одновременно с помощью разных потоков. Важно выбирать подход в зависимости от задачи, размера и требований приложения.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "75f9",
      "title": "Что такое promise? Когда и для чего используется?",
      "response": "Promise (промис) в JavaScript — это объект, представляющий промежуточный результат асинхронной операции. Промисы позволяют работать с асинхронным кодом более структурированно и упрощают обработку успеха или ошибки выполнения операции. Давайте рассмотрим подробнее, что такое промисы, как они работают и когда их использовать.Основные характеристики промисов 1. Состояния:- Ожидающее (Pending): начальное состояние, промис ещё не выполнен и не отклонён.- Разрешённое (Fulfilled): операция завершена успешно. Промис теперь содержит результат выполнения.- Отклонённое (Rejected): операция завершена с ошибкой. Промис содержит причину ошибки.2. Методы:- then(): используется для обработки успешного завершения. Принимает до двух функций: первая выполняется, если промис будет разрешён, вторая — если он будет отклонён (второй обработчик является необязательным).- catch(): используется для обработки ошибок. Вызывается, если промис был отклонён.- finally(): вызывается независимо от результата — как при успешном завершении, так и при ошибке.Когда и для чего используются промисы 1. Асинхронные операции: Промисы особенно полезны для работы с асинхронными вызовами, такими как запросы к API, работа с файловой системой, таймеры и т. д. Они помогают лучше организовать код, избегая \"адов колбеков\".2. Упрощение обработки ошибок: Промисы упрощают обработку ошибок. Ошибки можно перехватывать и обрабатывать централизованно, используя метод catch().3. Цепочка промисов: Промисы позволяют создавать цепочки вызовов через метод then(). Это особенно полезно, если нужно выполнить несколько связанных асинхронных операций последовательно.4. Конкуррентное выполнение: Промисы могут выполняться параллельно с помощью методов, таких как Promise.all(), Promise.race(), что упрощает выполнение нескольких асинхронных операций одновременно.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "e822",
      "title": "В чём разница между стеком вызовов (call stack) и очередью задач (task queue)?",
      "response": "Стек вызовов (call stack) и очередь событий (task queue, также известная как очередь колбеков) — это две ключевые структуры данных в модели выполнения JavaScript, определяющие, как и в каком порядке выполняются функции и обрабатываются события. Давайте рассмотрим их основные различия и функции более подробно.1. Основные понятия a. Стек вызовов (Call Stack) - Описание: Стек вызовов — это структура данных, которая отслеживает текущие выполняемые функции. Он работает по принципу LIFO (Last In, First Out), что означает, что последняя добавленная функция будет выполнена первой.- Что происходит: Когда функция вызывается, она помещается на вершину стека. Когда выполнение функции завершается, она удаляется из стека, и управление передаётся функции, которая была перед ней в стеке.- Использование: Стек используется для управления текущими функциями, их вызовами и возвратами. Он обрабатывает синхронные вызовы и их возвращение.b. Очередь событий (Task Queue)- Описание: Очередь событий — это структура данных, которая хранит функции обратного вызова (callback-функции), ожидающие выполнения. Эти функции обычно связаны с асинхронными событиями, такими как обработка событий, таймеров и результатов API-запросов.- Что происходит: Когда возникает событие (например, завершение промиса или истечение времени таймера), соответствующая колбек-функция помещается в очередь событий. Функции из этой очереди выполняются после того, как стек вызовов станет пустым.- Использование: Очередь событий позволяет осуществлять выполнение асинхронных задач, не блокируя основной поток выполнения. Она гарантирует, что колбеки будут вызываться после завершения текущего синхронного кода. 2. Рабочий процесс - Стек вызовов:- Содержит текущие вызовы функций.- Когда стек пуст, JavaScript начинает извлекать функции из очереди событий.- Очередь событий:- Содержит функции обратного вызова, которые будут выполнены позже.- Когда стек вызовов пуст, JavaScript начинает выполнять функции из очереди событий, перемещая их на верхушку стека вызовов.Как это работает вместе Предположим, у нас есть следующий код:\nconsole.log(\"Start\");\nsetTimeout(() => {\n   console.log(\"Timeout 1\");},\n 0);\nsetTimeout(() => {\n   console.log(\"Timeout 2\");\n}, 0);\nconsole.log(\"End\");\nИсполнение:1. Выполняется console.log(\"Start\");: помещается в стек вызовов, затем выполняется и удаляется.2. Вызывается setTimeout(...), добавляя колбек в очередь событий (колбек помещается в очередь, но сам таймер не блокирует выполнение).3. Выполняется console.log(\"End\");: помещается в стек вызовов, затем выполняется и удаляется.4. Стек вызовов пуст, и JavaScript начинает извлекать колбеки из очереди событий. Сначала выполняется первый колбек из setTimeout(...), выводя \"Timeout 1\", затем \"Timeout 2\".Вывод:Start End Timeout 1 Timeout 2\n4. Важно помнить - Синхронные операции: выполняются в стекe вызовов.- Асинхронные операции: помещают свои колбеки в очередь событий.- Очередь событий обрабатывается только после завершения всех синхронных операций в стеке вызовов.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "6eff",
      "title": "Какие паттерны проектирования вы знаете? Какие из них использовали? Расскажите поподробнее про один из них? (такое синглтон, фабрика, модуль, декоратор,publisher/subscriber)",
      "response": "Паттерны проектирования (или шаблоны проектирования) — это проверенные решения для часто встречающихся проблем в разработке программного обеспечения. Они помогают создавать гибкие, поддерживаемые и легко расширяемые системы. Вот некоторые из наиболее известных паттернов проектирования:1. Одиночка (Singleton) - Обеспечивает наличие только одного экземпляра класса и предоставляет глобальную точку доступа к этому экземпляру.2. Фабрика (Factory) - Определяет интерфейс для создания объектов, но позволяет подклассам изменять тип создаваемых объектов. Существует несколько вариаций, таких как \"Фабричный метод\" и \"Абстрактная фабрика\".3. Модуль (Module)- Группирует полезные функции и переменные в одном объекте, скрывая детали реализации и предоставляя только необходимый интерфейс.4. Декоратор (Decorator)- Позволяет динамически добавлять функциональность объекту, не изменяя его структуру. Это достигается путем обертывания объекта в другой объект.5. Издатель/Подписчик (Publisher/Subscriber)- Определяет взаимосвязь между объектами в виде подписки и уведомления, позволяя объектам взаимодействовать косвенно через события.Пример паттерна: Singleton Описание Паттерн \"Одиночка\" используется, когда необходимо гарантировать, что в системе будет только один экземпляр класса. Это может быть полезно для управления ресурсами, такими как конфигурации, подключение к базе данных или логирование. Пример паттерна: Singleton Описание Паттерн \"Одиночка\" используется, когда необходимо гарантировать, что в системе будет только один экземпляр класса. Это может быть полезно для управления ресурсами, такими как конфигурации, подключение к базе данных или логирование.Этот паттерн часто используется в ситуациях, когда необходимо управлять доступом к общему ресурсу — например, в настройках приложения, настраиваемых через конфигурационные файлы, или при работе с единственным кадровым объектом, который отвечает за управление определенными аспектами приложения.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "04bf",
      "title": "Какие типы модулей вы знаете? (AMD, UMD, CommonJs)",
      "response": "Существует несколько типов модульных систем, которые используются для организации кода в JavaScript. Они обеспечивают решение проблемы \"глобального пространства имен\" и позволяют разделять код на части, чтобы улучшить его структуру и повторное использование. Вот краткий обзор трех основных типов модулей: AMD, UMD и CommonJS.1. AMD (Asynchronous Module Definition)- Описание: AMD - это спецификация, позволяющая загружать модули асинхронно. Эта система часто используется в браузерах.- Преимущества:- Позволяет загружать модули параллельно, что улучшает производительность.- Инъекция зависимостей происходит во время загрузки скриптов.Использование: Часто используется в сочетании с библиотеками, такими как RequireJS.2. CommonJS - Описание: CommonJS - это модульная система, разработанная для серверной среды (например, Node.js). Она использует синхронные вызовы для загрузки модулей.- Преимущества:- Простота работы с модулями, так как код может быть написан на сервере и немедленно загружен.- Возможность использования модулей в Node.js и в некоторых сборщиках (например, Webpack).- Использование: Широко используется в Node.js для создания серверных приложений. 3. UMD (Universal Module Definition)- Описание: UMD - это гибридное решение, которое поддерживает как CommonJS, так и AMD, что позволяет модулю работать в разных средах (как в браузере, так и на сервере).- Преимущества:- Совместимость с различными окружениями: может использоваться как в Node.js (или другой среде, поддерживающей CommonJS), так и в браузерах (с поддержкой AMD).- Упрощает написание универсальных модулей.- Использование: Удобно для библиотек, которые хотят быть использованы в разных средах.Заключение Каждая из этих модульных систем имеет свои преимущества и области применения. CommonJS обычно используется на стороне сервера (например, в Node.js), AMD — на стороне клиента (в браузерах), а UMD позволяет разработчикам создавать универсальные модули, которые могут работать в обоих окружениях. В последние годы с развитием ES-модулей (ES6) разработчики начали использовать стандартные модули как новую альтернативу, которая обеспечивает лучшую совместимость и простоту использования.",
      "level": "Senior",
      "active": false
    },
    {
      "id": "b135",
      "title": "Use strict?",
      "response": " «use strict» — это директива в JavaScript, которая включает строгий режим. Этот режим позволяет выбрать ограниченный вариант JavaScript, который помогает выявить типичные ошибки кодирования и «небезопасные» действия.### Ключевые особенности строгого режима: 1. Устраняет «тихие» ошибки: в строгом режиме ошибки, которые в противном случае были бы проигнорированы, будут вызывать ошибку. Это помогает разработчикам выявлять проблемы на ранних этапах процесса разработки. 2. Запрещает необъявленные переменные. Переменные должны быть объявлены с помощью let, const или var. Присвоение значения необъявленной переменной приведет к ошибке 3. Предотвращает дублирование имен параметров. Функции не могут иметь повторяющиеся имена параметров. Это помогает избежать двусмысленности в аргументах функции. 4.Запрещает эту привязку: в строгом режиме это не определено в функциях, которые вызываются без контекста (т. е. без явного вызывающего объекта). В нестрогом режиме по умолчанию это глобальный объект (в браузерах это окно). 5. Устраняет с помощью оператора: оператор with не допускается в строгом режиме. Это связано с тем, что это может затруднить понимание и поддержку кода. Предотвращает использование определенных зарезервированных ключевых слов. Некоторые имена зарезервированы в строгом режиме, чтобы будущие версии JavaScript не могли использовать эти имена в качестве ключевых слов. ### Как включить строгий режим: — Вы можете включить строгий режим, добавив «use strict» в начале скрипта или функции.ачем использовать строгий режим?\n - Предотвращение ошибок: помогает выявить распространенные ошибки и предотвратить потенциальные проблемы в вашем коде.\n - Улучшена производительность: некоторые механизмы JavaScript могут лучше оптимизировать код в строгом режиме. - Качество кода: способствует улучшению практики кодирования, делая ваш код более чистым и предсказуемым.\n\n\n",
      "level": "Junior",
      "active": false
    },
    {
      "id": "3fcc",
      "title": "Что такое рекурсия и для чего используется?",
      "response": " Рекурсия — это метод, при котором функция вызывает саму себя с целью решения задачи. В рекурсивном подходе задача разбивается на меньшие подзадачи, которые имеют ту же структуру, что и оригинальная проблема, и решаются последовательно. Каждый рекурсивный вызов стремится к достижению базового случая, который завершает рекурсию и возвращает результат.### Принципы рекурсии: 1. Базовый случай (base case): Это условие, при котором рекурсия завершится. Базовый случай предотвращает бесконечные вызовы функции.\n 2. Рекурсивный случай (recursive case): Это часть кода, в которой функция вызывает саму себя с изменёнными аргументами, приближая её к базовому случаю.\n ### Применение рекурсии:\n 1. Решение задач на деление и завоевание: Многие алгоритмы, такие как сортировка слиянием и быстрая сортировка, используют рекурсию для разделения задач на более мелкие подзадачи. 2. Поиск и прохождение по структурам данных: Рекурсия часто используется для работы с деревьями и графами (например, для обхода узлов дерева в глубину). 3. Математические расчёты: Рекурсия применяется для вычисления чисел Фибоначчи, факториалов и других математических последовательностей. 4. Генерация комбинаций и перестановок: Рекурсивные функции могут использоваться для генерации всех возможных комбинаций и перестановок элементов в коллекциях. Преимущества рекурсии: - Структурированность: Рекурсия упрощает код, делая его более читабельным и понятным, особенно при работе со сложными структурами данных. - Упрощение задач: Рекурсия позволяет разбить задачу на подзадачи, что делает её проще для понимания.\n ### Недостатки рекурсии:\n - Производительность: Рекурсивные функции могут потреблять больше памяти и времени, так как каждый вызов функции добавляет новый кадр на стек вызовов. - Глубина стека: Если рекурсия слишком глубока, это может привести к переполнению стека (stack overflow). В таких случаях можно рассмотреть использование итеративных подходов.\n\n\n\n\n\n\n",
      "level": "Junior",
      "active": false
    },
    {
      "id": "ccd1",
      "title": "Что такое замыкания и для чего они используются? ",
      "response": " Замыкание — это функция, которая \"запоминает\" окружающий её контекст (лексическую область видимости), даже после того, как функция была вызвана вне этого контекста. Замыкания позволяют функции иметь доступ к внешним переменным, даже если они находятся вне её текущего контекста выполнения. В JavaScript замыкания создаются всякий раз, когда функция создаётся внутри другой функции.\n ### Принципы замыкания: 1. Лексическая область видимости: В JavaScript функции создают новую область видимости. Замыкания позволяют доступ к переменным из внешней функции, даже после завершения её выполнения.\n 2. Сохранение состояния: Замыкание можно использовать для хранения состояния, которое доступно только при помощи определённого интерфейса. Применение замыканий:\n 1. Инкапсуляция данных: Замыкания позволяют скрывать переменные, избегая их глобального доступа. Это помогает создавать защищённые компоненты или модули.\n 2. Функции-генераторы: Замыкания можно использовать для создания функций, которые хранят и возвращают состояния между вызовами. 3. Кэширование результатов: При помощи замыканий можно создать функции, которые запоминают результаты предыдущих вычислений для оптимизации. 4. Обработка событий: Замыкания помогают захватывать контекст во время работы с обработчиками событий, сохраняя доступ к переменным. Преимущества замыканий:\n - Скрытие реализации: Переменные могут быть скрыты от внешнего доступа, предоставляя только определённый интерфейс. - Динамическое создание функций: Замыкания позволяют создавать функции на лету с сохранением контекста, что удобно для обработки данных.\n ### Недостатки замыканий: - Потребление памяти: Из-за сохранённых ссылок на внешние переменные замыкания могут потреблять больше памяти, чем ожидается, что может привести к утечкам памяти, если они не освобождаются.\n- Сложность отладки: Замыкания могут усложнить понимание логики программы, если используются неаккуратно, что делает код менее понятным\n\n\n\n\n\n",
      "level": "Junior",
      "active": false
    },
    {
      "id": "c921",
      "title": "Блочная видимость переменных",
      "response": "Блочная видимость переменных в JavaScript относится к области видимости, которая ограничена определённым блоком кода, например, внутри фигурных скобок {}. С введением ключевых слов let и const в ES6 (ECMAScript 2015) была добавлена поддержка блочной видимости, которая отличается от функциональной и глобальной видимости, используемой с ключевым словом var.Основные аспекты блочной видимости:1. Определение блочной видимости:- Переменные, объявленные с помощью let или const внутри блока ({}), доступны только внутри этого блока. Попытка обратиться к таким переменным вне их блока вызовет ошибку ReferenceError.2. Область видимости:- Если переменная объявлена с помощью var, она имеет функциональную или глобальную видимость, что означает, что она доступна не только внутри блока, но и вне его, если используется внутри функции.3. Переопределение переменных:- Внутри одного и того же блока переменные с одинаковыми именами, объявленные с let или const, не могут быть повторно объявлены. Это позволяет избежать конфликтов переменных.4. Циклы и блочная видимость:- При использовании переменных, объявленных с let или const, внутри циклов, таких как for, каждая итерация цикла создаёт новую область видимости. Это позволяет избежать общих проблем с замыканиями в циклах. Применение блочной видимости:- Избегание конфликтов переменных: Блочная видимость помогает локализовать переменные и предотвращать их конфликты, особенно в больших кодовых базах или при использовании библиотек.- Ясность и читаемость кода: Использование let и const способствует более чёткой структуре кода, облегчая понимание того, где переменные могут использоваться и изменяться.- Сохранение состояния: Замыкания, использующие блочную видимость, полезны для сохранения состояния в функциях и использования переменных в пределах ограниченного контекста.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "f6f6",
      "title": "Что такое лексическое окружение?",
      "response": "Лексическое окружение (или лексическая область видимости) — это концепция в JavaScript (и в других языках программирования), которая определяет, как и где функции имеют доступ к переменным. Лексическое окружение создаётся всякий раз, когда создаётся контекст исполнения, и оно хранит ссылки на переменные, доступные в момент создания функции. Эта концепция важна для понимания работы замыканий и области видимости переменных.Структура лексического окружения Каждое лексическое окружение состоит из двух компонентов:1. Объект состояния (environment record): Этот объект содержит все переменные и функции, доступные в данной области видимости. В случае функции это будут локальные переменные и параметры.2. Ссылка на внешнее окружение: Это ссылка на лексическое окружение, в котором была создана текущая функция. Эта ссылка позволяет функциям иметь доступ к переменным из внешних областей видимости.Использование лексического окружения - Замыкания: Лексическое окружение позволяет создавать замыкания, которые сохраняют доступ к внешним переменным даже после завершения их функции-родителя. Это является основой многих паттернов программирования в JavaScript, включая инкапсуляцию данных и функции-генераторы.- Область видимости: Понимание лексического окружения помогает объяснить, как работает область видимости переменных, когда мы используем различные способы объявления (например, var, let, const).",
      "level": "Junior",
      "active": false
    },
    {
      "id": "f8ad",
      "title": "Чем отличается push от unshift? Какой из них быстрее?",
      "response": "В большинстве случаев push будет быстрее, чем unshift, особенно для больших массивов. Это связано с тем, что push добавляет элементы в конец массива, что обычно требует меньше операций с памятью, чем unshift, который может потребовать перемещения всех существующих элементов в массиве, чтобы освободить место в начале.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "4c7c",
      "title": "Отличия function expression и function declaration ",
      "response": "2. Подъем (Hoisting)- Function Declaration:- Объявления функций поднимаются в коде, что означает, что вы можете вызывать функцию до того, как она была объявлена.- Function Expression:- Функциональные выражения не поднимаются. Если вы попытаетесь вызвать функцию, определённую как выражение, до её объявления, вы получите ошибку.3. Область видимости- Function Declaration:- Объявление функции создаёт функцию, доступную в области видимости, в которой оно было определено. Если объявление функции находится внутри другого блока, то функция будет доступна в пределах этого блока.- Function Expression:- Выражение функции обычно используется для создания анонимных функций или функций, присваиваемых переменным. Если функция присваивается переменной, она доступна в пределах этой переменной.4. Анонимные функции- Function Expression:- Позволяет создавать анонимные функции, которые не имеют имени. Function Declaration:- Не поддерживает создание анонимных функций. Имя функции всегда должно быть указано.5. Использование в контексте- Function Declaration:- Часто используется для определения функций, которые будут вызываться в разных местах программы, координируя поведение.- Function Expression:- Часто применяется, когда функцией можно передать как аргумент, например, в методах массивов (например, map, filter), при создании коллбеков.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "e714",
      "title": "try/catch и finally?",
      "response": "В JavaScript блоки try, catch, и finally служат для обработки исключений и управления ошибками в коде. Позволяют вам обрабатывать ошибки и гарантируют выполнение определенного кода, независимо от того, возникли ли ошибки или нет. Давайте подробнее рассмотрим их назначение и синтаксис.1. Блок try\n- Описание: Блок try содержит код, который может вызвать исключение. Если в этом блоке происходит ошибка, выполнение переходит к блоку catch.2. Блок catch\n- Описание: Блок catch используется для обработки исключений, которые могут возникнуть в блоке try. Он принимает аргумент, который обычно используется для доступа к объекту ошибки.3. Блок finally - Описание: Блок finally выполняется после блоков try и catch, независимо от того, произошла ошибка или нет. Это полезно для выполнения завершающих операций, таких как освобождение ресурсов (например, закрытие файлов, соединений и т.д.).Важные моменты 1. Обработка ошибок: Использование блоков try и catch позволяет управлять ошибками без остановки выполнения всего скрипта. Это особенно полезно в случаях, когда ошибки могут возникать из-за внешних факторов (например, сетевые запросы).2. Гарантия выполнения: Блок finally гарантирует выполнение кода, даже если в блоке try происходит ошибка или если код завершает выполнение с помощью return или throw.3. Отсутствие необходимости: Блоки catch и finally не являются обязательными. Вы можете использовать блок try без блока catch и только с блоком finally",
      "level": "Junior",
      "active": false
    },
    {
      "id": "583b",
      "title": "Что такое всплытие в JavaScript? Погружение событий? (бамблинг)",
      "response": "В JavaScript обработка событий включает две основные концепции: *всплытие* (event bubbling) и *погружение* (event capturing). Оба этих механизма связаны с тем, как события распространяются через иерархию DOM (Document Object Model).1. Всплытие событий (Event Bubbling)*Всплытие* – это механизм, при котором событие начинается от целевого элемента и постепенно \"всплывает\" вверх по иерархии DOM, вызывая обработчики событий у родительских элементов.2. Погружение событий (Event Capturing)*Погружение* – это противоположный механизм, при котором событие сначала \"погружается\" вниз, начиная с самого верхнего элемента и проходя через все родительские элементы, пока не достигнет целевого элемента.- В JavaScript это поведение не является стандартным, но его можно активировать при добавлении обработчика события, указав третий аргумент true или передав объект с capture: true.Принцип работы событий 1. Сначала происходит погружение (если установлено): Обработчики событий на родительских элементах запускаются перед обработчиком на целевом элементе.2. Целевой элемент: Обработчик на целевом элементе запускается.3. Всплытие: Сначала обрабатываются события на целевом элементе, затем события на его родительских элементах по порядку.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "5fd6",
      "title": "Что нового принес последний стандарт ES? (сейчас ES9)",
      "response": "Стандарт ECMAScript 2018, также известный как ES9, был выпущен в июне 2018 года и внёс несколько интересных новых возможностей в JavaScript. Вот основные новшества, которые были добавлены в ES9:1. Rest/Spread Properties- В ES9 были добавлены возможности для использования rest и spread операторов с объектами.- Spread позволяет вам копировать, объединять или расширять объекты.- Rest позволяет собирать оставшиеся свойства объекта в новый объект.2. Asynchronous Iteration - ES9 добавил возможность использовать синтаксис for await...of для работы с асинхронными итераторами. Это позволяет итерировать по объектам, которые используют AsyncIterable.3. Promise.prototype.finally() - Метод finally() для объектов Promise был добавлен, что позволяет вам обеспечить выполнение кода после завершения промиса, независимо от того, был ли он выполнен успешно или завершился с ошибкой.4. Пробелы между символами в регулярных выражениях (s Flag) - Новый флаг s (dotAll) позволяет методу . в регулярных выражениях соответствовать символам новой строки.5. Обновления в JSON.stringify - В ES9 была улучшена поддержка указания функций для сериализации объектов, что повышает гибкость работы с JSON.stringify.6. Обработка ошибок с try/catch без указания переменной - Можно использовать try/catch без указания переменной для ошибки",
      "level": "Middle",
      "active": true
    },
    {
      "id": "8bf8",
      "title": "В чем суть стрелочной функции? Ее отличия от обычной функции?",
      "response": "1. Лексическое this - Стрелочные функции:- Не имеют своего собственного значения this. Вместо этого они унаследуют значение this от родительского контекста, в котором  они были определены. Это особенно полезно, когда вы используете функции обратного вызова (callback functions).- Обычные функции:- Имеют свое собственное значение this, которое зависит от того, как функция была вызвана.2. Использование arguments - Стрелочные функции:- Не имеют своего собственного объекта arguments. Вместо этого, если вам нужно обратиться к аргументам, вы должны использовать параметры функции или остальную часть оператора (...args).Обычные функции:- Имеют собственный объект arguments, который позволяет получить доступ ко всем переданным аргументам.3.Не могут быть конструкторами - Стрелочные функции:- Нельзя использовать в качестве конструктора — они не поддерживают new, и попытка сделать так вызовет ошибку.Обычные функции:- Можно использовать в качестве конструктора и создавать экземпляры с помощью new.4. Нет super и this - Стрелочные функции:- Не могут использоваться в методах классов для вызова родительских методов, потому что они не имеют собственного контекста.- Если вам нужно использовать super, лучше воспользоваться обычной функцией.5. Синтаксис - Стрелочные функции часто имеют менее громоздкий синтаксис. Если функция принимает один аргумент, скобки можно опустить - Для обычных функций необходимо указывать скобки, даже если аргумент один.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "cd2e",
      "title": "Spread/rest операторы?",
      "response": "Spread и Rest операторы в JavaScript имеют схожий синтаксис, но служат разным целям. Они оба обозначаются тремя точками (...). Давайте рассмотрим их более подробно.Spread оператор (оператор распространения) Spread оператор используется для \"распространения\" элементов массива или объекта на более глубокий уровень. Это позволяет вам развернуть массив или объект, чтобы использовать их элементы или свойства в другом контексте.1. Слияние массивов: const array1 = [1, 2, 3];const array2 = [4, 5, 6];const newArray = [...array1, ...array2]; // [1, 2, 3, 4, 5, 6] 2. Копирование массива:const originalArray = [1, 2, 3];const copiedArray = [...originalArray]; // [1, 2, 3] 3. Передача аргументов в функции:const numbers = [1, 2, 3];const max = Math.max(...numbers);4. Копирование объектов:const obj1 = { a: 1, b: 2 }; const obj2 = { ...obj1, c: 3 }; // { a: 1, b: 2, c: 3 }5. Объединение объектов:  const objA = { a: 1, b: 2 };const objB = { b: 3, c: 4 }; const merged = { ...objA, ...objB }; // { a: 1, b: 3, c: 4 }  Rest оператор (оператор остатка) Rest оператор позволяет собирать оставшиеся параметры функции в массив. Это полезно, когда вы не знаете заранее, сколько аргументов будет передано функции.1. Сбор аргументов в функцию:function sum(...args) { return args.reduce((a, b) => a + b, 0);}console.log(sum(1, 2, 3, 4)); // 10 2. Сбор остальных параметров при   const person = { name: 'Alice', age: 25, location: 'Wonderland' };деструктуризации: const { name, ...rest } = person; // name = 'Alice', rest = { age: 25, location: 'Wonderland' } 3. Использование в методах классов:class Numbers { constructor(...numbers) { this.numbers = numbers;}}const myNumbers = new Numbers(1, 2, 3, 4, 5); // numbers = [1, 2, 3, 4, 5] Заключение - Spread оператор (...) используется для развертывания элементов массивов и объектных свойств.- Rest оператор (...) позволяет собрать несколько аргументов функции в массив, а также используется в деструктуризации для сбора оставшихся свойств объекта.Оба оператора значительно упрощают работу с массивами и объектами в JavaScript, делая код более лаконичным и понятным\n",
      "level": "Junior",
      "active": false
    },
    {
      "id": "e498",
      "title": "Деструктивное присваивание? (...arguments)",
      "response": "Деструктивное присваивание (или деструктуризация) — это удобная синтаксическая конструкция в JavaScript, добавленная в ES6 (ECMAScript 2015), которая позволяет извлекать значения из массивов или объектов и присваивать их переменным. Это упрощает процесс работы с данными и делает код более читабельным.const obj = { name: 'Alice', age: 25 };const { name, age } = obj;Использование с остальными параметрами (...arguments)Остальные параметры (Rest parameters) в сочетании с деструктивным присваиванием позволяют собирать оставшиеся элементы массива или объектные свойства в отдельную переменную.Преимущества деструктивного присваивания 1. Читаемость: Код становится более понятным и компактным.2. Удобство: Упрощает извлечение данных из массивов и объектов, особенно если у вас много значений для извлечения.3. Переименование и пропуск: Позволяет переименовывать переменные и пропускать не нужные элементы без дополнительных строк кода.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "6e3d",
      "title": "Иммутабельность, что это и для чего нужна?",
      "response": "Иммутабельность (или неизменяемость) — это принцип в программировании, который подразумевает, что после создания объекта его состояние не может быть изменено. Вместо этого, всякий раз, когда требуется изменить объект, создается новый объект с необходимыми изменениями, оставляя оригинал без изменений.Зачем нужна иммутабельность?1. Состояние и предсказуемость:- Иммутабельные объекты делают состояние приложения более предсказуемым. Если вы знаете, что объект не изменится, вы можете быть уверены в его значении в любой момент времени. Это упрощает отслеживание изменений и отладку кода.2. Избежание побочных эффектов:- При изменения объектов могут возникать непредвиденные побочные эффекты. Иммутабельность помогает избежать ситуации, когда одна часть кода изменяет объект, который затем используется в другой части кода, что может привести к трудным для понимания ошибкам.3. Улучшение производительности:- В некоторых случаях иммутабельные структуры данных могут быть оптимизированы для более быстрого доступа и сравнения. Например, библиотеки, использующие иммутабельные объекты (такие как Immer), могут эффективно использовать изменения и минимизировать количество операций обновления.4. Упрощение работы с состоянием в реактивных библиотеках:- Во многих современных библиотеках и фреймворках, таких как React, Redux, Vue, иммутабельность является важным аспектом. Заслуживает внимания тот факт, что изменения состояния можно легко отслеживать через сравнение старого и нового состояния, что позволяет упростить процесс рендеринга компонент.Иммутабельные библиотеки.Существуют специальные библиотеки, которые помогают работать с иммутабельными структурами данных, например:- Immutable.js: Предоставляет иммутабельные структуры данных, такие как списки, карты и множества.- Immer: Позволяет писать иммутабельные обновления в более удобном и понятном стиле, реализуя концепцию \"промисканных\" изменений.Иммутабельность — это мощный подход к программированию, который помогает делать код более предсказуемым, безопасным и удобным для обслуживания. Она полезна в большинстве случаев, особенно в функциональных языках программирования и при работе с современными JavaScript-библиотеками и фреймворками.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "14f0",
      "title": "WebRTC",
      "response": "WebRTC (Web Real-Time Communication) — это открытая технология, позволяющая осуществлять реальное время передачи аудио, видео и данных между браузерами и мобильными приложениями без необходимости установки плагинов или дополнительных программ. Она была разработана с целью упрощения создания приложений для видеозвонков, обмена данными и других видов коммуникации в реальном времени.Основные  компоненты WebRTC 1. MediaStream:- Позволяет захватывать аудио и видео с устройств пользователя (например, веб-камеры и микрофона) и передавать эти потоки в реальном времени.2. RTCPeerConnection:- Основной компонент для установления соединения между двумя клиентами. Он управляет потоками медиа и данными, а также обеспечивает сетевые взаимодействия, такие как NAT traversal.3. RTCDataChannel:- Используется для обмена произвольными данными между клиентами. Это может быть полезно для приложений, которые требуют совместной работы, например, игры или обмен файлами.Принципы работы WebRTC 1. Сигнализация:- Для установления соединения между двумя пассажирами необходимо обменяться данными о состоянии соединения, называемыми \"сигнализацией\". Это может включать информацию о сетевых условиях и кодеках. Сигнализация обычно выполняется с использованием таких технологий, как WebSocket или HTTP.2. Наттраверс (NAT Traversal):- WebRTC использует различные протоколы, такие как STUN и TURN, для решения проблемы NAT-траверсинга, позволяя клиентам соединяться друг с другом, даже если они находятся за роутерами или межсетевыми экранами.3. Кодеки:- WebRTC поддерживает современные кодеки для сжатия аудио и видео, такие как VP8, VP9 и Opus. Это помогает оптимизировать качество передачи и уменьшить задержки. Применения WebRTC 1. Видеозвонки и аудиозвонки:- Приложения для видеоконференций, как Zoom, Google Meet и Skype, могут использовать WebRTC для прямой передачи медиа.2. Обмен данными:- WebRTC позволяет обмениваться данными между пользователями, что полезно для приложений, таких как файловые обменники и онлайн-игры.3. Live Streaming:- WebRTC идеален для потоковой передачи, так как обеспечивает минимальные задержки и высокое качество картинки и звука.4. Совместная работа:- WebRTC может быть использован в приложениях для совместной работы, таких как Google Docs, где пользователи могут в реальном времени редактировать документы и видеть изменения других пользователей. Преимущества WebRTC - Простота использования: Веб-разработчики могут легко интегрировать технологию в свои приложения, используя доступные API.- Открытая спецификация: WebRTC является открытым проектом, что позволяет разработчикам использовать его без лицензий и дополнительных затрат.- Безопасность: WebRTC поддерживает шифрование на уровне протоколов (SRTP и DTLS), что обеспечивает высокий уровень безопасности передачи данных.",
      "level": "Senior",
      "active": false
    },
    {
      "id": "ceb9",
      "title": "Где можно сохранить какие либо данные в браузере? Слышали и работали ли вы с indexedDB?",
      "response": "В браузере существует несколько способов для хранения данных. Ниже перечислены основные из них: 1. Local Storage - Описание: Local Storage позволяет сохранять небольшие объемы данных в формате ключ-значение в веб-браузере. Данные сохраняются даже после закрытия вкладки или браузера.- Объем: Ограничен до 5-10 МБ, в зависимости от браузера.- Простой доступ: Можно легко получить доступ к данным с помощью JavaScript 2. Session Storage - Описание: Session Storage аналогичен Local Storage, но данные хранятся только в рамках текущей сессии. Как только вкладка или браузер закрывается, данные удаляются.3. Cookies - Описание: Cookies могут хранить небольшие объемы данных и используют их для управления сессиями и хранения информации о пользователе.- Объем: Ограничен до 4 КБ на одно значение, и в браузере можно хранить до 50-100 cookies.- Срок хранения: Cookies могут иметь срок окончания, после которого они будут удалены.4. IndexedDB - Описание: IndexedDB — это более мощное хранилище, которое позволяет сохранять большие объемы структурированных данных, включая файловые блочные объекты. Это асинхронная база данных, которая позволяет осуществлять сложные запросы.Объем: Зависит от браузера и доступного места на диске, обычно значительно больше, чем Local Storage или Cookies.- Асинхронный доступ: Использует промисы или колбэки для доступа к данным.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "f68b",
      "title": "Чем localStorage отличается от sessionStorage, cookieStorage? В чём преимущества?",
      "response": "Основные отличия 1. Local Storage - Описание: Local Storage хранит данные в формате ключ-значение и сохраняет их без ограничения по времени. Данные остаются даже после закрытия браузера или вкладки.- Объем: Обычно ограничен до 5-10 МБ (в зависимости от браузера).- Доступ: Доступен для всех вкладок tокен одного домена- Применение: Подходит для хранения данных, которые необходимо использовать длительное время (например, настройки пользователя, токены аутентификации и т. д.). 2. Session Storage - Описание: Session Storage также хранит данные в формате ключ-значение, но эти данные существуют только в течение сессии вкладки. При закрытии вкладки данные удаляются.- Объем: Так же ограничен до 5-10 МБ.- Доступ: Доступен только для текущей вкладки; если открыть новую вкладку, доступ к данным уже не будет возможен.- Применение: Удобен для хранения временной информации, например, состояния формы, временные токены или данные, которые не нужно сохранять после закрытия вкладки. 3. Cookies - Описание: Cookies представляют собой небольшие текстовые файлы, которые хранятся на стороне клиента и могут содержать данные в формате ключ-значение. Cookies могут иметь срок действия и могут быть настроены для отправки на сервер с каждым запросом.- Объем: Ограничен до 4 КБ на одно значение, можно хранить 50-100 cookies на домен.- Срок хранения: Cookies могут иметь указанный срок действия, после чего они удаляются автоматически.- Применение: Часто используется для управления сессиями, отслеживания пользователей и работы с аутентификацией.Преимущества каждого метода Local StorageПреимущества:- Данные сохраняются между сессиями и могут быть легко получены из любых вкладок.- Простота использования: API Local Storage прост и понятен.- Более крупный объем для хранения по сравнению с cookies. Session Storage - Преимущества:- Идеален для временных данных: хранит данные только до закрытия вкладки, что делает его отличным выбором для данных, которые не должны сохраняться.- Изоляция данных: данные из разных вкладок не могут быть случайно перезаписаны.Cookies - Преимущества:- Поддержка сервера: Cookies автоматически отправляются на сервер с каждым HTTP-запросом, что делает их полезными для аутентификации и отслеживания сессий.- Возрастающая поддержка: Удобны для работы с обработкой данных на стороне сервера и для управления сессиями.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "f2f4",
      "title": "Можно ли в js вызвать функцию до ее объявления? Как это работает?",
      "response": "Да, в JavaScript можно вызвать функцию до ее объявления, и это возможно благодаря механизму, известному как \"подъем\" (hoisting).Подъем (Hoisting) Hoisting — это механизм, при котором объявления функций и переменных поднимаются на верхнюю часть своей области видимости (scope) в момент компиляции, а не выполнения. Это означает, что JavaScript сначала обрабатывает все объявления, а потом выполняет код.Однако если вы используете функциональное выражение (или стрелочную функцию), то позиция объявления имеет значение. Вот пример с функциональным выражением:Вызов функционального выражения до его объявления sayHello(); // TypeError: sayHello is not a function var sayHello = function() {   console.log(\"Hello, World!\");};В этом случае код выдаст ошибку TypeError, потому что переменная sayHello поднимается, но самой функции присвоено значение только после ее объявления. На момент вызова sayHello() она еще не определена как функция, и её значение равно undefined.Стрелочные функции также поднимаются, как и обычные функции, но поскольку они являются выражениями, они должны быть объявлены до их вызова Таким образом, в JavaScript можно вызвать функции до их объявления, если они были объявлены как функциональные декларации. Однако, если функция объявлена как функциональное выражение или стрелочная функция, вызов до их объявления приведет к ошибке, так как переменная будет подниматься, но не инициализироваться до момента её выполнения.Расскажите об Object.create()Object.create() — это метод в JavaScript, который используется для создания нового объекта, используя другой объект в качестве прототипа. Это позволяет создавать объекты и наследовать свойства и методы от другого объекта.Синтаксис Object.create(prototype, propertiesObject);- prototype: Объект, который будет использован в качестве прототипа для создаваемого объекта.- propertiesObject (необязательный): Это объект, который может содержать дополнительные свойства, которые будут добавлены к создаваемому объекту.Преимущества использования  Object.create() 1. Упрощенное наследование: Этот метод позволяет создавать объекты и наследовать их методы и свойства, что упрощает реализацию прототипного наследования.2. Настройка свойств: Вы можете определить, какие свойства должны быть доступны при создании объекта, например, являются ли они записываемыми, перечисляемыми и удаляемыми.3. Гибкость: Вы можете создать новый объект на основе существующего объекта, модифицируя или добавляя новые свойства, не затрагивая сам прототип.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "ea82",
      "title": "Чем отличается спрэд-оператор от Object.assign? Как быть, если браузер не поддерживает спрэд-оператор?",
      "response": "Спрэд-оператор (...) и метод Object.assign() являются способами копирования и комбинирования объектов в JavaScript, однако у них есть важные отличия в поведении и способах использования. Рассмотрим их подробно:Спрэд-оператор (...) 1. Использование: Спрэд-оператор позволяет \"разворачивать\" объекты (или массивы) и создавать новый объект с помощью указанного объекта. 2. Копирование:Спрэд-оператор делает поверхностную копию объектов. Если вы копируете объект с вложенными объектами, ссылки на вложенные объекты сохраняются:3. Неподдерживаемые свойства:Спрэд-оператор не может быть использован с null или undefined.Object.assign()1. Использование:Object.assign() принимает целевой объект и один или несколько исходных объектов, и копирует все перечисляемые свойства исходных объектов в целевой объект.2. Копирование:Как и спрэд-оператор, Object.assign() делает поверхностную копию. То есть, если в одном объекте есть вложенные объекты, ссылки будут сохраняться 3. Проблемы с целевым объектом:Object.assign() изменяет целевой объект. Если вы укажете существующий объект в качестве целевого, он будет модифицироваться. Что делать, если браузер не поддерживает спрэд-оператор Если в вашем окружении требуется поддержка старых браузеров, которые не поддерживают спрэд-оператор, вы можете использовать Object.assign() как альтернативу, или воспользоваться другим подходом, как, например, использование библиотек, таких как Lodash.Спрэд-оператор и Object.assign() имеют много общего, но важно понимать их различия и предпочитаемые сценарии использования. Если возникнет необходимость в поддержке старых браузеров, использование Object.assign() будет хорошим решением, но помните о необходимости проверки на наличие вложенных объектов при выполнении копирования.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "2c99",
      "title": "Различия var, const и let?",
      "response": "В JavaScript, var, let и const — это ключевые слова, используемые для объявления переменных. Вот основные различия между ними:1. Область видимости (Scope)- var:- Имеет функциональную или глобальную область видимости.- Переменные, объявленные с помощью var, доступны внутри функции, в которой они объявлены, или глобально, если они объявлены вне функции.- let:- Имеет блочную область видимости.- Переменные, объявленные с помощью let, доступны только в том блоке (например, в операторе if, for, и т.д.), где они были объявлены.- const:- Также имеет блочную область видимости.- Точно так же, как и let, переменные, объявленные через const, доступны только в том блоке, где они определены.2. Переназначение (Reassignment)- var:- Разрешает переназначение значения.- let:- Разрешает переназначение значения.- const:- Не позволяет переназначение значения после его первоначального назначения. Однако, если значение — это объект, вы можете изменять его свойства.3. Инициализация - var:- Может быть объявлен без инициализации (т.е. без значения), и его значение по умолчанию будет undefined.- let: - Также может быть объявлен без инициализации, с тем же результатом — значение будет undefined.- const:- Обязательно требует инициализации при объявлении. 4. Дерево всплытия (Hoisting)- var: - Объявления переменных с использованием var \"всплывают\" (hoisted) в верхнюю область видимости функции, но инициализация происходит на месте определения. let и const:\n - Также \"всплывают\", но не могут быть использованы до их объявления в коде (вызовет ReferenceError). - Используйте var, если вам нужна глобальная или функциональная область видимости (но лучше избегать его использования в современном JavaScript). - Используйте let, если вам нужно изменить значение переменной и область видимости — это блок.\n - Используйте const, если значение не должно изменяться и если вы хотите объявить константу в блочной области видимости.\n\n\n\n\n\n",
      "level": "Junior",
      "active": false
    },
    {
      "id": "9f17",
      "title": "Prototype",
      "response": " Прототип — это один из основных механизмов наследования в JavaScript. Он позволяет объектам делиться свойствами и методами друг с другом. Давайте подробнее рассмотрим, как работает система прототипов, и как ее можно использовать в ваших программах.\n1. Основные понятия - Прототип: В JavaScript каждый объект имеет свойство, называемое prototype, которое ссылается на другой объект. Это позволяет объекту наследовать свойства и методы от прототипного объекта. - Прототипное наследование: При попытке доступа к свойству объекта JavaScript сначала ищет это свойство в самом объекте. Если оно не найдено, поиск продолжается в прототипе объекта. Этот процесс может продолжаться до тех пор, пока не будет найдено значение или не будет достигнут конец цепочки прототипов. Цепочка прототипов — это процесс, при котором JavaScript проверяет объект и его прототипы, пока не найдет свойство или не достигнет  конца цепи. Проверка прототипов Вы можете использовать метод isPrototypeOf() для проверки, является ли объект прототипом другого объекта. Прототипы встроенных объектов Встроенные объекты в JavaScript, такие как Array и Function, также используют прототипы. Вы можете расширять эти  объекты, добавляя свои собственные методы в их прототипы.\n Прототипы — это мощный инструмент в JavaScript, который позволяет реализовывать наследование и делиться методами и свойствами между объектами. Понимание системы прототипов поможет вам лучше структурировать ваш код и воспользоваться преимуществами динамической природы JavaScript.\n",
      "level": "Junior",
      "active": false
    },
    {
      "id": "2478",
      "title": "this,call,apply,bind",
      "response": " this - контекст, ссылка на обьект\n call, apply  - методы функции (this, arguments) или (this, [...arguments]) сразу вызываются bind - можно забиндить и вызвать после\n В JavaScript ключевыми концепциями, связанными с контекстом выполнения функций, являются this, а также методы call, apply и bind. Все они позволяют управлять значением this в функциях, и вот как они работают в деталях.\n 1. Значение this this в JavaScript — это специальная переменная, которая ссылается на объект, который в данный момент выполняет код. Значение this может изменяться в зависимости от того, как вызывается функция:\n - В глобальном контексте (вне функции) this ссылается на глобальный объект (в браузере это window).\n - В функции, вызванной в строгом режиме ('use strict'), this будет undefined.\n - В методах объекта this ссылается на объект, к которому принадлежит метод. - В обработчиках событий this ссылается на элемент, на который было нажато.Метод call() Метод call() позволяет вызвать функцию с указанным значением this и аргументами, переданными по отдельности. - Первый аргумент для apply() — это значение this. - Второй аргумент — массив аргументов, которые передаются функции. Метод bind() Метод bind() создает новую функцию, которая, когда вызывается, имеет установленное значение this, а также предустановленные начальные аргументы. - bind() возвращает новую функцию, к которой применяются переданные аргументы. Это полезно, когда вы хотите привязать функцию к определенному контексту, но вы не хотите, чтобы она выполнялась немедленно.Примечания: 1. Строгий режим: в строгом режиме значение this для функции, вызванной без контекста (например, show()), будет undefined, в отличие от нестрогого режима, где это будет ссылка на глобальный объект. 2. Различия между call() и apply(): call() и apply() делают одно и то же, но apply() принимает массив аргументов, в то время как call() принимает их по отдельности.\n 3. Использование bind(): Часто используется для передачи обработчиков событий. Методы call(), apply() и bind() дают возможность гибко управлять контекстом выполнения функции в JavaScript. Понимание этих концепций важно для работы с объектами и функциями, что позволяет предотвращать ошибки, связанные с неправильным значением this.\n\n\n\n",
      "level": "Junior",
      "active": false
    },
    {
      "id": "85ff",
      "title": " const, let, arrow fn, class, шаблонные строки, spread, rest, итератор, генератор ",
      "response": " const и let - ключевые слова let - можно обьявить,присвоить значение позже, также можно переприсвоить\n const - начальное значение нужно, переприсвоить не получится, только обьект или массив const && let - блочной области видимости\n arrow fn(стрелочная функция ) -  () => {} нет своего контекста ,запоминает где была обьявлена, нет методов функций, аргументс,\n более короткая запись, анонимна spread - не глубокое копирование [...spread] || {...spread} rest  - когда мы не знаем сколько у нас аргументов - используем rest ( function(a, ...rest){} ) Генератор - это функция, которая можно запустить приостановить и возобновить на разных стадиях выполнения. Первый вызов функции вызовет итератор, у этого обьекта есть next для возобновления функции. При каждом вызове функция возобновляет свою работу пока не наткнется на yield и опять станет на паузу \n\n",
      "level": "Junior",
      "active": false
    },
    {
      "id": "1d2b",
      "title": "Веб-воркеры и сервис-вореры?",
      "response": " В веб-разработке два типа рабочих процессов, которые часто обсуждаются — это веб-воркеры (Web Workers) и сервис-воркеры (Service Workers). Оба они используются для выполнения фоновых задач, но имеют разные цели и функционал. Давайте разберем каждую из этих технологий по отдельности.Веб-воркеры (Web Workers)\n1. Описание: Веб-воркеры позволяют выполнять скрипты в фоновом режиме, т.е. в параллельных потоках. Это позволяет выполнять тяжелые вычисления без блокировки пользовательского интерфейса. 2. Основные характеристики:\n - Отдельный поток: Веб-воркеры работают на отдельном потоке, что предотвращает блокировку основного потока, в котором работает пользовательский интерфейс. - Ограниченный доступ: Веб-воркеры не имеют доступа к DOM и не могут выполнять действия, требующие интерфейса. Они могут взаимодействовать с основным потоком только через сообщения (используя postMessage()). - Использование: Удобны для выполнения тяжелых вычислений — обработки данных, выполнения фоновых заданий и т.п. Сервис-воркеры (Service Workers) 1. Описание:\n Сервис-воркеры — это специальные скрипты, которые работают между веб-приложением и сетевым сервером. Они служат в качестве прокси-сервера, позволяя перехватывать и обрабатывать сетевые запросы. 2. Основные характеристики: - Кэширование: Сервис-воркеры часто используются для реализации функции, связанной с кэшированием, что позволяет улучшить производительность и пользовательский опыт, особенно в условиях медленного интернет-соединения.\n - Офлайн-режим: Они позволяют приложениям работать офлайн, кэшируя ресурсы.\n - События: Сервис-воркеры работают на основе событий (например, fetch, install, activate). Им нельзя устанавливать свойства напрямую, они могут только реагировать на события. Сравнение 1. Цели: - Веб-воркеры: Основная цель — выполнение фоновых задач, которые не могут блокировать UI. - Сервис-воркеры: Основная цель — управление сетевыми запросами, кэширование ресурсов и реализация офлайн-функциональности. 2. Контекст выполнения: - Веб-воркеры имеют доступ к JavaScript API, но не имеют доступа к DOM. - Сервис-воркеры не имеют доступа к DOM, но могут работать с сетевыми запросами и кэшами.\n 3. Время работы: - Веб-воркеры живут до тех пор, пока они не завершат свои задачи. - Сервис-воркеры могут оставаться активными в фоновом режиме и работать на события.\nЗаключение Веб-воркеры и сервис-воркеры — это мощные инструменты для веб-разработчиков, которые позволяют реализовывать фоновые задачи и управлять сетевыми запросами. Выбор между ними зависит от ваших целей: если вам  нужно выполнить тяжелую вычислительную задачу, используйте веб-воркеры; если же требуется управление кэшированием и работа в офлайн-режиме, вам подойдут сервис-воркеры.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "level": "Middle",
      "active": false
    },
    {
      "id": "afed",
      "title": "Что вы знаете о функциональном подходе?",
      "response": " Функциональный подход (или функциональное программирование) — это парадигма программирования, которая рассматривает вычисления как оценку математических функций и избегает изменения состояния и изменяемых данных. В функциональном программировании функции являются первичными элементами композиции, и сами они рассматриваются как \"первоклассные\" сущности. Давайте рассмотрим основные концепции и принципы функционального программирования более подробно. ### Основные концепции функционального программирования 1. Чистые функции: - Чистая функция — это функция, которая возвращает одно и то же значение при одинаковых входных данных и не имеет побочных эффектов (не изменяет состояния, не взаимодействует с внешним миром, как, например, ввод-вывод). 2. Функции высшего порядка:\n - Это функции, которые принимают другие функции в качестве аргументов или возвращают функции в качестве результата.\n 3. Иммутабельность: - В функциональном программировании предпочтительно избегать изменения состояний и использовать неизменяемые данные. Вместо изменения существует создание новых версий данных. 4. Композиция функций: - Функции могут быть комбинированы для создания более сложных операций. Это позволяет строить цепочки обработки данных. 5. Лямбда-функции или стрелочные функции: - Функции без имени, которые часто используются для передачи как аргументы. 6. Функциональные структуры данных: - Использование структур данных, которые поддерживают функциональные операции, такие как map, filter, и reduce. Преимущества функционального программирования 1. Модульность: Код легче читать и поддерживать, благодаря чистым функциям и разделению задач на отдельные функции.\n 2. Тестирование: Чистые функции проще тестировать, так как их выходные данные зависят только от входных данных. 3. Избежание ошибок: Иммутабельность и отсутствие побочных эффектов уменьшают вероятность ошибок, связанных с изменением состояния программы. ### Недостатки функционального подхода 1. Производительность: Неизменяемость может вести к дополнительным затратам, поскольку при каждом изменении создаются новые объекты. 2. Обучаемость: Для разработчиков, привыкших к императивному программированию, может потребоваться время для привыкания к новым концепциям. 3. Сложность: Композиция функций может привести к сложным и труднопонимаемым конструкциям, если не использовать её осознанно. Функциональный подход к программированию предлагает мощный набор инструментов и методов для создания более чистого, понятного и модульного кода. Использование функционального программирования может значительно улучшить определенные аспекты разработки, особенно в сложных приложениях. Существует много языков программирования, которые поддерживают функциональный стиль (например, Haskell, Scala, Clojure) и многие языки общего назначения, такие как JavaScript, Python и Ruby, также предоставляют возможности для функционального программирования. \n\n\n\n\n\n\n\n\n\n\n\n",
      "level": "Middle",
      "active": false
    },
    {
      "id": "4928",
      "title": "Что такое чистая функция? Является ли функция делающая запрос чистой?",
      "response": " Чистая функция — это функция, которая выполняет определенные математические принципы и обладает следующими ключевыми свойствами: 1. Детерминированность: Чистая функция всегда возвращает одно и то же значение при одинаковых входных параметрах. То есть, если вы вызываете функцию с одними и теми же аргументами, вы всегда получите один и тот же результат. 2. Отсутствие побочных эффектов: Чистая функция не вызывает побочных эффектов, что означает, что она не изменяет состояние внешних данных и не взаимодействует с внешним миром (например, не изменяет глобальные переменные, не выполняет операции ввода/вывода, такие как изменение содержимого HTML, вывод в консоль, сетевые запросы и т. д.). Является ли функция, делающая запрос, чистой? Функция, выполняющая сетевой запрос (например, с помощью fetch в JavaScript) не является чистой функцией по следующим причинам: 1. Побочные эффекты: Когда функция выполняет сетевой запрос, она взаимодействует с внешней средой (сервером), и результат этого взаимодействия может изменять состояние приложения. Например, вы получите данные от сервера, которые могут изменять отображаемое состояние UI. 2. Недетерминированность: При одинаковых входных параметрах функция может возвращать разные значения, так как результат сетевого запроса может изменяться в зависимости от состояния сервера или базы данных в момент запроса. Чистые функции являются важной концепцией в функциональном программировании, так как они способствуют более предсказуемому и тестируемому коду. Напротив, функции с побочными эффектами, такие как сетевые запросы, усложняют процесс тестирования и предсказуемости, и их часто нужно отдельно обрабатывать или использовать другие подходы для их тестирования.\n\n\n",
      "level": "Junior",
      "active": false
    },
    {
      "id": "e2f9",
      "title": " Мемоизация функции? ",
      "response": " Мемоизация — это техника оптимизации, которая заключается в сохранении результатов вызовов функций с одинаковыми аргументами, чтобы избежать повторных вычислений. Эта техника особенно полезна для функций, выполнение которых достаточно затратное и которые часто вызываются с одинаковыми аргументами. #### Принципы работы: 1. При первом вызове функции с определёнными аргументами результат вычисления сохраняется (кэшируется). 2. При последующих вызовах с теми же аргументами функция сразу возвращает закэшированный результат, не выполняя вычисление повторно. Преимущества мемоизации:\n - Уменьшение времени выполнения программы за счёт избежания повторных вычислений для одинаковых аргументов.\n - Повышение общей производительности приложения, особенно если функции затратные по ресурсам. ### Недостатки: - Увеличение потребления памяти для хранения кэшированных результатов.\n - Эффективность мемоизации зависит от характера входных данных и частоты повторных вызовов функции. Таким образом, чистые функции и мемоизация — это ключевые концепции в функциональном программировании, которые позволяют создавать более оптимизированные и предсказуемые программы.\n\n\n\n\n\n\n",
      "level": "Junior",
      "active": false
    },
    {
      "id": "83c8",
      "title": "Понятие каррирования функции?",
      "response": " Каррирование — это техника, используемая в функциональном программировании, которая превращает функцию, принимающую несколько аргументов, в последовательность функций, каждая из которых принимает один аргумент. Это позволяет вызывать функцию поэтапно, передавая аргументы по одному.\n ### Принципы каррирования 1. Преобразование аргументов: Функция с несколькими аргументами, например, f(a, b, c), может быть преобразована в цепочку функций так, что первая функция принимает аргумент a, возвращает функцию, которая принимает аргумент b, и так далее, пока не будут введены все аргументы. Преимущества каррирования\n 1. Улучшение модульности: Каррирование позволяет создавать более гибкие и переиспользуемые функции за счет частичного применения. 2. Читаемость кода: Код может стать более читаемым, когда функции могут быть вызваны с одним аргументом. 3. Легкость тестирования: Меньшие и более простые функции легче тестировать. ### Недостатки 1. Сложность: Каррирование может усложнить код, особенно для программистов, не знакомых с этой концепцией. 2. Производительность: В некоторых случаях каррированные функции могут быть менее производительными из-за дополнительных вызовов функций.\n",
      "level": "Junior",
      "active": false
    },
    {
      "id": "f1bb",
      "title": " Чем отличаются способы обработки ошибок для async/await и promises?",
      "response": " Обработка ошибок в JavaScript может быть выполнена как с использованием Promise, так и с использованием синтаксиса async/await. Хотя оба подхода работают  с асинхронными операциями, есть различия в способах обработки ошибок для каждого из них.Promise  При использовании Promise, ошибки обрабатываются с помощью методов catch() и then()  Отличия при обработке ошибок с использованием Promise:\n 1. Цепочка вызовов: Ошибки могут быть обработаны через цепочку функций then(), что позволяет обрабатывать ошибки на разных уровнях цепочки.\n 2. Использование catch(): Метод catch() обрабатывает ошибки, возникающие в любом месте предыдущих методов then(). Это делает обработку ошибок ясной и централизованной.Async/Await При использовании синтаксиса async/await, обработка ошибок осуществляется с помощью блока try/catch. Отличия при обработке ошибок с использованием async/await: 1. Синтаксическая простота: Синтаксис try/catch более привычен и похож на синхронный код, что делает его более читаемым и управляемым. 2. Локализация ошибок: Блоки try/catch локализуют обработку ошибок, позволяя обрабатывать их только для конкретных частей кода, что может быть полезно, если у вас есть несколько отдельных асинхронных операций. В итоге, оба подхода имеют свои преимущества. Promise более декларативный и подходит для простых случаев, тогда как async/await делает код более читабельным и управляемым, особенно для более  сложных асинхронных операций. Используйте тот подход, который лучше подходит для вашей ситуации и стиля разработки.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "f1f9",
      "title": "Глубокое и неглубокое копирование объектов?",
      "response": " В JavaScript существует две основные техники копирования объектов: глубокое копирование (deep copy) и неглубокое копирование (shallow copy). Эти два метода отличаются тем, как они обрабатывают вложенные объекты и массивы. Неглубокое копирование (Shallow Copy) Неглубокое копирование создает новый объект, копируя свойства (ключи и значения) исходного объекта на верхнем уровне. Если объект содержит вложенные объекты, то их ссылки копируются, а не сами объекты, поэтому изменения во вложенных объектах в исходном объекте будут отражаться и в его копии. С помощью Object.assign() С помощью операторов расширения (spread operator) Глубокое копирование (Deep Copy) Глубокое копирование создает новую копию объекта, включая все вложенные объекты. Все свойства и их значения копируются рекурсивно. Таким образом, изменения в копии не отражаются на оригинальном объекте и наоборот. 1. С использованием JSON.parse() и JSON.stringify() Этот метод работает, но имеет ограничения: он не может копировать функции, undefined, специальные объекты (например, Date, Map, Set) и незначительно теряет типовые данные.\n 2. С использованием библиотек Выбор метода копирования\n - Неглубокое копирование: подходит, если вы работаете с плоскими объектами или не собираетесь изменять вложенные объекты. Это быстро и просто. - Глубокое копирование: необходимо использовать, если вам нужно избежать изменений в вложенных объектах оригинала. Этот метод более ресурсоемкий и может требовать дополнительных библиотек. Выбор между глубоким и неглубоким копированием зависит от ваших задач и структуры данных. Неглубокое копирование удобно для простых структур данных, тогда как глубокое копирование необходимо для работы с сложными и вложенными объектами.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "633e",
      "title": " Какие коллекции в JavaScript вы знаете? С какими работали? Приведите пример  использования и основные плюсы какой либо коллекции? (Set, Map, WeakSet и  WeakMap)  ",
      "response": " 1. Array (Массивы)\n 2. Set (Множества)\n 3. Map (Отображения)\n 4. WeakSet (Слабые множества)\n 5. WeakMap (Слабые отображения)\n1. Set  Set представляет собой коллекцию уникальных значений, при этом порядок следования элементов сохраняется. Значения могут быть любого типа, включая объекты. Если вы пытаетесь добавить дубликаты, они будут проигнорированы.\n Плюсы:\n - Легкость в помощи уникальности значений.\n - Быстрые операции добавления, удаления и проверки наличия элементов (приблизительно O(1)).\n - Возможность итерироваться по значениям в порядке их добавления. 2. Map Map — это коллекция, которая сохраняет пары \"ключ-значение\". В отличие от обычных объектов, где ключи являются строками или символами, в Map ключи могут быть любого типа, включая объекты. Плюсы:\n - Удобно использовать в качестве структуры данных для хранения ассоциативных массивов.\n - Поддерживает любые типы ключей. - Позволяет сохранять порядок вставки элементов. ### 3. WeakSet\n WeakSet — это коллекция, которая похожа на Set, но позволяет хранить только слабые (слабые ссылки) на объекты. Это значит, что если объект, который хранится в WeakSet, больше нигде не используется, он может быть удалён сборщиком мусора. Плюсы: - Поддержка автоматического управления памятью, так как объекты могут быть автоматически удалены, если на них нет других ссылок. - Можно использовать для хранения временных объектов. ### 4. WeakMap WeakMap — это коллекция, которая также хранит пары \"ключ-значение\", где ключом может быть только объект, а значения могут быть любого типа. WeakMap также использует слабые ссылки на ключи, благодаря чему объекты могут быть собраны сборщиком мусора. Плюсы:\n - Сильные преимущества в управлении памятью: объекты-ключи могут быть удалены сборщиком мусора, когда на них нет других ссылок. - Полезно для хранения данных, связанных с объектами, не мешая сборщику мусора. Каждая из коллекций имеет свое место в JavaScript и может использоваться в зависимости от задач. Лично я работал с такими коллекциями, как Set и Map, и на практике они были полезными при решении задач, связанных с уникальностью данных и ассоциативными массивами. Например, Set отлично подошёл для фильтрации дубликатов в массиве при обработке данных из API, а Map — для хранения пар \"ключ-значение\", что сделало код более читабельным и простым в поддержке. ",
      "level": "Junior",
      "active": false
    },
    {
      "id": "eb9b",
      "title": " Какие есть базовые события JS (Генерация событий на элементах) ",
      "response": " В JavaScript существует множество базовых событий, которые можно прослушивать и обрабатывать в элементах DOM. Под событиями понимаются определенные действия или изменения состояния, которые происходят на веб-странице и могут быть перехвачены и обработаны с помощью обработчиков событий. Вот некоторые из основных типов событий, которые чаще всего используются в JavaScript: ### 1. События работы с мышью- click: Срабатывает, когда элемент нажимается мышью.\n- dblclick: Срабатывает при двойном щелчке по элементу.\\n\n- mousedown: Срабатывает, когда кнопка мыши нажата на элементе.\\n\n- mouseup: Срабатывает, когда кнопка мыши отпускается над элементом.\\n\n- mouseover: Срабатывает, когда курсор мыши проходит над элементом.\\n\n- mouseout: Срабатывает, когда курсор мыши уходит с элемента.\\n\n### 2. События работы с клавиатурой\\n\n- keydown: Срабатывает, когда клавиша нажата.\\n\n- keyup: Срабатывает, когда клавиша отпущена.\\n\n- keypress: Срабатывает при нажатии клавиши, которая генерирует символ (устаревшее, лучше использовать keydown и keyup).\\n\n### 3. События фокуса\\n\n- focus: Срабатывает, когда элемент получает фокус (например, текстовое поле).\\n\n- blur: Срабатывает, когда элемент теряет фокус.\\n\n### 4. События работы с формами\n- submit: Срабатывает при отправке формы.\n- change: Срабатывает, когда значение элемента формы изменено и потерян фокус.\n- input: Срабатывает, когда значение элемента ввода изменяется. (Поддерживает более широкий диапазон событий, чем change).\n### 5. События касания (для мобильных устройств)\n- touchstart: Срабатывает, когда палец касается экрана.\n- touchmove: Срабатывает, когда палец перемещается по экрану.\n- touchend: Срабатывает, когда палец отпускается от экрана.\n### 6. События загрузки\n- load: Срабатывает, когда объект (например, изображение, страница, скрипт) завершает загрузку.\n- DOMContentLoaded: Срабатывает, когда первоначальная HTML-страница была полностью загружена и разобрана, не дожидаясь завершения загрузки стилей, изображений и всех подресурсов.\n- beforeunload: Срабатывает перед тем, как пользователь покинет текущую страницу.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "03da",
      "title": " Поднятие переменных в ES5 что это?  ",
      "response": " Поднятие переменных (hoisting) в JavaScript — это механизм, при котором переменные и функции \"поднимаются\" в начало их контекста выполнения (scope), что позволяет им использоваться до их объявления в коде. Обычно это относится к переменным, объявленным с помощью var, а также к объявлениям функций.\\n\n ### Как работает поднятие переменных:\\n\n 1. Объявления переменных:\\n\n Когда JavaScript интерпретирует код, он сначала проходит через этап создания контекста выполнения и поднимает все объявления переменных. При этом поднимаются только объявления, но не инициализации (присваивания).\\n\n 2. Объявления функций:\\n\n Функции объявляются во время подъема полностью, поэтому они могут быть вызваны до их объявления.\n Поднятие функций:\\n\n Функции также поднимаются, но полное определение функции переносится в верхнюю часть ее области видимости\n В данном примере мы можем вызвать myFunction() до ее фактического объявления в коде, и это работает, потому что объявление функции поднимается.\\n\n ### Важное отличие для let и const:\\n\n С введением let и const в ES6 ситуация изменилась. Объявления с использованием let и const также поднимаются, но они не инициализируются до фактического присвоения значений, и доступ к ним раньше вызовет ошибку ReferenceError.\n Поднятие переменных в JavaScript может вызывать путаницу, особенно для начинающих разработчиков. Пониженное значение переменной (undefined), когда оно вызывается до присвоения, может привести к ошибкам в коде. Рекомендуется всегда объявлять переменные перед их использованием, чтобы избежать недопонимания и потенциальных ошибок.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "af9e",
      "title": " Функции первого класса",
      "response": " В JavaScript функции являются первоклассными объектами (first-class objects), что означает, что функции могут рассматриваться и использоваться так же, как и другие значения. Это позволяет выполнять множество интересных операций с функциями. Давайте рассмотрим, что именно это означает и какие возможности оно предоставляет.\n ### Что значит \"функции первого класса\"?\\n\n 1. Присвоение переменным: Вы можете присваивать функции переменным.\\n\n 2. Передача как аргументы: Вы можете передавать функции в другие функции в качестве аргументов.\\n\n 3. Возврат из других функций: Вы можете возвращать функции из других функций.\\n\n 4. Создание и хранение: Вы можете создавать функции динамически и хранить их в структурах данных, таких как массивы или объекты.Функции можно хранить в массивах и начинать их с выполнения в программном коде.\\n\n ### Преимущества функций первого класса\\n\n 1. Высокая гибкость: Легко создавать составные функции и функции высшего порядка (higher-order functions).\\n\n 2. Упрощение кода: Повышает читаемость и сокращает количество кода за счет использования обратных вызовов (callbacks).\\n\n 3. Создание замыканий: Функции могут захватывать окружение (scope), что позволяет создавать замыкания.\\n\n\n ### Заключение\\n\n Функции первого класса в JavaScript предоставляют мощные инструменты для разработки. Они позволяют программистам использовать функции так же, как и другие данные, и это открывает множество возможностей для более эффективного и абстрактного программирования. Понимание этого\n концепта является важной частью работы с языком и способствует созданию более чистого, модульного и переиспользуемого кода.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "ff1b",
      "title": " Как восстановить контекст this?",
      "response": " В JavaScript контекст this — это важная концепция, которая определяет, на какой объект ссылается код в пределах функции. В зависимости от того, как вызывается функция, контекст this может меняться. Однако иногда возникает необходимость установить или восстановить желаемый контекст для функции. Здесь рассмотрим несколько способов этого добиться.\\n\n ### 1. Использование call, apply и bind\\n\n JavaScript предоставляет методы, такие как call, apply и bind, которые позволяют явно установить контекст this.\\n\n #### a. call()\\n\n Метод call() вызывает функцию с заданным значением this и аргументами, переданными по отдельности.\n b. apply()\\n\n Метод apply() работает аналогично call(), но принимает аргументы в виде массива.\n c. bind()\\n\n Метод bind() создает новую функцию, которая, при вызове, имеет установленный контекст this. Она также может принимать аргументы, которые будут переданы в новую функцию.\n 2. Стрелочные функции\\n\n Стрелочные функции захватывают значение this из окружающего контекста во время создания. Это означает, что this внутри стрелочной функции будет равно this родительской функции, где она была объявлена.\n важно понимать, как работает контекст this в JavaScript, а также как его можно устанавливать и восстанавливать в различных ситуациях. Используя методы call, apply, bind, стрелочные функции и правильные конструкции классов, вы сможете контролировать контекст this в вашем коде. Это поможет избежать распространенных ошибок и сделать ваш код более предсказуемым и стабильным.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "d56f",
      "title": " Можно ли разбиндить контекст",
      "response": " Да, можно \"восстановить\" или \"разбиндить\" контекст this в JavaScript, используя различные методы\n. Когда вы работаете с функциями, особенно с методами объектов и функциями\n обратного вызова, контекст this может меняться. Вот несколько способов управления контекстом this в JavaScript\n Способы восстановления контекста this\\n\n 1. Использование bind():\\n\n Метод bind() создает новую функцию, которая при вызове имеет установленное значение this, равное переданному значению.\n 2. Использование call() и apply():\\n\n Эти методы позволяют вызывать функцию с заданным контекстом this. call() принимает аргументы через запятую, а apply() принимает массив аргументов.\n 3. Стрелочные функции:\\n\n Стрелочные функции не имеют своего собственного this. Они берут this из родительского контекста, в котором они были определены.\n Разбиндить контекст this\\n\n В JavaScript нет встроенного способа \"разбиндить\" контекст this в функции, которая была связана с использованием bind(). Однако вы можете обойти это ограничение путем создания новой функции без привязки.\\n\n Для этого можно использовать одну из следующих стратегий:\\n\n 1. Создание новой функции:\\n\n Если у вас есть функция с привязанным контекстом, и вы хотите вызвать ее с обычным контекстом, просто создайте новую функцию, используя ее объявление без привязки.\\n\n 2. Использование обычного вызова:\\n\n Вы можете просто вызвать функцию без контекста, и this будет равен глобальному объекту (в браузере — window, в Node.js — global) или undefined в строгом режиме.\n Управление контекстом this — это важная часть JavaScript, особенно при работе с объектами и функциями обратного вызова. Используя методы bind(), call(), и apply(), а также стрелочные функции, можно эффективно управлять контекстом. Обратите внимание, что \"разбиндить\" контекст в прямом смысле невозможно, но можно вызвать функцию в контексте, где this не привязан, создавая новую функцию без привязки.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "f7e1",
      "title": " Два подхода к обработке событий в DOM(onevent,addEventListener).Пользовательские события.Стадии прохода события",
      "response": " События в JS - погружение и всплытие\\n\n 1.onEvent - можно на элемент накинуть событие onClick\\n\n 2.addEventListener - вешаем на элемент, далее пока не отпишемся через removеEventListener\\n\n element.addEventListener('событие (click)', функция которая наблюдает за событием (() => {}))\\n\n Пользовательские события - \\n\n new Event(”клик”, [опции]) опции - bubbles - true/false всплытие \\n\n eanaeleble true/false \\n\n composed-событие будет вставать за пределы shadow DOM метод dispatchEvent запускает событие на элемент(http://8.web/)\n Стадии события\\n\n  1.погружение только addEventListener\\n\n 2.целевая фаза-все\\n\n 3.фаза всплытие - с add по capture \\n",
      "level": "Junior",
      "active": false
    },
    {
      "id": "146c",
      "title": " Web Worker ",
      "response": " Ассинхронная система позволяет выполнять тяжелые в вычислительном плане и длительные задачи\\n\n без блокировки потока пользовательского интерфейса. При их использовании вычисления идут параллельно.\\n\n Это своего рода многопоточность. Web Workers - не являются частью JS, они представляют собой возможность браузера,\\n\n к которой можно получить доступ посредством JS - new Worker() - они должны быть в отдельном файле ,воркеры\\n\n выполняются в изолированных потоках  в браузере\\n\n Для запуска - worker.postMessage() для отправки в основной поток   (DOM && Window -  для них недоступны)\\n\n onMessage слушатель в основном потоке для получения сообщений от воркера terminate() завершает работу воркера \\n",
      "level": "Middle",
      "active": false
    },
    {
      "id": "e81e",
      "title": " В чем отличие вебсокетов от пулинга",
      "response": " Веб-сокеты и пуллинг (polling) — это два разных подхода для реализации взаимодействия между клиентом и сервером в веб-приложениях, особенно для работы в режиме реального времени. Давайте рассмотрим их основные отличия.\\n\n ### 1. Определение\\n\n - Веб-сокеты:\\n\n Веб-сокеты — это протокол, который обеспечивает постоянное соединение между клиентом и сервером. Он позволяет обмениваться данными в обоих направлениях (двусторонняя связь) без необходимости повторного запроса. После установления соединения с помощью веб-сокета оно остается открытым, что позволяет обмениваться сообщениями мгновенно.\\n\n - Пуллинг:\\n\n Пуллинг — это подход, при котором клиент периодически отправляет запросы на сервер с целью проверки наличия обновлений или новых данных. Это можно реализовать как \"опрос\" (long polling) или короткий опрос (short polling). В первом случае клиент отправляет запрос, и сервер не отвечает, пока у него не появятся новые данные, а затем клиент сразу же отправляет следующий запрос. В случае короткого опроса клиент отправляет запросы через фиксированные промежутки времени.\\n\n ### 2. Эффективность и производительность\\n\n - Веб-сокеты:\\n\n - Более эффективны, так как они требуют меньше ресурсов, чем пуллинг.\\n\n - После установления соединения обмен данными происходит без задержек, и не нужно каждый раз повторно устанавливать соединение.\\n\n - Минимальное использование пропускной способности, так как отсутствуют накладные расходы на заголовки HTTP (в отличие от обычных запросов).\\n\n - Пуллинг:\\n\n - Может потреблять больше ресурсов, так как клиент не может предсказать, когда сервер будет готов отправить обновления. Поэтому он может отправлять много запросов, даже когда нет новых данных.\\n\n - Задержка между запросами может приводить к большему времени ожидания перед тем, как клиент получит данные, что делает его менее эффективным.\\n\n ### 3. Поддержка технологий\\n\n - Веб-сокеты:\\n\n - Используют протокол WebSocket и могут работать во всех современных браузерах, поддерживающих этот протокол.\\n\n - Предоставляют поддержку для большого количества клиентов одновременно.\\n\n - Пуллинг:\\n\n - Поскольку основан на XMLHttpRequest (или Fetch API), он поддерживается повсеместно и не требует встраивания \n дополнительных протоколов.\\n\n - Простой в реализации, но не столь эффективен для больших объемов данных или частых обновлений.\\n\n ### 4. Примеры использования\\n\n - Веб-сокеты:\\n\n - Чат-программы, игры в реальном времени, биржевые приложения, где необходима высокая частота обновлений.\\n\n - Пуллинг:\\n\n - Сайты с реже обновляемыми данными, где не критично, чтобы обновления приходили с минимальной задержкой\n  (например, новостные агрегаторы).\\n\n ### Заключение\\n\n Веб-сокеты и пуллинг имеют свои преимущества и недостатки, и выбор между ними зависит от конкретных\n требований приложения. В большинстве случаев, если требуется высокая производительность и минимальная задержка при обмене данными, веб-сокеты являются предпочтительным \n вариантом. Пуллинг может быть хорошим вариантом для простых приложений или где постоянное соединение не требуется.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "075a",
      "title": "Какие операторы в JavaScript знаете?",
      "response": " В JavaScript существует множество операторов, которые могут быть классифицированы на несколько категорий. Вот основные из них:\\n\n ### 1. Арифметические операторы\\n\n Эти операторы используются для выполнения математических операций:\\n\n - + (Сложение)\\n\n - - (Вычитание)\\n\n - * (Умножение)\\n\n - / (Деление)\\n\n - % (Остаток от деления)\\n\n - (Возведение в степень, ES6)\\n\n ### 2. Операторы присваивания\\n\n Эти операторы используются для присвоения значений переменным:\\n\n - = (Простое присваивание)\\n\n - += (Прибавить и присвоить)\\n\n - -= (Вычесть и присвоить)\\n\n - *= (Умножить и присвоить)\\n\n - /= (Разделить и присвоить)\\n\n - %= (Взять остаток и присвоить)\\n\n - = (Возвести в степень и присвоить)\\n\n ### 3. Операторы сравнения\\n\n Эти операторы используются для сравнения значений:\\n\n - == (Равенство)\\n\n - === (Строгое равенство)\\n\n - != (Неравенство)\\n\n - !== (Строгое неравенство)\\n\n - > (Больше)\\n\n - < (Меньше)\\n\n - >= (Больше или равно)\\n\n - <= (Меньше или равно)\\n\n ### 4. Логические операторы\\n\n Эти операторы используются для выполнения логических операций:\\n\n - && (Логическое И)\\n\n - || (Логическое ИЛИ)\\n\n - ! (Логическое НЕ)\\n\n### 5. Побитовые операторы\\n\n Эти операторы работают на уровне битов:\\n\n - & (Побитовое И)\\n\n - | (Побитовое ИЛИ)\\n\n - ^ (Побитовое исключающее ИЛИ)\\n\n - ~ (Побитовое НЕ)\\n\n - << (Сдвиг влево)\\n\n - >> (Сдвиг вправо)\\n\n - >>> (Сдвиг вправо с заполнением нулями)\\n\n ### 6. Унарные операторы\\n\n Эти операторы работают с одним операндом:\\n\n - + (Унарный плюс, преобразует в число)\\n\n - - (Унарный минус, преобразует в число и меняет знак)\\n\n - ++ (Инкремент)\\n\n - -- (Декремент)\\n\n - typeof (Возвращает тип переменной)\\n\n - delete (Удаляет свойство из объекта)\\n\n ### 7. Оператор запятой\\n\n - , (Используется для отделения выражений, возвращает последнее выражение)\\n\n ### 8. Оператор условия (тернарный оператор)\\n\n - ? : (Упрощенная форма условия. condition ? expr1 : expr2)\\n\n ### 9. Оператор \"new\"\\n\n - new (Создает новый объект)\\n\n ### 10. Оператор \"instanceof\"\\n\n - instanceof (Проверяет, является ли объект экземпляром определенного конструктора)\\n\n ### 11. Оператор \"in\"\\n\n - in (Проверяет, существует ли свойство в объекте)",
      "level": "Junior",
      "active": false
    },
    {
      "id": "451c",
      "title": "Как перебрать в цикле все свойства объекта?",
      "response": " 1. Использование for...in\n Цикл for...in позволяет перебрать все перечисляемые свойства объекта, включая унаследованные свойства.\n 2. Использование Object.keys()\\n\n Метод Object.keys() возвращает массив собственных перечисляемых свойств объекта (без унаследованных) и позволяет использовать стандартный метод перебора массивов.\n 3. Использование Object.entries()\\n\n Метод Object.entries() возвращает массив пар ключ-значение, которые также можно перебрать.\n 4. Использование Object.values()\\n\n Метод Object.values() возвращает массив значений собственных перечисляемых свойств объекта. Его можно использовать вместе с циклом.\n 5. Использование forEach с Object.keys()\\n\n Это способ использовать методы массивов с массивом ключей.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "0281",
      "title": "Как работает setTimeout, setInterval? Что возвращают?",
      "response": " В JavaScript функции setTimeout и setInterval используются для работы с таймерами, позволяя выполнять код с задержкой или через определенные интервалы времени. Давайте рассмотрим, как они работают и что они возвращают.\\n\n ### 1. setTimeout\\n\n Функция setTimeout выполняет заданный код через определенный промежуток времени.\n Что возвращает: setTimeout возвращает уникальный идентификатор таймера (timeoutId), который можно использовать для отмены этого таймера с помощью функции clearTimeout.\\n\n 2. setInterval\\n\n Функция setInterval выполняет заданный код с регулярным интервалом времени.\n Что возвращает: setInterval возвращает уникальный идентификатор интервала (intervalId), который можно использовать для остановки выполнения интервала с помощью функции clearInterval.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "a4aa",
      "title": " С помощью какой операции можно отбросить дробную часть числа? ",
      "response": " 1. Использование Math.floor()\\n\n Метод Math.floor() округляет число до ближайшего меньшего целого числа, тем самым отбросив дробную часть.\n 2. Использование Math.trunc()\\n\n Метод Math.trunc() удаляет дробную часть числа, не округляя его.\n 3. Использование parseInt()\\n\n Функция parseInt() преобразует строку в целое число, игнорируя дробную часть, если переданное значение не является строкой.\n 4. Использование побитового оператора | (побитовое или)\\n\n Этот оператор приводит число к целочисленному типу, отбросив дробную часть.\n 5. Использование Math.round() с Math.abs()\\n\n Метод Math.round() позволяет округлить число, но с условием можно отбросить дробную часть.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "fdec",
      "title": " Каковы особенности сравнения с null и undefined?Каковы особенности сравнения с null и\\n  undefined? ",
      "response": " В JavaScript null и undefined представляют собой особые значения, которые часто используются для обозначения отсутствия или неопределенности. Однако между ними есть важные различия и особенности поведения при сравнении. Ниже рассмотрим их подробнее.\\n\n ### 1. Определение\\n\n - null: Это явное значение, которое задает отсутствие объекта или значения. Используется для инициализации переменной, что подразумевает, что она будет иметь объектное значение в будущем.\\n\n - undefined: Это значение автоматически присваивается переменным, которые были объявлены, но не инициализированы. Оно также возникает, если функция ничего не возвращает.\n 2. Сравнение с помощью оператора == (нестрогое равенство)\\n\n При использовании нестрогого равенства (==) JavaScript выполняет автоматическое преобразование типов для сравнения значений.\n таким образом, null и undefined равны, когда происходит нестрогое сравнение.\\n\n ### 3. Сравнение с помощью оператора === (строгое равенство)\\n\n С помощью строгого равенства (===) JavaScript не приводит значения к одному типу. Исходя из этого:\n Таким образом, null и undefined не равны при строгом сравнении, так как они имеют разные типы.\n 4. Типы данных\\n\n typeof можно проверить тип переменной:\n console.log(typeof null); // \"object\"\\n\n console.log(typeof undefined); // \"undefined\"\n Здесь стоит отметить, что typeof null возвращает \"object\", что является известным глюком в JavaScript.\\n\n ### 5. Использование в условных выражениях\\n\n Оба значения (null и undefined) считаются \"ложными\" (falsy) в условиях. Это означает, что они будут интерпретироваться как false в контексте условных операторов.\n 6. Частые ошибки и практические моменты\\n\n - Если вы хотите проверить, если переменная не задана (т.е. равно null или undefined), используйте нестрогое сравнение с ==\n - Если необходимо строго различать null и undefined, используйте строгое равенство ===. Это помогает избежать неожиданных последствий.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "852b",
      "title": "  К чему преобразуются null и undefined в численном преобразовании типов?",
      "response": " Преобразование null в число\\n\n Когда вы преобразуете null в число, оно становится 0. Это происходит потому, что null считается \"пустым\" или \"отсутствующим\" значением, и в числовом контексте это значение эквивалентно нулю. Преобразование undefined в число\\n\n При преобразовании undefined в число результатом будет NaN (Not-a-Number). undefined обозначает, что значение отсутствует или недоступно, поэтому при попытке преобразовать его в число возникает неопределенность.\\nТаким образом, при численном преобразовании:\\n\n - null преобразуется в 0\\n\n - undefined преобразуется в NaN",
      "level": "Middle",
      "active": false
    },
    {
      "id": "2875",
      "title": "  Объяснить разницу между !!(a && b) и (a && b)",
      "response": " !!(a && b) и (a && b) — это два различных выражения в JavaScript, и их разница заключается в том, как они обрабатываются и какое значение возвращают. Давайте рассмотрим их подробнее.\\n\n ### 1. (a && b)\n Выражение (a && b) использует логический оператор AND (&&). Оно возвращает:\\n\n - Первое истинное (truthy) значение: Если a является истинным значением, то результатом будет значение b. Если a является ложным (falsy), будет возвращено a.\\n\n - Ложное (falsy) значение: Если оба значения ложные, то будет возвращено первое ложное значение.\\n\n Таким образом, результатом этого выражения могут быть три возможных варианта:\\n\n - Если и a, и b истинны, возвращается значение b.\\n\n - Если a ложное, возвращается значение a.\\n\n - Если b ложное и a истинно, возвращается значение b.\n 2. !!(a && b)\\n\n Выражение !! — это двойное логическое отрицание, которое используется для приведения значения к типу Boolean. Оно делает следующее:\\n\n - Оператор ! (логическое отрицание) преобразует значение в булевый тип и инвертирует его.\\n\n - При использовании !! вы сначала инвертируете значение, а затем инвертируете его снова, что возвращает его истинное булевое значение.\\n\n Таким образом, выражение !!(a && b) всегда возвращает true или false, что соответствует булевому значению, представляющему результат логического выражения (a && b).\n Краткое резюме:\\n\n - (a && b) возвращает одно из значений (a или b) или false, в зависимости от значений переменных.\\n\n - !!(a && b) возвращает только true или false, приводя результат выражения к логическому значению.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "3b0b",
      "title": " Как реализовать сложение числа с объектом(в результате должно получиться число)?",
      "response": "JavaScript\n Объекты в JavaScript могут иметь пользовательские методы, включая метод valueOf(), который вызывается автоматически, когда объект используется в контексте, \n требующем примитивное значение (например, при выполнении арифметической операции).\n Пример реализации\\n\n Давайте создадим объект, который будет иметь метод valueOf(), возвращающий числовое значение, и затем сложим его с числом.\\n\n let obj = {\\n\n    value: 10,\\n\n    valueOf: function() {\\n\n       return this.value; // Возвращаем числовое значение\\n\n    }\\n\n };\\n\n // Сложение числа с объектом\\n\n let number = 5;\\n\n let result = number + obj; // Здесь будет вызван obj.valueOf()\\n\n console.log(result); // 15\n Объяснение:\\n\n 1. Создание объекта: Мы создали объект obj с числовым свойством value и методом valueOf(), который возвращает это значение.\\n\n 2. Арифметическая операция: При выполнении операции сложения number + obj JavaScript автоматически вызывает метод valueOf() у объекта obj, чтобы получить его числовое значение. В данном случае, результатом будет 5 + 10, что дает 15.\\n\n ### Другие методы\\n\n Кроме метода valueOf(), можно также использовать метод toString(), если это необходимо. Однако в контексте арифметических операций метод valueOf() является предпочтительным, так как он возвращает примитивное (числовое) значение.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "25f2",
      "title": " Что является областью видимости для переменных в JavaScript?",
      "response": " Область видимости (scope) в JavaScript определяет, где доступна переменная в коде и откуда она может быть использована или изменена. Понимание области видимости является важной частью работы с JavaScript, так как это влияет на жизненный цикл переменных и управление памятью. В JavaScript существуют несколько типов областей видимости: глобальная и локальная (функциональная и блочная). Давайте рассмотрим каждый из этих типов подробно.\\n\n ### 1. Глобальная область видимости\\n\n Переменные, объявленные в глобальной области видимости, доступны из любого места в коде, включая функции и другие блоки кода. Если переменная объявлена вне функции, она получает глобальную область видимости.\n 2. Локальная область видимости\\n\n Переменные, объявленные внутри функции, имеют локальную область видимости и доступны только внутри этой функции. Они не могут быть доступны вне функции.\n ### 3. Блочная область видимости\\n\n С появлением let и const в ES6 была введена блочная область видимости. Переменные, объявленные с помощью let или const внутри блока (например, в фигурных скобках), доступны только внутри этого блока.\n 4. Замыкания\\n\n Замыкания (closures) — это особая форма видимости, когда внутренняя функция имеет доступ к переменным своей внешней функции даже после завершения выполнения этой функции. Это позволяет сохранять состояние и создавать приватные переменные.\n 5. Область видимости в глобальных объектах\\n\n Переменные, объявленные с помощью var в глобальной области, становятся свойствами глобального объекта (например, window в браузере).",
      "level": "Junior",
      "active": false
    },
    {
      "id": "fd96",
      "title": " Реализация аргументов по умолчанию в функции",
      "response": " Аргументы по умолчанию определяются простым присваиванием значения в объявлении функции",
      "level": "Junior",
      "active": false
    },
    {
      "id": "65b5",
      "title": " Как работает чтение и запись свойств объекта в прототипном наследовании?",
      "response": " Прототипное наследование — это одна из ключевых концепций в JavaScript. Она позволяет объектам наследовать свойства и методы от других объектов. При работе с объектами и их свойствами важно понимать, как происходит чтение и запись свойств, а также как используется цепочка прототипов. Давайте рассмотрим это подробнее.\\n\n ### Как работает чтение и запись свойств объекта\\n\n 1. Чтение свойств: Когда вы обращаетесь к свойству объекта, JavaScript сначала проверяет, существует ли это свойство непосредственно в объекте. Если такое свойство найдено, оно возвращается. Если же его нет, JavaScript переходит к прототипу объекта и продолжает процедуру проверки. Этот процесс повторяется по цепочке прототипов до тех пор, пока не будет найдено свойство или не закончится цепочка. Если свойство не найдено, будет возвращено undefined.\\n\n 2. Запись свойств: Когда вы присваиваете значение свойству объекта, JavaScript сначала проверяет, существует ли это свойство в самом объекте. Если свойство существует, новое значение перезаписывает старое. Если же свойства нет, оно создается непосредственно в объекте, и новое значение присваивается ему. Важно отметить, что при записи свойств происходит именно создание или обновление непосредственно в объекте, который был использован для записи, без необходимости проходить по цепочке прототипов\n Цепочка прототипов\\n\n При создании объекта с помощью Object.create(), вы устанавливаете прототип для нового объекта. Цепочка прототипов позволяет объекту наследовать свойства и методы от его прототипа.\\n\n - В приведенном выше примере, объект child содержит собственное свойство name, но для вызова метода greet он будет искать его в parent, потому что greet не определен в child.\\n\n ### Лексическое окружение и замыкания\\n\n Важно понимать, что при использовании прототипного наследования не следует путать контекст и области видимости. Свойства, добавленные к объекту, могут затмить одноименные свойства, наследуемые от прототипа, но возможности доступа к замыканиям и лексическому окружению остаются незатронутыми..",
      "level": "Middle",
      "active": false
    },
    {
      "id": "9c35",
      "title": " Что такое контекст функции?",
      "response": " Контекст функции в JavaScript — это объект, который определяет, к каким данным имеет доступ функция, когда она вызывается. Контекст функции определяет значение слова this внутри функции. Понимание контекста является важным аспектом написания корректного и предсказуемого кода на JavaScript. Давайте разберемся с основными аспектами контекста функции подробнее.\\n\n ### 1. Виды контекста\\n\n #### Глобальный контекст\\n\n Когда код выполняется вне функций, он работает в глобальном контексте. В браузере это объект window, а в Node.js — объект global.\\n\n Контекст функции\\n\n Когда функция вызывается, создается новый контекст. Значение this внутри функции зависит от того, как была вызвана функция.\n 2. Способы вызова функций и их влияние на контекст\\n\n #### Простой вызов\\n\n При простом вызове функции (как в приведенном выше примере) контекст будет глобальным объектом (или undefined в строгом режиме).\\n\n #### Метод объекта\\n\n Когда функция вызывается как метод объекта, this ссылается на объект, к которому принадлежит метод.\n Конструктор\\n\n При вызове функции с оператором new, контекст this будет ссылаться на новый объект, создаваемый с помощью конструктора.\n Привязка контекста\\n\n Функции можно явно привязывать к объектам с помощью методов call(), apply() и bind().\n Стрелочные функции\\n\n Стрелочные функции не имеют собственного this. Они наследуют значение this от своего лексического окружения (т.е., от родительской функции или контекста, в котором они были созданы).\n 3. Контекст и области видимости\\n\n Контекст this не зависит от области видимости и определяет, каким образом функция была вызвана. Это важно отличать от переменных, которые имеют свою область видимости.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "7d05",
      "title": " Каков результат выполнения var obj = Object.create(null);?",
      "response": " Выражение var obj = Object.create(null); создает новый объект obj, который не имеет прототипа. Это означает, что он не наследует никаких свойств и методов от стандартного объекта Object, таких как toString, hasOwnProperty, и других. ### Объяснение:\\n\n 1. Создание объекта без прототипа:\\n\n - Object.create(null) создает пустой объект, который не имеет никаких свойств и методов, унаследованных от Object. Это делает его \"чистым\" объектом.\\n\n\n - Например, можно сказать, что это объект в \"чистой\" форме, без каких-либо дополнительных свойств.\\n\n 2. Результат:\\n\n - obj будет объектом, который не реагирует на стандартные методы и свойства объектного типа\n 3. Практическое применение:\\n\n - Использование объектов без прототипа может быть полезно, когда нужно создать контейнер для хранения данных, где вы не хотите, чтобы они конфликтовали с методами и свойствами, которые могут унаследоваться от Object.\\n\n - Это также важно в случаях, когда вы строите структуры данных (например, хеш-таблицы) и хотите избежать путаницы с методами, унаследованными от стандартного объекта.\\n\n 4. Итог:\\n\n - Создание объекта с использованием Object.create(null) позволяет вам избежать потенциальных проблем и обеспечить чистоту данных, что делает этот подход полезным в различных сценариях программирования\n",
      "level": "Senior",
      "active": false
    },
    {
      "id": "5e37",
      "title": " Как скопировать функцию со всеми свойствами?",
      "response": " В JavaScript для копирования функции вместе со всеми её свойствами можно воспользоваться либо встроенными методами, либо инструментами, предоставляемыми языком. Однако стоит иметь в виду, что функции в JavaScript являются объектами, поэтому простое присваивание не скопирует их свойства. Ниже приведены несколько подходов к решению этой задачи:\\n\n ### 1. Использование Object.assign\\n\n Можно использовать Object.assign для копирования всех свойств функции в новую функцию.2. Использование Function.prototype.bind\\n\n Созданная с помощью bind функция будет иметь те же свойства, что и исходная функция\n 3. Использование ES6 class\\n\n Если ваша функция является конструктором, вы можете создать новый класс, который будет наследовать её\n 4. Ручное копирование\\n\n'Если вам нужно сделать более комплексное копирование свойств, вы можете вручную перебрать иx'\n Все эти методы копируют только собственные свойства функции (если они есть). Унаследованные свойства, такие как методы прототипа, не будут скопированы.\\n\n- Копировать функции и их свойства следует с осторожностью, так как при изменениях в оригинальной функции изменения не отразятся на копии и наоборот.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "7c9d",
      "title": " Как выглядит модуль в JavaScript?",
      "response": "\nМодули в JavaScript представляют собой способ структурирования кода в отдельные файлы или модули и позволяют импортировать и экспортировать функции, объекты или переменные между этими модулями. С введением ECMAScript 6 (ES6) появилась официальная поддержка модулей в JavaScript, что сделало работу с модулями более удобной и понятной. Вот как выглядит модуль в JavaScript.\\n\n ### 1. Определение модуля\\n\n Чтобы создать модуль, вам нужно использовать ключевые слова export и import.\n a. Экспорт\\n\n Вы можете экспортировать переменные, функции или классы, используя export. Это можно сделать либо по умолчанию, либо именованным образом.\n 2. Импорт модуля\\n\n Теперь, когда у вас есть модули, вы можете их импортировать в другие модули.\n 3. Импорт всего модуля\\n\n Вы также можете импортировать весь модуль как объект\n 4. Важно помнить\\n\n - Расширение файлов: Важно добавить расширение .js, когда вы импортируете модули, если вы используете ES6 модули в браузере, который поддерживает модули.\\n\n - Корректная загрузка модулей: Для использования ES6 модулей в браузере используйте атрибут type=\"module\" в script>:\n 5. Поддержка модулей\\n\n Модули в JavaScript поддерживаются во всех современных браузерах и Node.js.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "a056",
      "title": " Какие способы назначения обработчиков событий вы знаете?",
      "response": " В JavaScript существует несколько способов назначения обработчиков событий на элементы DOM. Вот основные из них:\\n\n ### 1. Атрибуты HTML\\n\n Вы можете назначить обработчик события непосредственно в HTML-коде, используя атрибуты, такие как onclick, onmouseover и другие. Это старый способ, который может быть менее предпочтительным из-за смешивания разметки и логики.\n 2. Свойства DOM\\n\n Вы можете назначить обработчик события непосредственно через свойство элемента DOM\n 3. Метод addEventListener()\\n\n Это наиболее современный и гибкий способ назначения обработчиков событий. Он позволяет добавлять несколько обработчиков на одно событие и поддерживает захват событий.\n Преимущества addEventListener():\\n\n - Можно добавлять несколько обработчиков событий для одного и того же элемента и события.\\n\n - Поддерживает параметры захвата и не всплытия.\\n\n - Легко удалять обработчики с помощью removeEventListener().\n 5. Стрелочные функции\\n\n При использовании ES6 стрелочных функций можно задавать обработчики событий более лаконично, особенно если вы используете их внутри других функций или методов.\n 6. Привязка событий в CSS\\n\n Некоторые события, такие как :hover, могут вызывать применение стилей CSS, но это не полноценные обработчики событий JavaScript. Однако это стоит упомянуть в контексте работы с событиями.\\n\n ### 7. Inline обработчики\\n\n Вы можете назначать обработчики событий непосредственно в HTML-коде с использованием on Event>, что также является старым методом.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "811b",
      "title": " Как предотвратить распространение события?",
      "response": " В JavaScript для предотвращения распространения события (всплытия) можно использовать два метода: stopPropagation() и stopImmediatePropagation(). Оба метода доступны на объекте события, который передается в обработчик. Вот как они работают:\\n\n ### 1. stopPropagation()\\n\n Метод stopPropagation() предотвращает дальнейшее распространение события по дереву DOM. Если событие вызвано на элементе, этот метод предотвращает его всплытие к родительским элементам.\n 2. stopImmediatePropagation()\\n\n Метод stopImmediatePropagation() не только предотвращает всплытие события, но и останавливает выполнение всех остальных обработчиков событий, назначенных на тот же элемент для того же события.\n Используйте stopPropagation(), когда вам нужно остановить всплытие события, но продолжить выполнение других обработчиков на том же элементе.\\n\n - Используйте stopImmediatePropagation(), если вы хотите остановить не только всплытие, но и выполнение остальных обработчиков на текущем элементе.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "4db7",
      "title": " Как отменить стандартное дествие браузера при наступлении события?",
      "response": " Для отмены стандартного действия браузера при наступлении события в JavaScript вы можете использовать метод preventDefault() объекта события. Этот метод предотвращает выполнение стандартного действия, связанного с конкретным событием. Например, если вы хотите отменить отправку формы, переход по ссылке или использование клавиши в текстовом поле.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "b52e",
      "title": " Как получить тэг html?",
      "response": " Для получения (или создания) HTML-тегов можно использовать различные подходы в зависимости от контекста: разработки веб-страниц или взаимодействия с DOM (Document Object Model) с помощью JavaScript. Ниже приведены основные способы получения HTML-тегов.\\n\n ### 1. Получение HTML-тегов с помощью JavaScript\\n\n Чтобы получить элементы HTML на веб-странице с помощью JavaScript, вы можете использовать следующие методы:\\n\n - document.getElementById(): Получает элемент по уникальному значению атрибута id.\\n\n - document.getElementsByClassName(): Получает все элементы с указанным классом.\n - document.getElementsByTagName(): Получает все элементы по имени тега.\n - document.querySelector(): Получает первый элемент, соответствующий указанному CSS-селектору.\\n\n - document.querySelectorAll(): Получает все элементы, соответствующие указанному CSS-селектору.\n 3. Создание HTML-тегов\\n\n Для создания новых HTML-элементов с помощью JavaScript вы можете использовать метод document.createElement()",
      "level": "Junior",
      "active": false
    },
    {
      "id": "6ae3",
      "title": " Какое событие позволяет отловить загрузку страницы? (разница между onload иDocumentContentLoaded)",
      "response": " В JavaScript для отслеживания загрузки страницы используются два основных события: onload и DOMContentLoaded. Оба события относятся к загрузке документа, но они имеют разные триггеры и цели. Ниже приведено их сравнение и объяснение:\\n\n ### 1. onload\\n\n - Триггер: Событие onload срабатывает, когда весь документ, включая все его ресурсы (такие как изображения, стили, скрипты и т. д.), полностью загружен. Это означает, что браузер закончил загрузку всех аспектов страницы.\\n\n - Использование: Обычно используется для выполнения скриптов, которые требуют, чтобы вся страница и все её ресурсы были загружены до их выполнения. Например, инициализация слайдеров изображений или выполнение каких-то функций, которые зависят от загруженных изображений.\n 2. DOMContentLoaded\\n\n - Триггер: Событие DOMContentLoaded срабатывает, когда HTML-документ полностью загружен и разобран, без ожидания завершения загрузки стилей, изображений и других ресурсов. Это происходит раньше, чем событие onload.\\n\n - Использование: Обычно используется для инициализации интерфейса или выполнения скриптов, которые не зависят от загрузки внешних ресурсов. Это позволяет ускорить реакцию страницы на действия пользователя.\n Выбор между onload и DOMContentLoaded зависит от требуемой логики приложения. Если нужно дождаться загрузки всех ресурсов, используйте onload. Если достаточно дожидаться загрузки HTML, лучше использовать DOMContentLoaded для повышения производительности и лучшей отзывчивости интерфейса.",
      "level": "Senior",
      "active": false
    },
    {
      "id": "da58",
      "title": " Как подписаться на событие OnLoad?",
      "response": " Подписаться на событие onload можно несколькими способами в JavaScript. Вот основные подходы, которые можно использовать для этого:\\n\n ### 1. Использование атрибута в HTML\\n\n Вы можете добавить атрибут onload к тегу body> в HTML-коде\n 2. Использование свойства window.onload\\n\n Вы можете назначить обработчик события onload через свойство window.onload в JavaScript\n Этот метод заменяет предыдущий обработчик onload, если он был установлен. Если необходимо добавить несколько обработчиков, используйте другой способ, описанный ниже.\\n\n ### 3. Использование addEventListener\\n\n Самый рекомендуемый и гибкий способ — использовать метод addEventListener. Это позволяет вам добавлять несколько обработчиков для одного события и не заменяет предыдущие обработчики\n Этот метод также позволяет указать дополнительные параметры, такие как использование фазы захвата события и возможность удаления обработчика.\n Для подписки на событие onload лучше использовать метод addEventListener, так как он предоставляет много преимуществ, включая возможность добавления нескольких обработчиков и лучшую совместимость с современными стандартами JavaScript.",
      "level": "Senior",
      "active": false
    },
    {
      "id": "3af9",
      "title": " Как можно перебрать коллекцию html элементов",
      "response": " Перебрать коллекцию HTML-элементов можно с помощью различных методов и подходов в JavaScript. Ниже приведены некоторые из наиболее распространенных способов:\\n\n ### 1. Использование цикла for\\n\n Это один из самых простых и интуитивно понятных способов перебора коллекции. Например, если у вас есть коллекция элементов, полученная с помощью getElementsByClassName или getElementsByTagName, вы можете использовать for цикл\n 2. Использование цикла forEach\\n\n Если вы используете метод querySelectorAll, он возвращает NodeList, на который можно применить метод forEach для перебора элементов\n 3. Использование цикла for-of\\n\n Если вы хотите использовать более современный подход, можно воспользоваться циклом for-of для перебора коллекции. Это также возможно с NodeList или с массивами\n 4. Преобразование в массив\\n\n Если вы используете коллекции, которые не поддерживают методы массивов (например, getElementsByClassName или getElementsByTagName), вы можете преобразовать их в массив, а затем использовать forEach",
      "level": "Middle",
      "active": false
    },
    {
      "id": "7272",
      "title": " Как перевести html коллекцию в массив",
      "response": " HTML-коллекцию можно перевести в массив несколькими способами в JavaScript. Такие коллекции часто возвращаются методами, такими как getElementsByClassName, getElementsByTagName и children. Поскольку эти коллекции являются живыми списками (Live NodeList), они не поддерживают методы массива, такие как forEach, map, и т. д. Поэтому их необходимо преобразовать в массив. Вот несколько способов сделать это: ### 1. Использование Array.from()\\n\n Метод Array.from() создает новый массив из объектов, которые имеют итератор или являются массивоподобными.\n 2. Использование оператора расширения ... (Spread Operator)\\n\n Оператор расширения позволяет развернуть массивоподобные объекты в массив.\n 3. Использование обычного цикла для создания массива\\n\n Вы можете создать новый массив и передать в него элементы из коллекции с помощью обычного цикла.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "bfc7",
      "title": " Разница между атрибутами async элемента script>?",
      "response": " Атрибуты async и defer элемента script> в HTML используются для управления загрузкой и выполнением JavaScript на веб-странице. Хотя оба атрибута позволяют загружать скрипты асинхронно, они работают по-разному. Вот основные различия между ними:\\n\n ### 1. async\\n\n - Загрузка: Скрипт с атрибутом async загружается асинхронно по мере того, как страница загружается. Это означает, что браузер продолжает загружать HTML-документ, не дожидаясь полной загрузки скрипта.\\n\n - Исполнение: Скрипт выполняется сразу после его загрузки, что может произойти до того, как будет завершена загрузка всего HTML-документа. Поэтому порядок выполнения не гарантирован, если у вас несколько скриптов \n с атрибутом async. Можно сказать, что скрипт будет выполняться, как только он будет готов, независимо от того, были ли загружены более ранние или поздние скрипты.. defer\\n\n - Загрузка: Скрипт с атрибутом defer также загружается асинхронно, чтобы не блокировать загрузку HTML-документа.\\n\n - Исполнение: Однако в отличие от async, скрипт с атрибутом defer выполняется только после того, как весь HTML-документ будет полностью загружен и разобран. Таким образом, все скрипты с defer выполняются в порядке, в котором они записаны в документе.\n Порядок выполнения\\n\n Чтобы подвести итоги:\\n\n - Скрипты с async выполняются по мере загрузки (порядок не гарантируется).\\n\n - Скрипты с defer выполняются в порядке их появления в документе, только после завершения загрузки всего HTML.\n Используйте async, если порядок выполнения скриптов не важен и вы хотите ускорить загрузку страницы, и defer, когда вам важно, чтобы скрипты выполнялись после загрузки полного HTML-документа, сохраняя при этом порядок их обработки.",
      "level": "Senior",
      "active": false
    },
    {
      "id": "f71a",
      "title": "Какие методы выборки элементов DOM вы знаете?",
      "response": " В JavaScript есть несколько методов для выборки элементов из DOM (Document Object Model). Вот основные из них:\\n\n ### 1. getElementById()\\n\n Этот метод возвращает элемент с указанным идентификатором (id).\n 2. getElementsByClassName()\\n\n Этот метод возвращает коллекцию всех элементов с указанным классом. Обратите внимание, что он возвращает \"живую\" коллекцию, которая обновляется при изменении DOM.\n 3. getElementsByTagName()\\n\n Этот метод возвращает коллекцию всех элементов с указанным тегом. Также возвращает \"живую\" коллекцию.\n 4. querySelector()\\n\n Этот метод возвращает первый элемент, соответствующий указанному CSS-селектору. Если элемент не найден, возвращает null.\\n\n 5. querySelectorAll()\\n\n Этот метод возвращает статическую коллекцию всех элементов, соответствующих указанному CSS-селектору. В отличие от getElementsByClassName() и getElementsByTagName(), эта коллекция не обновляется при изменении DOM.\n 6. childNodes\\n\n Это свойство возвращает коллекцию всех дочерних узлов элемента, включая текстовые узлы и комментарии.\n 7. firstChild, lastChild\\n\n Эти свойства возвращают первый и последний дочерний узел элемента соответственно.\n 8. children\\n\n Это свойство возвращает коллекцию всех дочерних элементов элемента, исключая текстовые узлы и комментарии.\n 9. firstElementChild, lastElementChild\\n\n Эти свойства возвращают первый и последний дочерний элемент соответственно, игнорируя текстовые узлы.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "f679",
      "title": " Как добавить новый элемент DOM в дерево?",
      "response": " Добавление нового элемента в дерево DOM в JavaScript можно сделать с помощью методов, которые предоставляют API DOM. Вот основные шаги, как это сделать:\\n\n ### 1. Создание нового элемента\n Для создания нового элемента используется метод createElement()\n 2. Настройка нового элемента\n Вы можете добавить текст, атрибуты или классы к новому элементу:\n newElement.textContent = 'Hello, World!';  Добавляет текстовое содержимое\n newElement.className = 'my-class'; Устанавливает класс\n newElement.setAttribute('id', 'my-id'); // Устанавливает атрибут id\n 3. Выбор родительского элемента\n Теперь необходимо выбрать элемент, в который вы хотите добавить новый элемент. Это можно сделать с помощью одного из методов выбора элементов, таких как getElementById(), querySelector() и т. д.:\\n\n const parentElement = document.getElementById('parent'); // Выбор родительского элемента\n 4. Добавление нового элемента в DOM\\n\n Теперь, когда у вас есть новый элемент и родительский элемент, вы можете добавить новый элемент в дерево DOM с помощью методов appendChild(), insertBefore(), или append():\\n\n #### Использование appendChild()parentElement.appendChild(newElement); // Добавляет новый элемент как последний дочерний элемент\n Использование insertBefore()\n Если вы хотите вставить элемент перед определенным дочерним элементом:\n const referenceElement = document.getElementById('reference');\n parentElement.insertBefore(newElement, referenceElement);  Вставляет новый элемент перед referenceElement\n #### Использование append()\n append() можно использовать для добавления одного или нескольких элементов в конец родительского элемента. Также он позволяет добавлять текст:",
      "level": "Junior",
      "active": false
    },
    {
      "id": "c7ff",
      "title": " Объяснить как работать с AJAX запросами в JS",
      "response": " AJAX (Asynchronous JavaScript and XML) позволяет выполнять асинхронные запросы к серверу без необходимости перезагрузки страницы. В JavaScript для работы с AJAX-запросами можно использовать как устаревший объект XMLHttpRequest, так и более современный Fetch API. Давайте рассмотрим оба способа.\\n\n ### 1. Использование XMLHttpRequest\\n\n Вот пример использования объекта XMLHttpRequest для выполнения AJAX-запроса:\n 2. Использование Fetch API\\n\n Fetch API упрощает выполнение запросов и возвращает Promise, что позволяет использовать более современный стиль работы с асинхронным кодом (например, через .then() и async/await).\n 3. Использование async/await с Fetch API\\n\n Можно сделать код еще более читаемым, используя async/await\n 4. Отправка данных на сервер\\n\n Чтобы отправить данные на сервер с использованием Fetch API, вы можете использовать метод POST.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "fa60",
      "title": "element.cloneNode — как копируются свойства элемента?",
      "response": " Метод cloneNode() в JavaScript используется для создания клона (копии) элемента и может копировать его свойства и структуру. Давайте подробнее рассмотрим, как работает этот метод и какие свойства копируются при клонировании элементов.\\n\n ### 1. Синтаксис\\n\n Метод cloneNode() принимает один параметр:\\n\n - deep (boolean) — если true, производится глубокое клонирование, включая все дочерние элементы. Если false (по умолчанию), то клонируется только сам элемент без его дочерних узлов.\\n\n 2. Что копируется?\\n\n - Атрибуты: Все атрибуты оригинального элемента (например, id, class, data-* и другие пользовательские атрибуты) будут скопированы в клоне. Однако, значения свойства id могут не сработать должным образом, если у вас уже есть элемент с таким же id в документе. Это может также вызвать проблемы с уникальностью.\\n\n - События: Событие не копируется. Например, если на оригинальном элементе установлены обработки событий (например, с помощью addEventListener), они не будут перенесены на клон. Необходимо отдельно привязывать обработчики событий к клону.\\n\n - Дочерние элементы: Если параметр deep установлен в true, все дочерние элементы и их атрибуты также будут скопированы. Если false, клонируется только сам элемент без его содержимого.\\n\n - Стили (inline): Инлайновые стили (например, стиль, указанный непосредственно в атрибуте style элемента) будут скопированы. Однако, стили, применяемые через CSS-классы, не будут скопированы. Клон будет наследовать стили, применяемые к классу, если к нему применены те же классы.\n Метод cloneNode() предоставляет удобный способ клонирования DOM-элементов с учетом их атрибутов, но не копирует обработчики событий. Для полной функциональности, особенно если вам нужны события, придется добавлять обработчики отдельно для клонированного элемента.",
      "level": "Senior",
      "active": false
    },
    {
      "id": "e72d",
      "title": " События, работа с DOM",
      "response": "Работа с DOM (Document Object Model) и событиями — это ключевые аспекты взаимодействия с веб-страницами на JavaScript. В этой области вы можете манипулировать элементами документа, изменять их содержимое и реагировать на действия пользователя. Давайте подробнее рассмотрим эти концепции.\\n\n ### 1. Что такое DOM?\\n\n DOM — это объектная модель документа, которая представляет структуру документа HTML или XML в виде дерева объектов. Каждый элемент на странице, будь то текст, кнопка или изображение, представлен как узел в этой структуре. Это позволяет скриптам взаимодействовать с элементами страницы.\\n\n ### 2. Основные методы работы с DOM\\n\n Вот несколько основных методов для работы с DOM в JavaScript:\\n\n - Получение элементов\\n\n - document.getElementById('id'): Получает элемент по его ID.\\n\n - document.getElementsByClassName('class'): Получает коллекцию элементов по имени класса.\\n\n - document.getElementsByTagName('tag'): Получает коллекцию элементов по тэгу.\\n\n - document.querySelector('selector'): Получает первый элемент, соответствующий селектору CSS.\\n\n - document.querySelectorAll('selector'): Получает все элементы, соответствующие селектору CSS.\\n\n - Изменение содержимого\\n\n - element.innerHTML: Изменяет HTML-содержимое элемента.\\n\n - element.textContent: Изменяет текстовое содержимое элемента.\\n\n - Изменение стилей\\n\n - element.style.property: Позволяет изменять стили элемента, например: element.style.color = 'red';.\\n\n - Создание и добавление элементов\\n\n - document.createElement('tag'): Создает новый элемент.\\n\n - parentElement.appendChild(childElement): Добавляет элемент как дочерний к указанному родителю.\\n\n - Удаление элементов\\n\n - element.remove(): Удаляет элемент из DOM.\\n\n - parentElement.removeChild(childElement): Удаляет дочерний элемент из родителя.\\n\n ### 3. События в JavaScript\\n\n События — это действия или действия пользователя, которые могут происходить на веб-странице, такие как щелчки мыши, нажатия клавиш,\n наведение указателя на элемент и т.д. JavaScript позволяет вам реагировать на эти события с помощью обработчиков событий.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "9643",
      "title": "Манипуляции с DOM",
      "response": " Dom - поиск через getElementById - по id, querySelector - по селектору, querySelectorAll\\n\n getElementByClassName - по имени класса  getElementByTagName - по тегу\\n\n создание элемента Dom - document.createElement(tag).className(класс).innerHtml(текст)\\n\n чтобы его вставить body.append - добавляем в конец, prepend - в начало, before -  до, after- после\\n\n\n Изменение replaseWith, cloneNode\\n\n удаление через element.remove()\\n\n добавление классов - element.classList.add/remove/sidebar.component.ts\\n",
      "level": "Junior",
      "active": false
    },
    {
      "id": "a17d",
      "title": "Какие способы реализации ООП есть в JS(ES6)",
      "response": "В JavaScript (ES6 и новее) есть несколько способов реализации объектно-ориентированного программирования (ООП). Вот основные из них:\n\n\nОбъекты:\n\nВ JavaScript все является объектом. Вы можете создавать объекты с помощью литералов объектов или конструкций конструктора и добавлять методы к ним.Конструкторы и прототипы:\n\nВы можете создавать функции-конструкторы, которые используют прототипы для создания объектов.\nКлассы (ES6):\n\nС введением классов в ES6, JavaScript получил синтаксис, более близкий к традиционным языкам ООП, таким как Java или C#.Наследование (ES6):\n\nВ классовой системе ES6 вы можете использовать ключевое слово extends для создания подклассов.Модули (ES6):\n\nES6 поддерживает модули, которые позволяют организовывать код в отдельные файлы и использовать экспорт и импорт, что также способствует объектно-ориентированному подходу.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "a630",
      "title": " Как устроена асинхронность в js",
      "response": " Асинхронность в JavaScript — это важная концепция, которая позволяет выполнять операции\n не блокируя основной поток выполнения кода. Это особенно полезно при работе с такими задачами,\n как запросы к серверу, работа с файловой системой, таймеры и другие действия, которые могут занять \n неопределённое время. JavaScript использует несколько механизмов для работы с асинхронностью:\\n\n ### Обработка событий (Event Loop)\\n\n JavaScript работает в однопоточном режиме, что означает, что он выполняет один поток кода за раз. \n Чтобы справляться с асинхронными операциями, используется система событий и цикл событий (Event Loop).\\n\n - Call Stack: Это стек вызовов, который хранит текущие функции, которые выполняются. Когда функция\n  вызывается, она помещается в стек, а когда завершается, удаляется из стека.\\n\n - Web APIs: Когда происходит асинхронное выполнение (например, HTTP-запрос), это передаётся соответствующему \n API, который работает независимо, не блокируя основной поток JavaScript.\\n\n - Callback Queue: Когда асинхронная операция завершена, соответствующий callback помещается в очередь обратных\n  вызовов (callback queue).\\n\n - Event Loop: Цикл событий движется между стеком вызовов и очередью обратных вызовов. Когда стек пуст, Event Loop\n  берёт функцию из очереди и помещает её в стек для выполнения.\n Функции обратного вызова (callbacks) — это функции, которые передаются как аргументы в другие функции,\n чтобы быть вызванными позже, когда операция будет завершена.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "6b27",
      "title": " Функциональные конструкции map,reduce,filter",
      "response": " Метод reduce() применяет функцию reducer к каждому элементу массива\n (слева-направо), возвращая одно результирующее значение.\n Метод filter() создаёт новый массив со всеми элементами, \n прошедшими проверку, задаваемую в передаваемой функции.\n Метод map вызывает переданную функцию callback один раз \n для каждого элемента, в порядке их появления и конструирует новый массив из результатов функции",
      "level": "Junior",
      "active": false
    },
    {
      "id": "7ab8",
      "title": " Работа с ассинхронностью",
      "response": " Promise - специальный обьект  в JS, для работы с ассинхронностью\\n\n у него есть состояние - pending(в процессе ), reject(ошибка), fullfield(успешно)\\n\n методы then(), catch(), finally()  чейнинг(цепочка вызовов) - then().then()\\n\n new Promise((res, rej) => {})  два колбека res, rej  он срабатывает один раз и неизменяем либо resolve или reject\\n\n .all([]) - ждет пока все пройдут, если один с ошибкой выдаст ошибку\\n\n .race() - выдаст результат первого промиса\\n\n .allSetled() - покажет результат всех и их статусы",
      "level": "Junior",
      "active": false
    },
    {
      "id": "af53",
      "title": "Async/await",
      "response": " async/await - специальный синтаксис над промисом\\n\n async function() {return } - зарезолвленный промис\\n\n await - аналог .then() - у промиса\\n\n обработчик ошибок try/catch внутри\n async/await — это синтаксический сахар в JavaScript, который упрощает работу с промисами и делает асинхронный код более читаемым и удобным для написания. Давайте подробнее рассмотрим, как это работает, как его использовать и чем он удобен.\\n\n ### Основные концепции async и await\\n\n 1. async:\\n\n - Ключевое слово async используется для определения функции как асинхронной.\\n\n - Асинхронная функция всегда возвращает промис. Если она возвращает значение, это значение автоматически упаковывается в промис, разрешенный с этим значением.\\n\n - Если в асинхронной функции выбрасывается ошибка, промис будет отклонён с этой ошибкой.\\n\n 2. await:\\n\n - Ключевое слово await используется для ожидания завершения промиса.\\n\n - Оно может использоваться только внутри асинхронной функции.\\n\n - await приостанавливает выполнение функции, пока промис не будет выполнен (либо разрешён, либо отклонён).\\n\n - Если при ожидании промиса возникает ошибка, она будет выброшена, и вы можете обработать её через блок try...catch.\n Преимущества использования async/await\\n\n 1. Читаемость: Код выглядит более линейно и легко читается, как обычный синхронный код, что упрощает его понимание.\\n\n 2. Простота обработки ошибок: Использование try...catch облегчает обработку ошибок по сравнению с использованием метода .catch() с промисами.\\n\n 3. Упрощение работы с цепочками промисов: С async/await можно избежать \"адов колбеков\" и глубоких вложенных структур, упрощая структуру кода.\\n\n ### Важно помнить:\\n\n - В большинстве случаев, если вы используете await, вы должны обрабатывать ошибки с помощью try...catch.\\n\n - await может быть использован только внутри функций, помеченных как async.\\n\n - Вы также можете параллельно выполнять несколько промисов с использованием Promise.all(), чтобы дождаться их выполнения, но это не требует использования await для каждого промиса.\\n",
      "level": "Junior",
      "active": false
    },
    {
      "id": "05eb",
      "title": " Способы оптимизации работы с Dom.  Список самых дорогих операций",
      "response": " добавление в Dom после рендеринга  - нужно использовать  documentFragment\\n\n слишком частые события window.resize - использовать debounce()\\n\n Узлы дом необходимо создавать только при их необходимости а как только в них отпала надобность, удаляем\\n\n Подгружать узлы по мере необходимости пользователю\\n\n Сокращение объёма  сложных вычислительных стилей",
      "level": "Senior",
      "active": false
    },
    {
      "id": "ceaf",
      "title": " Modules, Proxy, Reflect,",
      "response": " Модули - файл с use strict режимом, у них есть импорт и экспорт Proxy - спец. обьект для перехвата и переопределения основных операций new Proxy(obj, handler) reflect -часто используют вместе с proxy внутри надстройка\n\n",
      "level": "Middle",
      "active": false
    },
    {
      "id": "78f0",
      "title": " localStorage, sessionStorage, cookie",
      "response": " localStorage - хранит данные без срока годности session- во время жизни вкладки, если дублировать вкладку создаст для каждой\\n\n setItem('key', содержимое) - закинуть, getItem('ключ') - забрать\\n\n cookie - хранит данные, которые должны быть отправлены обратно на сервер последующими запросами\\n\n Если установить флаг httpOnly -true - для файла то предотвратит доступ на стороне клиента, добавляется  через document.coockie",
      "level": "Junior",
      "active": false
    },
    {
      "id": "724a",
      "title": " Сборщик мусора  ",
      "response": " Сборщик мусора периодически находит \n объекты, которые больше не доступны в контексте \n выполнения программы, и автоматически освобождает связанную с ними память",
      "level": "Middle",
      "active": false
    },
    {
      "id": "b83f",
      "title": "repaint, reflow",
      "response": " repaint -перерисовка элементов стили визуальный слой, \n без изменения размеров(это процесс, в ходе которого браузер отрисовывает (перерисовывает) визуальное представление\n элемента. Происходит, когда изменяются визуальные стили элемента, не влияющие на его размеры или положение.)\\n\n reflow - перерисовка макета страницы(Reflow — это процесс, в ходе которого\n браузер вычисляет размеры и позиции элементов на странице. Он происходит, когда\n изменяются какие-либо свойства, влияющие на расположение (размеры, границы, отступы, содержание и т. д.) элементов на странице.)\n Оптимизация\\n\n Чтобы минимизировать количество reflow и repaint, следует следовать ряду рекомендаций:\\n\n - Структура изменений: Группируйте изменения стилей и добавления/удаления элементов, чтобы избежать множественных перерисовок.\\n\n - Избегайте частых изменений в циклах: Если необходимо много раз изменить стиль в цикле, лучше собрать все изменения и применить их за один раз.\\n\n - Используйте requestAnimationFrame: Для анимаций это позволяет браузеру оптимально справляться с обновлением интерфейса.\\n\n - Работайте с классовыми селекторами: Изменение класса может затронуть несколько стилий одновременно и сэкономить ресурсы на перерисовку.\\n\n - Минимизируйте зависимости: Будьте внимательны с событиями, которые могут вызвать восприятие изменений интерфейса.",
      "level": "Senior",
      "active": false
    },
    {
      "id": "2591",
      "title": " Web Assembly",
      "response": " язык программирования низкого уровня, призванный внести программируемость \n туда, где нужны кроссплатформенность,\n эффективность и безопасность, в первую очередь на клиентскую сторону Всемирной паутины.WebAssembly — это мощный инструмент, который расширяет \n возможности веб-разработки\n , позволяя использовать более производительные и эффективные языки, а также обеспечивая отличную совместимость с существующим\n  JavaScript. Он открывает новые возможности \n для создания современных высокопроизводительных веб-приложений и идеально подходит для сценариев, требующих высоких вычислительных затрат.",
      "level": "Senior",
      "active": false
    }
  ],
  "css": [
    {
      "id": "500f",
      "title": "Что такое CSS3 и чем он отличается от предыдущих версий CSS?",
      "response": "CSS3 (Cascading Style Sheets Level 3) — это третья версия каскадных таблиц стилей, которая используется для описания внешнего вида и формата документа, написанного на HTML или XML (включая такие) языки разметки, как SVG и XHTML). CSS3 добавляет новые возможности и улучшения по сравнению с предыдущими версиями, что делает стилизацию веб-страниц более гибкой и мощной.Основные отличия CSS3 от предыдущих версий CSS:1. Модули: - CSS3 организован в виде модулей, каждый из которых отвечает за определенные функции. Это позволяет разработчикам использовать только те части CSS3, которые им нужны, без необходимости загружать весь стандарт.- Например, есть модули для градиентов, теней, анимаций и т. д.2. Новые селекторы:- CSS3 предлагает множество новых селекторов, таких как :nth-child(), :not(), :first-of-type, и других. Эти селекторы делают выбор элементов более точным и простым.3. Градиенты:- В CSS3 можно использовать градиенты без необходимости в использовании изображений.Благодаря свойству background можно создавать линейные и радиальные градиенты прямо в CSS.4. Медиазапросы:- CSS3 вводит медиазапросы, которые позволяют применять стили в зависимости от различных условий, таких как размер экрана устройства. Это является основой для создания адаптивного дизайна.5. Новые свойства для работы с шрифтами:- CSS3 предоставляет поддержку @font-face, которая позволяет загружать и использовать шрифты на веб-страницах, улучшая типографику и дизайн.6. Флексбокс и Grid Layout:- CSS3 вводит новые единицы и модели компоновки, такие как Flexbox и CSS Grid.Они значительно упрощают создание сложных макетов, позволяя лучше управлять расположением и размером элементов.7. Анимации иTransitions:- В CSS3 можно создавать анимации без использования JavaScript, используя свойства transition и animation. Это позволяет добавлять плавные изменения стилей и анимацию к элементам при взаимодействии с пользователем.8. Тени:- CSS3 позволяет добавлять тени к элементам с помощью свойств box-shadow и text-shadow,что дает больше возможностей для дизайна.Заключение:CSS3 представляет собой значительное улучшение по сравнению с предыдущими версиями,предоставляя разработчикам мощные инструменты для создания современных и привлекательных веб-интерфейсов.Эти улучшения делают CSS3 более адаптивным, мощным и удобным для работы,что в свою очередь улучшает пользовательский опыт и визуальную привлекательность веб-страниц.",
      "level": "Junior",
      "active": true
    },
    {
      "id": "5a8e",
      "title": "Какие новые селекторы были добавлены в CSS3? Приведите примеры.",
      "response": "В CSS3 были добавлены несколько новых селекторов, которые делают выбор элементов более гибким и точным.Вот некоторые из них с примерами использования:1. Селекторы по псевдоклассам - :nth-child(n):- Выбирает элементы, которые являются n-ыми дочерними элементами своего родителя, где n может быть числом,ключевым словом или формулой.:nth-of-type(n):- Работает аналогично :nth-child(n), но только для элементов определенного типа.:first-child и :last-child: - Селекторы для выбора первого или последнего дочернего элемента.:not(selector):- Выбирает все элементы, которые не соответствуют указанному селектору.2. Селекторы по состоянию - :hover: - Селектор для применения стилей при наведении мыши на элемент.:focus:- Селектор для элементов, находящихся в фокусе, например, при клике или при использовании клавиатуры.3. Псевдоэлементы - ::before и ::after:- Позволяют добавлять контент перед или после содержимого элемента.4. Групповые селекторы - :checked:- Выбирает элементы формы, такие как радио-кнопки или чекбоксы, которые отмечены.:disabled и :enabled:- Выбирает отключенные или включенные элементы формы.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "4cba",
      "title": "Что такое медиазапросы в CSS3, и как они используются для адаптивного дизайна?",
      "response": "Медиазапросы (media queries) в CSS3 — это мощный инструмент, который позволяет применять различные стили к документу в зависимости от определённых характеристик устройства, на котором он отображается. Это широко используется для создания адаптивного дизайна, который позволяет веб-страницам выглядеть и работать оптимально на разных устройствах, таких как мобильные телефоны, планшеты и десктопы.Основные функции медиазапросов:1. Тargeting Different Devices:- Медиазапросы позволяют определять параметры устройства, включая ширину экрана, высоту, плотность пикселей и ориентацию (пейзаж или портрет).2. Применение различных стилей:- С помощью медиазапросов возможно изменять стиль элементов в зависимости от устройства,обеспечивая лучшую читаемость и удобство пользователей.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "c8fc",
      "title": "Какие знаете методологии верстки? (БЭМ, SMACSS, ECSS, RSCSS, OOCSS)",
      "response": "1. БЭМ (Блок, Элемент, Модификатор)- Описание: БЭМ (Block, Element, Modifier) — это методология, разработанная для повышения читаемости и повторяемости кода. Она делит интерфейс на независимые блоки, которые могут быть модифицированы.- Структура:- Блок: независимый компонент (например, header, menu).- Элемент: часть блока, не имеющая смысла вне его (например, menu__item).- Модификатор: модификация блока или элемента (например, button--large, menu--open).2. SMACSS (Scalable and Modular Architecture for CSS) - Описание: SMACSS — это методология, направленная на создание масштабируемой и модульной архитектуры CSS. Она делит стили на категории и акцентирует внимание на гибкости и лёгкости поддержки.- Категории:- Baseline: основные стили для приложения.- Layout: стили для глобального макета.- Module: повторно используемые компоненты.- State: состояния элементов (например, состояние активности).- Theme: стили для различных тем оформления.3. ECSS (Essential CSS) - Описание: ECSS — это методология, фокусирующаяся на уменьшении избыточности и упрощении структуры CSS. В ней акцентируется внимание на том, что стили должны отражать структуру HTML.- Принципы:- Избегание дублирования свойств.- Минимизация вложенности.- Простота и легкость в поддержке.4. RSCSS (Reasonable System for CSS Styles)- Описание: RSCSS — это методология, которая акцентирует внимание на ясной структуре, читаемости и легкости поддержки. Она предлагает определенный набор практик для организации стилей.- Структура:- Component: ядро стиля элемента.- Modifier: изменения состояния компонента.- Namespace: пространство имен для идентификации компонентов.5. OOCSS (Object Oriented CSS) - Описание: OOCSS (Объектно-Ориентированный CSS) — это методология, которая относится к подходу к созданию интерфейсов, пропагандируемому объектно-ориентированным программированием. Основное внимание уделяется разделению структуры и внешнего вида.- Основные принципы:- Разделение структуры и кожи: стиль объектов (например, цвета, шрифты) отделяется от их структуры.- Повторное использование: максимальное использование классов для повторного использования.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "a60f",
      "title": "Шаблонизаторы css. Фреймворки на серверной стороне",
      "response": "Шаблонизаторы CSS и серверные фреймворки играют важную роль в разработке веб-приложений. Давайте рассмотрим их подробнее.Шаблонизаторы CSS Шаблонизаторы CSS позволяют использовать различные приемы для упрощения написания стилей, создания структуры и переиспользования кода. Вот несколько наиболее распространенных шаблонизаторов и препроцессоров CSS:1. Sass (Syntactically Awesome Style Sheets)- Описание: Sass добавляет к CSS переменные, вложенность, функции и миксины. Он компилируется в стандартный CSS.2.LESS - Описание: LESS также является препроцессором, который добавляет возможности работы с переменными, миксинами и вложенностью.3.Stylus - Описание: Stylus – гибкий и мощный препроцессор, позволяющий писать CSS в более краткой и удобной форме.4.PostCSS - Описание: PostCSS — это инструмент для обработки CSS с помощью JavaScript-плагинов. Он может использоваться для добавления переменных, функций и других возможностей, аналогичных Sass и LESS. - Пример использования: Использование плагинов, таких как autoprefixer для автоматического добавления вендорных префиксов.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "bcb0",
      "title": "Основные правила БЭМ. Максимальная вложенность по БЭМ. Где в БЭМ может быть каскад? Где можно использовать/где нельзя",
      "response": "Основные правила БЭМ 1. Именование:'- Используйте нижнее подчеркивание (_) для разделения блоков и элементов, а также дефис (-) для разделения слов.- Блоки именуются в единственном числе (например, menu), элементы — в форме block__element (например, menu__item), модификаторы — block--modifier или block__element--modifier (например, button--primary или menu__item--active).2. Разделение на блоки и элементы:- Блок — это независимый компонент, который может использоваться в любом месте и не зависит от других блоков.- Элемент — это часть блока, смысл которой не имеет значения вне его.3. Модификаторы:- Модификатор определяет вид, состояние или поведение блока или элемента. Он позволяет создать разные вариации одного и того же блока/элемента.4. Композиция:- БЭМ поддерживает композицию, когда один блок может содержать другие блоки. Это помогает структурировать интерфейс без излишней вложенности.5. Отсутствие каскадности:- БЭМ как методология ограничивает использование каскада. Структура классов должна быть такой, чтобы стили можно было легко переопределить без использования каскадных селекторов на основе иерархий.Максимальная вложенность по БЭМ В БЭМ рекомендованная максимальная вложенность составляет 2-3 уровня. Это позволяет избежать излишней сложности Подходы с более глубокой вложенностью усложняют понимание структуры и могут затруднить переиспользование стилей и компонентов.Где в БЭМ может быть каскад?Каскад может быть использован ограниченно, например:- Внутри блока, когда некоторые стили блока могут зависеть от состояний модификаторов. Например, вы можете использовать каскад для управления видимостью или размером элементов внутри блока  Где можно использовать/где нельзя Можно использовать:- Модификаторы для изменения стилей блока или элемента.- Стилизованные компоненты, которые не относятся к другим блокам, например, кнопки, заголовки и т. д. Нельзя использовать:- Глубокую вложенность в 4 и более уровня (это приводит к усложнению понимания и поддержки).- Применять CSS-классы через каскад на основе иерархии, чтобы избежать конфликта и непредсказуемого поведения стилей.- Избегайте избыточности — не дублируйте стили и не создавайте множество модификаторов для одной и той же функциональности.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "5f4c",
      "title": "border-box особенности, отличия от стандартного",
      "response": "Свойство box-sizing в CSS определяет, как рассчитываются размеры элемента, включая его ширину и высоту. Значение border-box — одно из возможных значений для этого свойства, и оно имеет определённые особенности по сравнению со стандартным значением content-box. Давайте рассмотрим эти особенности и отличия:box-sizing: content-box (стандартное значение)1. Оригинальное значение: Это значение является значением по умолчанию для всех элементов. Когда устанавливается ширина или высота элемента, это значение не включает границы и внутренние отступы (padding).2. Рассчет размеров: Ширина и высота (width, height) элемента рассчитываются только для внутреннего содержимого, что означает, что если вы добавляете границы или внутренние отступы, они увеличивают общий размер элемента:- Общий размер элемента = width + padding + border box-sizing: border-box 1. Границы и отступы учитываются: Когда box-sizing установлен в border-box, ширина и высота элемента включают в себя как внутренние отступы (padding), так и границы (border). Это значительно упрощает расчет размеров элемента.2. Рассчет размеров: Размеры элемента устанавливаются более интуитивно, так как они включают в себя все компоненты, и при создании макетов проще контролировать размеры элементов:- Общий размер элемента = width (включает padding и border) content-box Как считаются размеры | Только содержимое (width/height) Как рассчитывается общий размер | width + padding + border | width Интуитивность | Меньше интуитивно, требует дополнительного расчета Использование | Иногда требует дополнительных вычислений border-box Как считаются размеры | Включает содержимое, padding и border | Как рассчитывается общий размер| width равен размеру элемента, включая все | Интуитивность | Более интуитивно и удобно в верстке | Использование| Широко используется в адаптивной и гибкой вёрстке |",
      "level": "Middle",
      "active": false
    },
    {
      "id": "97f0",
      "title": "Что такое уникальность (специфичность) селектора",
      "response": "Уникальность (или специфичность) селектора в CSS — это мера того, как браузер определяет, какие стили применяются к элементу, когда к нему применяется несколько правил CSS. Специфичность помогает избежать конфликтов и обеспечивает правильное применение стилей, когда несколько селекторов совпадают с одним и тем же элементом. Она рассчитывается на основе различных типов селекторов с учётом их значимости.Как вычисляется специфичность?Специфичность определяется по системе указателей, которая складывается из разных категорий селекторов. Основные категории и их вес:1. Инлайн-стили (1, 0, 0, 0) - Такие стили применяются непосредственно в атрибуте style элемента HTML. - Пример: div style=\"color: red;\">. 2. Идентификаторы (0, 1, 0, 0) - Стили, определенные через ID селектор. У ID селекторов имеется вес одного пункта. - Пример: #header.3. Классы, псевдоклассы и атрибуты (0, 0, 1, 0) - Это селекторы классов, псевдоклассов (например, :hover, :nth-child) и атрибутов.- Пример: .menu, input[type=\"text\"].4. Теги и псевдоэлементы (0, 0, 0, 1)- Селекторы тегов (например, div, p) и псевдоэлементы (например, ::before, ::after).- Пример: p, div.menu.Как работает специфичность?Когда браузер применяет стили, он оценивает специфичность всех соответствующих селекторов. Если два или более селектора применяются к одному элементу, браузер выберет селектор с наивысшей специфичностью. Если специфичность совпадает, то последнее по порядку правило в CSS будет применено.Важные нюансы - Порядок расположения селекторов в CSS имеет значение. Если два селектора имеют одинаковую специфичность, то применяется последний из них.- Инлайн-стили имеют наивысшую специфичность и всегда будут применяться, если стилей на уровне внешнего CSS недостаточно.- Чтобы определить, какой стиль применяется, удобно использовать инструменты разработчика в браузере.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "900d",
      "title": "Какой атрибут делает поле формы обязательным для заполнения?",
      "response": "Чтобы сделать поле формы обязательным для заполнения в HTML, используется атрибут required. Когда этот атрибут добавлен к элементу формы (например, к input>, textarea>, или select>), браузер будет проверять, заполнено ли это поле перед отправкой формы.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "db4c",
      "title": "Важны ли стили для SEO?",
      "response": "Стили (CSS) не влияют напрямую на SEO (поисковую оптимизацию) с точки зрения ранжирования в поисковых системах, но они играют косвенно важную роль в улучшении общего пользовательского опыта и восприятии сайта. Вот несколько аспектов, в которых стили могут повлиять на SEO:1. Пользовательский опыт - Время загрузки: Оптимизированные стили могут способствовать более быстрому рендерингу страницы. Быстро загружающиеся сайты с хорошей версткой предлагают лучший пользовательский опыт, что может положительно сказаться на ранжировании. - Читабельность: Хорошо оформленный текст (например, размер шрифта, цвет, контраст) повышает читабельность, что может снизить показатель отказов и повысить время, проведенное на сайте.2. Мобильная адаптация- Отзывчивый дизайн: Стили, которые обеспечивают адаптацию сайта под различные устройства (мобильные, планшеты, компьютеры), важны для SEO, поскольку Google учитывает мобильную версию сайта при поисковой индексации и ранжировании.- Мобильный пользовательский опыт: Если CSS сайта хорошо оптимизирован и делает контент удобным для просмотра на мобильных устройствах, это может positively wow пользовательский опыт, что тоже важно для SEO.3. Структура страницы - Грамотное использование HTML и CSS: Стили могут помочь создать более понятную структуру страницы. Например, использование списков, заголовков и других семантических элементов помогает поисковым системам лучше индексировать контент.- Классные селекторы: Правильное применение классов и идентификаторов может позволить вам легко управлять контентом и выделять важные элементы, которые могут быть полезны для SEO.4. Индексация - Скрытый контент: Некоторые стили могут использоваться для скрытия контента (например, display: none). Если поисковые системы найдут такой скрытый контент, это может негативно сказаться на вашем SEO, особенно если они сочтут это попыткой манипуляции.- Кроссбраузерная совместимость: Хорошо стилизованный сайт, который выглядит и работает одинаково хорошо во всех браузерах, повышает вероятности, что пользователи не будут сталкиваться с проблемами, которые могли бы уменьшить их доверие к сайту.",
      "level": "Senior",
      "active": false
    },
    {
      "id": "8203",
      "title": "Что такое препроцессор? Приведите примеры препроцессоров.",
      "response": "Препроцессор — это инструмент, который предварительно обрабатывает исходный код, написанный на одном языке, переводя его в другой язык или в простой машинный код. Препроцессоры часто используются в веб-разработке для улучшения структуры, читаемости и удобства работы с кодом. Они позволяют применять различные функциональные возможности, такие как переменные, вложенные правила, функции и миксины, что делает написание и сопровождение кода более эффективным.Вот примеры самых распространенных типов препроцессоров:1. CSS-препроцессоры - Sass (Syntactically Awesome Style Sheets):- Sass добавляет в CSS такие возможности, как переменные, вложенность, миксины, функции и другие.- LESS:- LESS также поддерживает такие возможности, как переменные, вложенность, операции и логические условные конструкции.- Stylus:- Stylus — это гибкий и мощный CSS-препроцессор, который сильно отличается от обычного CSS, позволяя писать менее явный код.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "8390",
      "title": "Миксины в less",
      "response": "Миксины в Less — это один из ключевых инструментов, который позволяет повторно использовать группы стилей в вашем CSS-коде. Они более удобны, чем простые классы, так как позволяют инкапсулировать стиль и применять его к различным элементам. Это особенно полезно при создании сложных стилей, которые могут применяться к нескольким селекторам или в разных контекстах.Основные характеристики миксинов в Less:1. Определение миксина: Миксин определяется с помощью специального синтаксиса, используя имя миксина, за которым следует перечень свойств.2. Параметры: Миксины могут принимать параметры, что позволяет делать их более гибкими и адаптируемыми к различным условиям.3. Наследование: Миксины могут наследовать другие миксины, что способствует уменьшению дублирования кода.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "d678",
      "title": "Амперсанд (&) в less",
      "response": "В Less символ амперсанда (&) используется для обозначения родительского селектора в контексте вложенных стилей. Это позволяет создавать более структурированные и организованные правила CSS, избегая дублирования кода и делая его более читабельным. Рассмотрим подробнее, как и где можно использовать амперсанд в Less.Основные применения амперсанда (&) в Less 1. Вложенные селекторы:Амперсанд позволяет обращаться к родительскому селектору внутри вложенных правил. Это особенно полезно при создании комбинаций классов или когда нужно изменить свойства в зависимости от состояния элемента.2. Использование с псевдоклассами и псевдоэлементами:Вы можете использовать амперсанд, чтобы добавить псевдоклассы или псевдоэлементы к текущему селектору 3. Комбинированные селекторы:Используя амперсанд, вы можете создать более сложные селекторы без дублирования кода.4. Миксины с амперсантом:Амперсанд также можно использовать внутри миксинов, что позволяет использовать родительский селектор в различных контекстах.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "ae04",
      "title": "Что такое постпроцессор? Как пост-процессор работает «под капотом»?",
      "response": "Постпроцессор — это инструмент, который работает с уже скомпилированным CSS-кодом, добавляя дополнительные преобразования и оптимизации. В отличие от препроцессора, который модифицирует исходный код на этапе его написания и компиляции (например, Sass, Less, Stylus), постпроцессор обрабатывает уже готовый CSS-файл, выполняя различные задачи, такие как оптимизация, добавление вендорных префиксов, минификация и другие преобразования. Примеры популярных постпроцессоров 1. PostCSS — это самый распространенный инструмент для постобработки CSS. Он предоставляет API для создания плагинов, что позволяет добавлять функциональность.2. Autoprefixer — это плагин для PostCSS, который автоматически добавляет вендорные префиксы к CSS-свойствам, чтобы обеспечить кросс-браузерную совместимость.3. CSSNano — постпроцессор, который минифицирует CSS для уменьшения размера файлов и увеличения скорости загрузки.Как постпроцессор работает «под капотом»?1. Чтение исходного CSS: Постпроцессор сначала считывает уже скомпилированный CSS-файл, который необходимо обработать.2. Парсинг: Код CSS разбивается на абстрактное синтаксическое дерево (AST, Abstract Syntax Tree). AST — это структура данных, представляющая иерархические отношения между элементами CSS.3. Обработка через плагины: Постпроцессоры часто используют плагины для выполнения различных преобразований. Например:- Вендорные префиксы: Проверка свойств на необходимость добавления префиксов с помощью формул, определяющих, для каких браузеров и версий это требуется.- Минификация: Удаление пробелов, комментариев и сокращение длинных свойств для уменьшения размера файла.4. Генерация итогового CSS: После применения всех заданных преобразований, постпроцессор формирует окончательный CSS-код, который затем может быть записан в файл или использован в браузере.",
      "level": "Senior",
      "active": false
    },
    {
      "id": "4ac5",
      "title": "Расскажите как работает z-index? Если z-index не задан?",
      "response": "z-index — это CSS-свойство, которое контролирует порядок наложения элементов в трехмерном пространстве веб-страницы. Оно определяет, какой элемент будет располагаться \"над\" или \"под\" другим элементом, когда они накладываются друг на друга. Чтобы правильно понять, как работает z-index, нужно учитывать несколько вещей.Основные понятия 1. Контекст наложения:- z-index работает только в пределах контекста наложения. Контекст наложения создается для элементов, имеющих определенные свойства position (например, relative, absolute, fixed или sticky) и с заданным значением z-index.- Каждый элемент с position и определенным z-index образует собственный контекст наложения для его потомков.2. Значения z-index:- z-index принимает целые числа, включая отрицательные значения. Больше значение z-index означает, что элемент будет находиться выше (ближе к зрителю) по сравнению с элементами с меньшими значениями z-index.- Например, если у вас есть три элемента с z-index: 1, z-index: 2, и z-index: 3, элемент с z-index: 3 будет находиться выше остальных.3. Автоматическое поведение:- Если z-index не задан, элементы располагаются на основание порядка их размещения в HTML-документе. Элементы, которые расположены в документе позже, будут отображаться выше тех, которые расположены раньше. Например, если у вас есть два перекрывающихся элемента, и ни один из них не имеет установленных z-index, тот, который написан после другого в HTML, будет виден сверху.Заданный z-index:- Элементы с установленными значениями z-index и соответствующими позициями могут перекрывать другие элементы.- Не заданный z-index:- Если у элемента не установлен z-index, но он имеет position, он будет принимать значение z-index: auto по умолчанию. При этом он будет помещён в порядок наложения в соответствии с его положением в документе и контекстом наложения.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "f0e0",
      "title": "Зачем нужны mediaQueries?",
      "response": "Media queries (медиа-запросы) — это важный инструмент в CSS, предназначенный для создания адаптивных и отзывчивых веб-дизайнов. Они позволяют изменять стиль веб-страницы в зависимости от различных характеристик устройства, на котором она отображается. Вот основные причины, зачем нужны media queries:1. Адаптивный дизайн Медиа-запросы позволяют разработчикам создавать адаптивные макеты, которые могут автоматически изменять свое отображение в зависимости от размера экрана устройства. Это помогает обеспечить удобство использования на мобильных устройствах, планшетах и настольных компьютерах.2. Оптимизация пользовательского опыта С помощью медиа-запросов можно изменять элементы интерфейса, такие как размеры шрифтов, отступы, расположение изображений и многое другое, чтобы улучшить пользовательский опыт в зависимости от устройства. Например, на мобильных устройствах можно сделать текст более крупным и уменьшить количество столбцов в сетке. 3. Перегрузка контента Медиа-запросы позволяют включать или отключать определенные стили, изображения и другие элементы в зависимости от размера экрана или других параметров устройства. Например, можно загружать менее тяжелые изображения для мобильных устройств, чтобы сократить время загрузки. 4. Контроль за производительностью Используя медиа-запросы, разработчики могут оптимизировать производительность сайта, загружая только нужные стили и контент в зависимости от устройства. Это особенно важно для мобильных пользователей с ограниченным доступом к данным.5. Поддержка различных разрешений и ориентаций Медиа-запросы позволяют адаптировать дизайн в зависимости от разрешения экрана и ориентации устройства (портретная или альбомная). Это особенно актуально для планшетов и смартфонов, которые могут работать в разных режимах.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "64c1",
      "title": "Чем отличается {display: none} от {visibility: hidden}",
      "response": "Свойства CSS {display: none} и {visibility: hidden} часто используются для управления видимостью элементов на веб-странице, но они имеют разные эффекты на элементы и их поведение в документе. Вот основные различия между ними:1. Отображение элемента - {display: none}: - Убирает элемент из потока документа. Элемент не будет отображаться на странице, и он не будет занимать место. Это означает, что соседние элементы могут занять место, которое было освобождено. - {visibility: hidden}: - Скрывает элемент, но элемент по-прежнему занимает место в потоке документа. То есть, пространство, которое он занимал, остается, но содержимое не отображается.2. События - {display: none}: - Элементы с этим стилем не участвуют в обработке событий. Например, на них не срабатывают клики или другие события мыши.- {visibility: hidden}:- Скрытые элементы по-прежнему могут обрабатывать события (например, на них можно назначить обработчики), но поскольку они невидимы, пользователи не могут с ними взаимодействовать.3. Использование в анимации - Элементы с {visibility: hidden} могут использоваться в анимациях, так как они по-прежнему существуют в DOM-дереве.  Элементы с {display: none} не могут участвовать в анимации, поскольку они полностью убираются из DOM. 4. Примеры использования - {display: none} подходит для случаев, когда необходимо полностью удалить элемент с экрана, например, скрытие модальных окон или переключение между вкладками.- {visibility: hidden} может быть использовано, например, для временного скрытия элементов интерфейса (таких как подсказки), где важно сохранить место в компоновке страницы.Когда вы выбираете между {display: none} и {visibility: hidden}, определите, требуется ли вам сохранить место для элемента в потоковой компоновке. Если элемент не должен занимать место — используйте {display: none}. Если нужно скрыть его, но сохранить место — используйте {visibility: hidden}.",
      "level": "Senior",
      "active": false
    },
    {
      "id": "a30b",
      "title": "Что такое свойство Position",
      "response": "Свойство position в CSS определяет, как элемент будет позиционирован на странице, а также взаимодействие с другими элементами в документе. Оно играет важную роль в компоновке веб-страниц. Значения свойства position определяют контекст позиционирования для элемента.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "13ea",
      "title": "Назовите возможные свойства position",
      "response": "1. static - Это значение по умолчанию для всех элементов. Элементы с position: static располагаются в естественном потоке документа. Позиционирование не зависит от других элементов.- Свойства top, right, bottom, и left для таких элементов игнорируются. 2. relative - Элемент позиционируется относительно своего нормального положения в потоке документа. - Если задать свойства top, right, bottom, или left, элемент будет смещен от его первоначального положения, но при этом займет свое обычное место в потоке, и другие элементы будут вести себя так, будто он находится в своём исходном месте.3.. absolute - Элемент позиционируется относительно ближайшего предка с ненормальным (то есть не static) позиционированием. Если таких предков нет, элемент будет позиционироваться относительно окна обозревателя (viewport).- При использовании position: absolute элемент вынимается из потока документа, то есть не занимает места, и другие элементы будут располагаться так, как будто его нет.4. fixed - Элемент фиксирован в отношении окна браузера, а не потока документа. Это означает, что он останется на одном и том же месте экрана при прокрутке страницы.- Также вынимается из потока документа, как и элемент с position: absolute.5. sticky - Элемент ведёт себя как relative, пока не достигнет определённой позиции прокрутки, после чего ведет себя как fixed. - Это означает, что элемент будет оставаться в своем нормальном положении до тех пор, пока его верхняя граница не достигнет верхней части viewport, после чего он будет оставаться на месте при дальнейшей прокрутке.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "77c3",
      "title": "Объясните, что такое Flexbox и как он упрощает работу с расположением элементов на странице",
      "response": "Flexbox (Flexible Box Layout) — это модель компоновки CSS, предназначенная для более эффективного распределения пространства и выравнивания элементов в контейнерах, даже когда их размер неизвестен или динамически меняется. Flexbox предоставляет гибкий и интуитивно  понятный способ управления расположением элементов, что значительно упрощает создание адаптивных и отзывчивых дизайнов. Основные характеристики Flexbox:1. Гибкость: Flexbox позволяет элементам внутри контейнера изменять свои размеры и порядок в зависимости от доступного пространства, что обеспечивает гибкость макета.2. Выравнивание: Flexbox облегчает выравнивание элементов по горизонтали и вертикали, позволяя  разработчикам быстро выравнивать элементы по центру, краям или между собой. 3. Перенос элементов: Элементы могут быть легко перенесены на новую строку или в колонку, что полезно для адаптивных макетов.4. Простота управления: Flexbox делает управление пространством между элементами более понятным и простым.Можно задать отступы и размеры, которые автоматически адаптируются.Основные компоненты Flexbox:1. Контейнер Flexbox: Элемент, к которому применяются свойства Flexbox. Это родительский элемент, содержащий дочерние элементы (flex items).2. Элементы Flexbox: Дочерние элементы контейнера, которые будут управляться с помощью Flexbox.Основные свойства Flexbox:CSS-свойства для контейнера:- display: flex;: Применяет модель Flexbox к элементу.- flex-direction: Определяет направление расположения элементов (по умолчанию — row).- Примеры:- row — элементы располагаются по горизонтали.- column — элементы располагаются по вертикали.- justify-content: Устанавливает выравнивание элементов по главной оси.- Примеры:- flex-start — выравнивание по началу.- flex-end — выравнивание по концу.- center — центрирование.- space-between — равномерное распределение с отступами между элементами.- space-around — равномерное распределение с отступами вокруг элементов.- align-items: Устанавливает выравнивание по поперечной оси.- Примеры:- flex-start — выравнивание по верхнему краю.- flex-end — выравнивание по нижнему краю.- center — вертикальное центрирование.- stretch — растяжение элементов на весь доступный размер.CSS-свойства для элементов:- flex-grow: Определяет, как элемент может расти, чтобы заполнить доступное пространство.- flex-shrink: Определяет, как элемент может сжиматься, чтобы избежать переполнения контейнера.- flex-basis: Устанавливает начальный размер элемента перед распределением пространства.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "ea99",
      "title": "В чем разница между display: block, display: inline, и display: inline-block?",
      "response": "- display: block: Элемент занимает всю ширину, начинается с новой строки, подходит для заголовков,абзацев и других блочных элементов.- display: inline: Элемент занимает только необходимую ширину, не начинается с новой строки, подходит для текста и других элементов, где не требуется контроль высоты.- display: inline-block: Элемент располагается рядом с другими элементами, не начиная новую строку,но может иметь заданную ширину и высоту, что делает его полезным для создания адаптивных интерфейсов.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "efe1",
      "title": "Как работают трансформации (transform) и трансляции (transition) в CSS3? Приведите примеры использования.",
      "response": "В CSS3 трансформации и трансляции — это два мощных инструмента,которые позволяют изменять положение, размер, угол и другие свойства элементов на веб-странице с помощью эффектов анимации и визуальных преобразований.1. Трансформации (transform) Свойство transform позволяет изменять 2D и 3D представления элементов.Оно может использоваться для таких преобразований, как:- Поворот (rotate) - Масштабирование (scale) - Перемещение (translate) - Наклон (skew) 2. Трансляции (transition) Свойство transition обеспечивает плавный переход между состояниями CSS. Оно позволяет контролировать изменение других CSS-свойств со временем (например, цвет, размер, положение или трансформацию).Вы можете указать время перехода, тип временной функции (ease, linear, ease-in и т. д.)  и свойства, к которым применяется переход.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "ea62",
      "title": "Что такое градиенты в CSS3 и как их можно использовать? Приведите пример градиента.",
      "response": "Градиенты в CSS3 — это плавные переходы между двумя или более цветами, которые могут использоваться в качестве фонов, заливок и других визуальных эффектов в веб-дизайне.Градиенты позволяют создавать красивые и современные эффекты, добавляя глубину и стиль на страницы без необходимости использования изображений.Типы градиентов в CSS:1. Линейные градиенты (linear-gradient):Линейный градиент плавно переходит между цветами в заданном направлении,которое можно определить с помощью угла или ключевых слов (например, to right, to bottom и т. д.).2. Радиальные градиенты (radial-gradient):Радиальный градиент создаёт эффект перехода от центра к внешним краям в виде круга или эллипса.Линейные градиенты:- direction: направление градиента (например, to right, to bottom, или угол в градусах).- color-stop: цветовые точки, которые определяют цвета градиента.Радиальные градиенты:- shape: форма градиента (например, circle или ellipse).- size: размер градиента (например, farthest-corner или closest-side).- position: положение градиента (например, center).- color-stop: цветовые точки.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "9049",
      "title": "Как использовать псевдоэлементы и псевдоклассы в CSS3? Приведите примеры",
      "response": "Псевдоэлементы и псевдоклассы в CSS3 — это мощные инструменты, которые позволяют нацеливаться на определённые части элементов или состояния элементов без изменения HTML-код. Это особенно полезно для создания стилизованных интерфейсов и улучшения внешнего вида страниц. Псевдоэлементы Псевдоэлементы позволяют стилизовать определённые части элемента. В CSS3 существуют следующие псевдоэлементы:- ::before — добавляет содержимое перед содержимым элемента. - ::after — добавляет содержимое после содержимого элемента. - ::first-line — стилизует первую строку текста элемента.- ::first-letter — стилизует первую букву текста.Псевдоклассы Псевдоклассы применяются к элементам на основе их состояния или положения в документе.Вот несколько распространённых псевдоклассов:- :hover — применяется, когда курсор находится над элементом.- :focus — применяется, когда элемент имеет фокус (например, поле ввода).- :nth-child(n) — выбирает элементы по их порядковому номеру.- :first-child — применяет стиль к первому дочернему элементу.- :last-child — применяет стиль к последнему дочернему элементу.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "ec55",
      "title": "Что такое свойства box-shadow и text-shadow и как они работают?",
      "response": "Свойства box-shadow и text-shadow в CSS используются для создания теней вокруг объектов и текста соответственно. Эти свойства помогают добавить глубину и объем на веб-страницы,улучшая визуальное восприятие элементов.1. Свойство box-shadow Свойство box-shadow добавляет тень к элементам блоков . Оно определяет, как будет выглядеть тень, и имеет следующий синтаксис:(box-shadow: h-offset v-offset blur-radius spread-radius color;)- h-offset: Горизонтальное смещение тени (положительное значение смещает в право, отрицательное — влево).- v-offset: Вертикальное смещение тени (положительное значение смещает вниз, отрицательное — вверх)- blur-radius: Радиус размытия тени (чем больше значение, тем более размытой будет тень)- spread-radius: Радиус распространения тени (положительное значение увеличивает размер тени, отрицательное — уменьшает).- color: Цвет тени (возможно использование любых форматов цвета, например, HEX, RGB, RGBA и т.д.).Свойство text-shadow Свойство text-shadow используется для добавления теней к тексту. Синтаксис следующий:text-shadow: h-offset v-offset blur-radius color;- h-offset: Горизонтальное смещение тени (как и для box-shadow).- v-offset: Вертикальное смещение тени (как и для box-shadow).- blur-radius: Радиус размытия тени (помимо этого, увеличивает глубину).- color: Цвет тени.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "cccd",
      "title": "Объясните, как делать анимации с помощью CSS3. Каковы различные ключевые кадры (keyframes)?",
      "response": "Анимации в CSS3 позволяют создавать плавные переходы между состояниями элементов на веб-странице,добавляя динамическое взаимодействие и визуальный интерес.Для создания анимаций в CSS3 используется свойство animation и ключевые кадры (keyframes), которые определяют,как элемент будет выглядеть в разные моменты времени.Синтаксис анимации Чтобы создать анимацию, вам нужно выполнить следующие основные шаги:1. Определить ключевые кадры с помощью правила @keyframes.2. Применить анимацию к элементу с помощью свойства animation.1. Определение ключевых кадров Правило @keyframes позволяет задать анимацию, описывая, как элемент должен выглядеть на разных этапах анимации. Репрезентация анимации может включать множество ключевых кадров, но обычно используются два основных состояния: начальное (0%) и конечное (100%).Применение анимации Чтобы использовать определённые ключевые кадры, необходимо применить их к элементу с помощью свойства animation. Свойство animation Свойство animation может включать различные параметры: - animation-name: имя анимации (например, example) - animation-duration: длительность анимации (например, 4s или 2s) - animation-timing-function: функция временной анимации (например, linear, ease, ease-in, ease-out) - animation-delay: время задержки перед началом анимации - animation-iteration-count: количество повторений анимации (например, infinite или 3) - animation-direction: направление анимации (например, normal, reverse, alternate, alternate-reverse) - animation-fill-mode: определяет, как будет выглядеть элемент после окончания анимации (например, forwards, backwards)",
      "level": "Junior",
      "active": false
    },
    {
      "id": "ce3d",
      "title": "Что такое CSS-препроцессоры и почему они были созданы?",
      "response": "CSS-препроцессоры — это инструменты, которые расширяют возможности стандартного CSS,добавляя дополнительные функции и улучшая структуру стилей. Они предназначены для упрощения процесса написания и управления стилями в крупных проектах. К популярным CSS-препроцессорам относятся SASS (Syntactically Awesome Style Sheets), LESS и Stylus. Основные причины возникновения CSS-препроцессоров:1. Улучшение структуры кода Препроцессоры позволяют использовать вложенные правила, что делает код более читаемым и понятным.Это позволяет легко организовывать и управлять стилями, особенно в крупных проектах с иерархическими структурами.2. Повторно используемые стили:Препроцессоры поддерживают использование переменных, миксинов и функций, что позволяет избежать дублирования кода и легко обновлять стили в рамках проекта.3.Модулярность:Многие препроцессоры поддерживают возможность разбивки стилей на отдельные, более мелкие файлы, которые затем можно импортировать в основной файл. Это помогает организовать проект и улучшает управляемость кода.4.Расширенные функции и инструменты: Препроцессоры предлагают дополнительные функции, такие как математические операции,условные конструкции и циклы. Это позволяет создавать более динамичные и сложные стили.5. Упрощение управления стилями:Благодаря использованию функций, переменных и других функций, управление стилями становится более гибким и простым.Это особенно полезно в крупных проектах, где необходимо быстро вносить изменения.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "3a55",
      "title": "Объясните основные преимущества использования SASS в проекте.",
      "response": "SASS (Syntactically Awesome Style Sheets) — это один из самых популярных CSS-препроцессоров, который добавляет множество возможностей для написания стилей. Вот основные преимущества использования SASS в проектах:1. Вложенность SASS поддерживает вложенные правила, что позволяет организовать стили в логической иерархии,отражающей структуру HTML. Это делает код более читабельным и упрощает его поддержку.2. Переменные SASS позволяет использовать переменные, что упрощает управление значениями, такими как цвета, размеры шрифтов и другие параметры.Это также позволяет избежать дублирования кода.3. Миксины Миксины (mixins) позволяют создавать наборы стилей, которые можно повторно использовать по всему проекту,передавая им переменные.Это особенно удобно для стилизации повторяющихся элементов или условий.4. Функции SASS предоставляет встроенные функции для выполнения вычислений и манипуляций со значениями, а также возможность  создавать свои собственные функции.Это упрощает создание сложных стилей и взаимодействие с математикой.5. Парциальные файлы и импорты SASS позволяет разбивать стили на парциальные файлы, которые можно импортировать в основной файл.Это делает структуру проекта более организованной и облегчает управление стилями.6. Расширяемость (Extend) С помощью директивы @extend можно делиться стилями между классами, что позволяет избежать дублирования кода и упрощает обновление стилей.7. Сложные селекторы SASS позволяет использовать сложные селекторы с логическими условиями и операциями, что делает код более выразительным.8. Временные функции С помощью временных функций можно создавать анимации и переходы с динамическими значениями,что упрощает их написание и чтение.9. Улучшенная читаемость SASS упрощает написание кода и делает его более понятным, что особенно важно для  командной работы и поддержки проектов.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "6a40",
      "title": "Каковы основные синтаксические отличия между SASS и LESS?",
      "response": "SASS и LESS — это два популярных CSS-препроцессора, и хотя они оба предназначены для расширения возможностей CSS,они имеют различные синтаксические особенности. Давайте рассмотрим основные синтаксические отличия между SASS и LESS:1. Синтаксис- SASS SASS использует отступы вместо фигурных скобок и точек с запятой для определения блоков кода. Это работает как синтаксис, основанный на отступах, что делает код более чистым и читабельным.- LESS:LESS требует фигурные скобки и точки с запятой для определения блоков и завершения строк,что делает его ближе к привычному синтаксису CSS.2. Переменные - Объявление переменной: В SASS переменные обозначаются с помощью знака доллара  - LESS: Переменные обозначаются с помощью @ а присваивается (:) 3. Миксины в SASS 3.1. Объявление миксина: В SASS миксины объявляются с помощью директивы @mixin, за которой следует имя миксина и его параметры (если они есть).- Использование миксина: Для применения миксина в селекторе используется директива @include.3.2. Миксины в LESS - Объявление миксина: В LESS создается миксин через класс или с помощью функции, и для определения параметров используются символы @. - Использование миксина: Миксин вызывается простым обращением к его имени, за которым следуют переданные параметры в круглых скобках.3.3. Основные отличия между SASS и LESS - Синтаксис:- В SASS используется директива @mixin для объявления и @include для использования. Это выглядит несколько более формально.- В LESS миксины объявляются как функции и применяются просто как класс: мы вызываем имя миксина как из класса.- Вложенность:- В SASS можно вызывать миксины внутри других миксинов, и это можно делать на любом уровне вложенности.- В LESS тоже поддерживается вложенность, но как в функциях с параметрами, так и в точности, как в обычных классах.- Поддержка параметров:- Оба препроцессора поддерживают параметры для миксинов, однако в SASS можно задавать параметры по умолчанию и использовать @content для передачи дополнительных стилей.4. Наблюдение за изменениями и вложенными правилами - Оба препроцессора поддерживают вложенные правила, но SASS имеет более развитую функциональность благодаря директиве @extend, которая позволяет делиться стилями между классами, избегая дублирования.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "0476",
      "title": "Объясните концепцию переменных в SASS и LESS. Приведите пример.",
      "response": "Концепция переменных в SASS и LESS заключается в возможности хранения значений,таких как цвета, размеры шрифтов или любые другие значения, которые могут быть использованы многократно в стилях. Это улучшает управляемость,читабельность и поддержку кода, так как позволяет вносить изменения в единое место, а не искать каждое вхождение в коде.- Гибкость: Оба препроцессора позволяют использовать переменные в любом месте, где ожидается значение,однако SASS предлагает дополнительные возможности,такие как ссылки на переменные в миксинах и использование переменных как параметров с заданием значений по умолчанию.",
      "level": "Senior",
      "active": false
    },
    {
      "id": "aabf",
      "title": "Что такое вложенность правил (nesting), и как она работает в препроцессорах?",
      "response": "Вложенность правил (nesting) — это концепция, которая позволяет разработчикам писать CSS-правила внутри других CSS-правил, создавая структурированное и иерархическое представление стилей.Эта возможность значительно улучшает читаемость и организацию кода, позволяя легче видеть, как стили группируются и применяются к различным элементам страницы.Как работает вложенность в SASS и LESS Вложенность в SASS В SASS вложенность реализуется путем написания селекторов внутри других селекторов.Это делает код более логичным и удобным для восприятия. Вложенность в LESS В LESS вложенность работает аналогично. Вы можете писать селекторы внутри других  селекторов, что также делает структуру кода более понятной Основные преимущества вложенности 1. Упрощенная структура: Позволяет быстрее находить и редактировать связанные стили,поскольку визуально они находятся рядом друг с другом.2. Лучшая читабельность: Код становится более понятным и структурированным, что упрощает работу с большими стилевыми файлами. 3. Избежание дублирования: Вложенные правила позволяют избежать повторного написания общего селектора,сохраняя стильный код чистым и организованным.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "66da",
      "title": "Как работают миксины (mixins) в SASS и LESS, и для чего они используются?",
      "response": "Миксины (mixins) — это одна из ключевых функций препроцессоров CSS, таких как SASS и LESS, которые позволяют разработчикам создавать повторно используемые группы CSS-правил. Миксины помогают избегать дублирования кода, улучшая поддержку и организацию стилей. Давайте подробно рассмотрим, как работают миксины в SASS и LESS, а также их использование и преимущества. 1. Миксины в SASS Объявление миксина:В SASS миксин создается с помощью директивы @mixin, за которой следует имя миксина и его параметры (при необходимости).Использование миксина:Для применения миксина в стиле используется директива @include.Как работают миксины в LESS: Объявление миксина:Миксин объявляется с помощью имени с параметрами (при необходимости) и фигурных  скобок, в которых содержатся стили. Параметры могут быть опциональными и могут иметь значения по умолчанию.Использование миксина:Чтобы использовать миксин в другом селекторе, просто вызовите его имя как функцию,передав необходимые параметры в круглых скобках.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "37c9",
      "title": "Что такое функции и операции в SASS? Приведите примеры их использования.",
      "response": "Функции и операции в SASS являются мощными инструментами для выполнения вычислений и манипуляций с данными,что позволяет создавать более динамичные и гибкие стили . Давайте подробнее рассмотрим каждую из этих концепций и приведем примеры их использования.1. Функции в SASS Функции в SASS позволяют выполнять определенные манипуляции с данными и возвращать результат.SASS предоставляет множество встроенных функций для работы с цветами, математикой, строками и другими типами данных.Кроме того, разработчики могут создавать свои собственные функции.Примеры встроенных функций:- lighten: осветляет цвет.- darken: затемняет цвет.- multiply: умножает два значения.- round: округляет число.2. Операции в SASS Операции в SASS позволяют выполнять математические вычисления с числами и длинами.Например, вы можете складывать, вычитать, умножать и делить значения, что упрощает создание ыадаптивных и динамических дизайнов.Создание пользовательской функции Вы также можете создавать свои собственные функции в SASS для выполнения специфических задач. Для этого используется директива @function.Примеры операций:- Сложение (+) - Вычитание (-)- Умножение (*)- Деление (/)",
      "level": "Middle",
      "active": false
    },
    {
      "id": "4255",
      "title": "Объясните, что такое \"partials\" в SASS и как их можно использовать для организации кода.",
      "response": "Partials в SASS — это специальные Sass-файлы, которые предназначены для хранения частей стилей, которые можно импортировать в другие файлы SASS. Это позволяет организовать CSS-код,делая его более структурированным и легким в обслуживании. Используя partials, вы можете разбить ваш CSS на меньшие, управляемые файлы и избежать дублирования кода.Преимущества использования partials в SASS:1. Организация кода: Разделение стилей на логические блоки (например, для различных компонентов,страниц или секций), что упрощает навигацию и редактирование.2. Упрощение поддержки: Легче находить и менять стили, так как каждый файл отвечает за отдельный аспект или часть дизайна.3. Повторное использование: Вы можете импортировать одни и те же partials в нескольких файлах, что снижает дублирование кода.4. Лучшие рабочие практики: Меньшие файлы с ограниченным количеством кода легче тестировать,понимать и расширять.Как использовать partials:1. Создание partials:Назовите ваши partials с префиксом подчеркивания (_), чтобы обозначить, что это только часть  стилей, а не полный файл CSS. Например, вы можете создать следующие файлы:- _variables.scss (для хранения переменных) - _mixins.scss (для хранения миксинов) - _buttons.scss (для стилизации кнопок) - _header.scss (для стилизации заголовка) - _footer.scss (для стилизации подвала) 2. Импорт partials: Используя команду @import, вы можете подключить созданные partials в основном файле стилей.3. Сборка файла:После компиляции SASS в ваш основной файл (например, main.css), все стили из импортированных файлов будут собраны и скомпилированы в один CSS-файл.Использование partials в SASS позволяет организовать стили более структурированно и управляемо.Вы сможете легко поддерживать и развивать ваш проект, обращаясь к отдельным частям стилей, без излишнегодублирования кода. Разделение кода на partials соответствует принципам модульности и лучшим практикам разработки,что значительно улучшает процесс работы с CSS.",
      "level": "Senior",
      "active": false
    },
    {
      "id": "fd28",
      "title": "Как происходит компиляция файлов SASS или LESS в CSS? Какие инструменты вы можете использовать для этого?",
      "response": "Компиляция файлов SASS или LESS в CSS — это процесс преобразования стилей,написанных с использованием этих препроцессоров, в стандартный CSS, который браузеры могут интерпретировать. Этот процесс необходим, поскольку браузеры не поддерживают SASS или LESS напрямую,так как это расширенные синтаксисы для написания CSS.Как происходит компиляция 1. Написание стилей: Вы создаете файлы с помощью SASS (с расширением .scss или .sass) или LESS (с расширением .less).2. Запуск компилятора: Используя специальный инструмент или командную строку, вы запускаете компилятор, который обрабатывает ваш SASS или LESS код.3. Обработка файла: Компилятор считывает ваш файл, анализирует его, выполняет все определенные функции, операции, миксины и partials, и затем генерирует итоговый CSS-файл.4. Вывод: Скомпилированный CSS-файл сохраняется на диск и может быть подключен к HTML-документу.Инструменты для компиляции Существует несколько инструментов, которые можно использовать для компиляции SASS и LESS в CSS:1. CLI-компиляторы - SASS CLI: Официальный компилятор для SASS можно установить через npm или использовать предварительно собранные бинарники.npm install -g sass sass input.scss output.css - LESS CLI: Аналогичный подход можно использовать для LESS. npm install -g less less input.less output.css 2. Сборщики проектов - Webpack: С помощью плагинов, таких как sass-loader и less-loader, вы можете интегрировать SASS и LESS в сборку вашего проекта.npm install sass-loader css-loader style-loader --save-dev - Gulp: Это задача для автоматизации, которая позволяет писать задачи для компиляции SASS и LESS. Плагины gulp-sass и gulp-less могут помочь в этом.  npm install gulp gulp-sass gulp-less --save-dev - Grunt: Используйте плагины grunt-sass и grunt-contrib-less для компиляции SASS и LESS.npm install grunt-sass grunt-contrib-less --save-dev 3. Расширения и плагины для редакторов - Visual Studio Code: Существуют расширения, такие как Live Sass Compiler и Easy LESS, которые позволяют компилировать файлы в реальном времени.  - Atom и Sublime Text: Поддерживают плагины для SASS и LESS, которые позволяют  компилировать код непосредственно из редактора.4. Инструменты для разработки - CodeKit: Это приложение для macOS, которое автоматически компилирует файлов SASS и LESS при их изменении.- Prepros: Многофункциональный инструмент, которые позволяет компилировать SASS  и LESS (и другие препроцессоры) с поддержкой Live Reload.",
      "level": "Senior",
      "active": false
    },
    {
      "id": "e4b7",
      "title": "Что такое @import в SASS и LESS, и как он помогает в управлении файлами стилей?",
      "response": "Директива @import в SASS и LESS — это механизм, который позволяет импортировать и объединять файлы стилей, что существенно облегчает управление и организацию кода. Рассмотрим, как она работает в каждом из препроцессоров  и как помогает в управлении файлами стилей. 1. @import в SASS В SASS директива @import используется для включения одного SASS-файла в другой.Это позволяет разбить код на логические части и упрощает его организацию.SASS автоматически компилирует все импортированные файлы в один CSS-файл.2. @import в LESS В LESS также используется директива @import для объединения различных файлов. Подобно SASS, это позволяет структурировать код и облегчить его поддержку и расширение. Преимущества использования @import 1. Организация кода: Использование @import позволяет разбить код на логические части, что делает его более понятным и структурированным.2. Управление зависимостями: Импортируя файлы с переменными, миксинами и стилями,вы можете легко управлять зависимостями между различными частями кода.3. Переиспользование кода: Миксины и переменные могут быть определены в одном файле и использованы в других,что снижает дублирование кода.4. Удобство работы: Поддерживать и обновлять стили становится проще благодаря отделению различных компонентов друг от друга. 5. Компиляция в CSS: При компиляции все имена и стили объединяются в один CSS-файл, что упрощает подключение стилей на веб-странице.",
      "level": "Middle",
      "active": false
    }
  ],
  "git": [
    {
      "id": "968a",
      "title": "Основные понятия Git",
      "response": "1. Репозиторий (repository): Это основное хранилище для вашего проекта, где хранится вся история изменений.2. Коммит (commit): Это сохранение изменений в репозитории. Каждый коммит содержит сообщение о том, что было изменено.3. Ветка (branch): Это параллельная линия разработки, позволяющая работать над новыми функциями или исправлениями без влияния на основную ветку.4. Слияние (merge): Это процесс объединения изменений из одной ветки в другую.5. Конфликты (conflicts): Возникают, когда изменения в двух ветках конфликтуют, и Git не может автоматически объединить их.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "13aa",
      "title": "Основные команды Git",
      "response": "1. git init: Инициализация нового репозитория.2. git clone [url]: Клонирование существующего репозитория.3. git add [file]: Добавление файлов к индексации (подготовка к коммиту).4. git commit -m \"message\": Сохранение изменений с сообщением.5. git status: Проверка статуса файлов в репозитории.6. git log: Просмотр истории коммитов.7. git branch: Просмотр существующих веток.8. git checkout [branch]: Переключение на другую ветку.9. git merge [branch]: Слияние указанной ветки с текущей.10. git pull: Получение последних изменений из удалённого репозитория и автоматическое слияние.11. git push: Отправка коммитов на удалённый репозиторий.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "ab6a",
      "title": "Git hookss",
      "response": "Git hooks — это специальные скрипты, которые выполняются автоматически при выполнении определённых действий с репозиторием Git. Они позволяют настраивать процессы автоматизации и улучшать рабочий процесс разработки. Git поддерживает хуки для различных событий, таких как коммиты, слияния, и отправка данных в удалённый репозиторий. Эти хуки написаны в языке сценариев,таком как Bash, и могут быть настроены в зависимости от ваших нужд.Основные виды хуков 1. pre-commit: Выполняется перед созданием коммита. Используется для проверки кода на ошибки,форматирования, запуска тестов и т.д. Если скрипт завершится с ненулевым кодом, коммит не будет выполнен.2. prepare-commit-msg: Запускается перед открытием редактора для ввода сообщения коммита.Используется для изменения или дополнения стандартного сообщения о коммите.3. commit-msg: Выполняется после того, как сообщение коммита было введено, но перед его сохранением. Полезно для проверки формата сообщения коммита.4. post-commit: Выполняется после завершения коммита. Может использоваться для уведомлений,запуска сборки или других задач, которые должны выполняться после коммита.5. pre-push: Выполняется перед отправкой данных в удалённый репозиторий. Этот хук может использоваться для проверки, что все тесты проходят, прежде чем выполнить git push.6. post-merge: Выполняется после успешного слияния веток. Может использоваться для выполнения дополнительных действий, таких как установка зависимостей или очистка.7. pre-receive, update, post-receive: Эти хуки выполняются на стороне сервера при получении изменений от клиента. Используются для проверки входящих изменений, обеспечения соблюдения политик разработки и т.д.\nКак настроить хуки 1. Путь к хукам: Хуки располагаются в директории вашего Git-репозитория по пути .git/hooks/.По умолчанию в этой директории находятся примеры хуков с расширением .sample, которые можно использовать как шаблоны.2. Создание хука: Чтобы создать хук, просто переименуйте файл, удалив расширение .sample и добавьте ваш код. Например, для создания хуку pre-commit создайте файл с именем pre-commit в директории .git/hooks/.3.После создания хуков не забудьте сделать файл исполняемым, выполнив команду +x .git/hooks/pre-commit Примеры применения хуков - Автоматическое форматирование кода с использованием линтеров. - Запуск тестов перед коммитом или отправкой изменений. - Обработка и проверка сообщений коммита на соответствие стандартам.- Уведомление разработчиков через электронную почту о завершении коммитов или слияний.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "cdc8",
      "title": " Рабочие пространства (Worktrees)",
      "response": "Рабочие пространства (Worktrees) в Git \nпозволяют вам создавать несколько рабочих каталогов для одного\n     репозитория, что позволяет одновременно работать над несколькими ветками         без необходимости переключения между ними. Это особенно полезно для разработчиков, \n        которые хотят разрабатывать или тестировать разные изменения в отдельных ветках одновременно.\n        Основные преимущества Worktrees\n        1. Одновременная работа с несколькими ветками: Вы можете иметь активные копии различных веток в разных каталогах, что позволяет вам работать над несколькими задачами одновременно.2. Изолированное окружение: Каждое рабочее пространство является количеством независимым,что помогает избежать конфликтов и путаницы между изменениями и состояниями веток.\n       3. Упрощение тестирования и деплоя: Рабочие пространства позволяют легко протестировать изменения в одной ветке, не затрагивая другие ветки и не переключаясь между ними.\n        Основные команды для работы с Worktrees 1. Создание нового рабочего пространства:Чтобы создать новое рабочее пространство на основе существующей ветки, используйте команду:git worktree add (путь_к_новому_рабочему_каталогу) (ветка) Эта команда создаст новое рабочее пространство в каталоге ../new-feature-branch на основе ветки feature-branch.2. Просмотр существующих рабочих пространств:Для просмотра всех рабочих пространств в вашем репозитории выполните команду:git worktree list 3. Удаление рабочего пространства:Если вам больше не нужно рабочее пространство, вы можете удалить его с помощью команды:git worktree remove (путь_к_рабочему_каталогу) Обратите внимание, что для успешного удаления рабочего пространства необходимо, чтобы оно было пустым (т.е. в нём не должно быть несохранённых изменений).4. Переключение между рабочими пространствами:После создания рабочего пространства вы можете просто перейти в его каталог и работать, как если бы вы находились в обычном репозитории.Примеры применения Worktrees - Работа над несколькими функциональностями: Если у вас есть несколько функциональностей, которые вы хотите разработать одновременно, вы можете создать отдельные рабочие пространства для каждой из них.- Проверка состояния ветки: Вы можете тестировать изменения в одной ветке, не боясь привести в замешательство незафиксированные изменения в текущей ветке.- Облегчение командной работы: Когда несколько разработчиков работают над проектом, каждый из них может создать своё рабочее пространство для своей задачи, что облегчает совместную работу.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "e3ac",
      "title": "Отмена изменений",
      "response": "Git предоставляет несколько способов отмены изменений:git checkout, git revert и git reset. Это позволяет разработчикам гибко обрабатывать различные ошибки или откатывать изменения.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "95e7",
      "title": "daswqeerfqwer",
      "response": "asd",
      "level": "Junior",
      "active": false
    },
    {
      "id": "3c28",
      "title": "фы",
      "response": "асмясчм",
      "level": "Junior",
      "active": false
    },
    {
      "id": "a77e",
      "title": " asd",
      "response": " d",
      "level": "Junior",
      "active": false
    },
    {
      "id": "aeff",
      "title": "фыв",
      "response": "вввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввв",
      "level": "Junior",
      "active": false
    },
    {
      "id": "0b5c",
      "title": "asdasd",
      "response": "ddddddasdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd",
      "level": "Junior",
      "active": true
    },
    {
      "id": "7685",
      "title": "йцуйцу",
      "response": "фыцввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввв",
      "level": "Junior",
      "active": false
    },
    {
      "id": "d250",
      "title": "цйуцу",
      "response": "вввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввв\n",
      "level": "Junior",
      "active": false
    },
    {
      "id": "a75e",
      "title": "edsadasdasd",
      "response": "edsadasdasd dsdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasd\n",
      "level": "Junior",
      "active": false
    }
  ]
}