{
  "data-struct": [],
  "oop": [],
  "testing": [],
  "rxjs": [
    {
      "id": "e3b4"
    }
  ],
  "typescript": [
    {
      "id": "4162"
    }
  ],
  "patterns": [
    {
      "id": "f3f7"
    }
  ],
  "net-protocols": [
    {
      "id": "3d4d"
    }
  ],
  "angular": [
    {
      "id": "82a5",
      "title": "Что такое Angular?",
      "response": "Angular – это фреймворк для создания клиентских веб-приложений, разработанный компанией Google. Он позволяет создавать динамические веб-приложения, обеспечивая высокую производительность и гибкость кода.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "52fa",
      "title": "Как на Angular2 и Angular8 при получении данных с бэка парсить их в модель?",
      "response": "На Angular (как версии 2, так и 8) процесс получения данных с бэкенда и их парсинга в модель можно описать следующими этапами:1. Определение модели данных Перед тем, как получать данные, необходимо определить, как они будут представляться в приложении. Это включает в себя создание модели, которая описывает структуру данных, получаемых от бэкенда. Например, если вы работаете с пользователями, вам нужно решить, какие свойства будут у пользователя (например, имя, email, возраст и т.д.). 2. Создание сервиса Создайте сервис, который будет отвечать за взаимодействие с API бэкенда. Этот сервис будет отправлять HTTP-запросы к серверу для получения данных. Важно, чтобы сервисы в Angular отвечали за логику работы с данными, отделяя эту логику от компонентов, которые отображают данные.3. Запрос к API Сервис использует методы для отправки запросов к API для получения данных. В ответ на запрос бэкэнд возвращает данные, обычно в формате JSON. После получения этих данных сервис должен обработать их, чтобы они соответствовали модели.4. Парсинг данных На этом этапе происходит преобразование данных, полученных с бэкенда, в объекты вашей модели. Это включает в себя сопоставление свойств, которые пришли от сервера, с полями вашей модели. Если структура данных соответствует ожидаемым полям модели, то можно создать экземпляры модели с полученными значениями.\n5. Использование данных в компоненте После того, как данные были успешно преобразованы в объекты модели, их можно использовать в компонентах Angular. Компоненты могут подписываться на сервисы, чтобы получать данные, и обновлять свое состояние, чтобы отобразить эти данные на экране. Это значит, что компоненты могут легко обновлять представление в зависимости от данных, получаемых из сервиса.6. Обработка ошибок Всегда полезно обрабатывать возможные ошибки, которые могут возникнуть при запросах к бэкенду. Это может быть сделано путем проверки ответов от сервера и добавления соответствующей обработки ошибок. Заключение: В итоге, процесс парсинга данных из бэкенда в Angular включает в себя определение модели данных, создание сервиса для работы с API, выполнение запросов, их обработку и преобразование в объекты модели, а затем использование этих данных в компонентах приложения. Такой подход позволяет поддерживать чистую архитектуру и легкость управления данными в приложении.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "7541",
      "title": "Расскажи про guardы?",
      "response": "Гарды (guards) в Angular — это механизм, который позволяет контролировать доступ к определённым маршрутам (pages) в вашем приложении. Они действуют как защитные слои, проверяя, имеет ли пользователь право переходить на определённые страницы или выполнять определённые действия. Гарды помогают реализовать маршрутизацию с учетом авторизации, аутентификации и других условий. Основные виды гардов в Angular: 1. CanActivate: - Проверяет, может ли пользователь перейти на определённый маршрут. Если метод возвращает true, переход разрешён; если false, переход отменяется.- Используется для проверки, прошел ли пользователь аутентификацию или имеет ли права доступа к определённому маршруту.2. CanActivateChild:Работает аналогично CanActivate, но применяется к дочерним маршрутам. Это позволяет контролировать доступ ко всем дочерним маршрутам конкретного родительского маршрута.3. CanDeactivate:- Переход контролируется, когда пользователь пытается покинуть текущий маршрут. Например, это может быть полезно, если у вас есть форма, и вы хотите предупредить пользователя о том, что он потеряет несохраненные данные.4. Resolve:- Используется для получения данных перед активацией маршрута. Это позволяет загружать данные заранее и передавать их в компонент, что полезно для случаев, когда вы хотите отображать данные, прежде чем пользователь увидит страницу.5. CanLoad:- Проверяет, имеет ли пользователь доступ к загрузке определённого модуля. Это используется для ленивой загрузки маршрутов, что позволяет загружать модули только при необходимости. Это помогает улучшить производительность приложения, предотвращая загрузку ненужных модулей.Как работают гарды:Гарды реализуются в виде сервисов. Чтобы создать гард, вы можете использовать Angular CLI, который автоматически создаст необходимый сервис. Каждый гард должен реализовывать интерфейс, соответствующий его типу (например, CanActivate), и реализовывать метод, который будет возвращать true или false, либо Observable boolean> или Promise boolean>.Пример использования гарда:1. Создание гарда: Вы создаете гард, который проверяет, старше ли пользователь определенного возраста.2. Имплементация логики: В методе проверяете возраст пользователя и возвращаете true или false.3. Настройка маршрутов: В маршрутах указываете, какой гард применить к конкретному маршруту, тем самым обеспечивая контроль доступа.Преимущества использования гардов:- Позволяют улучшить безопасность вашего приложения, предотвращая несанкционирован- Обеспечивают лучшую управляемость переходов между маршрутами, особенно в сложных приложениях с множеством условий доступа.- Помогают загружать необходимые данные перед тем, как пользователь увидит страницу, что улучшает пользовательский опыт.В целом, гарды в Angular являются мощным инструментом для управления доступом к маршрутам и организации логики переходов в приложении.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "6f7e",
      "title": "Использовали ли сторонние библиотеки для форм? Angular Material?",
      "response": "Да, в Angular часто используются сторонние библиотеки для работы с формами, и одной из наиболее популярных таких библиотек является Angular Material. Вот несколько аспектов, касающихся использования Angular Material и других библиотек для работы с формами:Angular Material 1. UI-компоненты: Angular Material предоставляет набор предопределённых пользовательских интерфейсных компонентов, которые соответствуют Material Design. Это включает в себя различные элементы форм, такие как текстовые поля, селекты, чекбоксы, радиокнопки и другие.3. Валидация: Angular Material делает процесс валидации форм более удобным. Компоненты формы интегрированы с механизмом валидации Angular, что позволяет легко отображать сообщения об ошибках и советы пользователям.4. Интерактивность: Angular Material поддерживает различные интерактивные возможности, такие как автозаполнение, выпадающие списки и адаптивное поведение в зависимости от размера экрана. Это улучшает взаимодействие пользователей с формами.Другие сторонние библиотеки 1. Ngx-formly: Это библиотека для создания динамических форм в Angular. Она позволяет определять формы с использованием JSON и автоматически генерировать пользовательский интерфейс на основе этого определения. Это особенно полезно для приложений с изменяемыми требованиями к формам.2. Reactive Forms: Хотя это не совсем сторонняя библиотека, это важный подход в Angular. Reactive Forms предоставляет более мощные инструменты для управления состоянием форм и их валидацией по сравнению с Template-driven Forms. Reactive Forms позволяют легче отслеживать изменения формы и управлять их состоянием.3. ngx-bootstrap и PrimeNG: Эти библиотеки также предлагают компоненты для работы с формами, в том числе таблицы, модальные окна и различные элементы управления. Они могут быть использованы в сочетании с Angular Material или другим стилем приложения в зависимости от требований проекта.Заключение:Использование сторонних библиотек, таких как Angular Material, значительно упрощает разработку форм в Angular-приложениях. Они не только предоставляют готовые компоненты, но и обеспечивают удобное взаимодействие с пользователями, улучшая общее восприятие приложения. Выбор библиотеки зависит от конкретных потребностей вашего проекта, предпочтений по стилю и дизайну, а также уровня требуемой функциональности.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "ca5b",
      "title": "Пользуетесь типизацией в typescript или используете как дефолтный инструмент для Angular?",
      "response": "Типизация в TypeScript является одной из его ключевых особенностей, и в большинстве случаев использование типизации рассматривается как важная практическая практика при разработке приложений на Angular. Вот несколько причин, почему типизация считается полезной и важной в контексте Angular:1. Улучшенная безопасность типов - Использование типизации позволяет обнаруживать ошибки на этапе компиляции вместо выполнения, что снижает вероятность возникновения ошибок во время выполнения приложения.- Это особенно полезно в крупных приложениях, где сложно отслеживать типы данных, передаваемых между компонентами, сервисами и другими частями приложения.2. Лучшее автозавершение и поддержка IDE - Типы помогают интегрированным средам разработки (IDE) предоставлять более точные подсказки, автозавершение и документацию для методов и свойств.- Это упрощает разработку, поскольку разработчики могут легче понимать структуры данных и интерфейсы, используемые в приложении.3. Чёткое определение интерфейсов и моделей - В TypeScript можно использовать интерфейсы и классы для явного определения структуры объектов и моделей данных, что делает код более понятным и поддерживаемым.- Это помогает обеспечить единообразие в использовании объектов в разных частях приложения.4. Поддержка и расширяемость - Типизация упрощает совместную работу в команде, поскольку другие разработчики могут легко понять, какие данные ожидаются, и какие структуры данных необходимы для использования.- Это делает код более удобным для тестирования и расширения, поскольку вы точно знаете, какие типы передаются в функции и компоненты.5. Использование сложных типов - TypeScript позволяет использовать сложные типы данных, такие как объединения (union types), пересечения (intersection types) и типы с помощью дженериков. Это помогает создавать более гибкие и обобщенные компоненты и сервисы.- Это особенно полезно для сложных бизнес-логик и компонентов, которые могут обрабатывать разнообразные данные. \nЗаключение:Таким образом, хотя TypeScript и является дефолтным инструментом для Angular, использование типизации в TypeScript не следует рассматривать как опцию, а как рекомендацию. Это не только улучшает надежность и читаемость кода, но и делает разработку более эффективной и управляемой, что критически важно в современных веб-приложениях.Поэтому большинство разработчиков на Angular активно используют типизацию TypeScript для повышения качества своего кода.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "8b08",
      "title": "Что такое change detection? В чём разница между default и push?",
      "response": "Change Detection (обнаружение изменений) в Angular — это механизм, который отслеживает изменения в данных и обновляет пользовательский интерфейс (UI) в соответствии с этими изменениями. Angular использует этот механизм для актуализации представления приложения, когда данные изменяются в модели. С помощью обнаружения изменений вы можете автоматически реагировать на изменения состояния приложения, обеспечивая синхронизацию между моделью и представлением.Как работает обнаружение изменений в Angular Angular обновляет представление компонентов при помощи так называемого механизма обнаружения изменений. Он основан на концепции \"потока\" данных и использует различные стратегии для определения изменений:1. Zone.js: Angular использует библиотеку Zone.js, чтобы отслеживать асинхронные операции, такие как события, таймеры и HTTP-запросы. Когда такие операции завершаются, Angular знает, что необходимо проверить, произошло ли изменение.2. Change Detection Strategy: У каждого компонента в Angular есть стратегия обнаружения изменений, которая определяет, как именно Angular будет отслеживать изменения в этом компоненте. Стратегии обнаружения изменений В Angular существуют две основные стратегии обнаружения изменений:1. Default Change Detection (Default strategy):- Это стандартная стратегия обнаружения изменений, используемая по умолчанию для всех компонентов.- Angular проверяет каждую часть дерева компонентов на изменения после каждой асинхронной операции (например, при событиях, таймерах и HTTP-запросах).- Это означает, что Angular будет периодически проверять все компоненты с целью указать, есть ли изменения в их переменных, и обновлять соответствующее представление при необходимости.- Эта стратегия проста в использовании и подходит для большинства приложений, но может привести к неэффективности в производительности, особенно в сложных приложениях с глубоким деревом компонентов.\n2. OnPush Change Detection (OnPush strategy):- Эта стратегия оптимизирует производительность компонента, проверяя только те компоненты, которые имеют изменения в своих входных параметрах (inputs), или те, которые вызывают события.- Angular не проверяет компонент, если не были выполнены изменения в его свойствах, и если он не реагирует на события в его пределах. Это означает, что если никаких изменений не произошло, компонент не будет проверяться на изменения, что снижает нагрузку на производительность.- Компоненты с OnPush должны использовать иммутабельные данные (immutable data) или производить изменения экземпляра для вызова обновлений. - OnPush может быть полезен в больших и сложных приложениях, где производительность имеет важное значение.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "19da",
      "title": "ngZone",
      "response": "NgZone — это сервис в Angular, который позволяет управлять контекстом выполнения асинхронного кода и обеспечивать обнаружение изменений. Он является частью механизма, который позволяет Angular отслеживать изменения в приложении и обновлять представление в соответствии с изменениями состояния. NgZone использует библиотеку Zone.js для работы с зонами, изолированными контекстами выполнения, которые позволяют отслеживать асинхронные операции.Основные функции NgZone:1. Обнаружение изменений:- NgZone позволяет Angular эффективно отслеживать изменения, происходящие в приложении, автоматически активируя обнаружение изменений после завершения асинхронных операций (таких как HTTP-запросы, таймеры и события). Это обеспечивает автоматическое обновление представления, когда данные меняются.2. Контроль над изменениями:- NgZone предоставляет методы для управления тем, когда Angular должен проверять изменения. Вы можете использовать его для временного выхода из зоны (например, при выполнении операций, которые не требуют изменений в UI), что может помочь улучшить производительность.3. Методы NgZone:- run(): Этот метод запускает функцию внутри контекста Angular, активируя обнаружение изменений. Это полезно, если вы хотите выполнить некоторые действия и убедиться, что изменения будут отслежены.- runOutsideAngular(): Этот метод позволяет выполнять функции вне контекста Angular. Это важно, если вы хотите избежать избыточного отслеживания изменений и улучшить производительность (например, при использовании сторонних библиотек для работы с событиями или анимациями).",
      "level": "Middle",
      "active": false
    },
    {
      "id": "68d8",
      "title": "Чем e2e-тесты отличаются от unit-тестов?",
      "response": "E2E-тесты (end-to-end тесты) и unit-тесты (модульные тесты) являются двумя различными уровнями тестирования программного обеспечения, и каждый из них имеет свои особенности, цели и области применения.Unit-тесты Определение:Unit-тесты предназначены для проверки отдельных \"единиц\" кода, таких как функции, методы или классы, в изоляции от остальной части системы.Основные характеристики:1. Изоляция: Каждый unit-тест проверяет только одну конкретную функциональность, отделённую от других частей приложения. Это достигается через использование моков (mocks), заглушек (stubs) или фейков (fakes).2. Скорость: Unit-тесты обычно выполняются быстро, так как они не требуют взаимодействия с внешними компонентами, такими как база данных или API.3. Инструменты: Для написания unit-тестов часто используются фреймворки, такие как Jasmine, Mocha, Jest и другие.4. Простота: Unit-тесты проще для реализации и отладки, так как они сосредоточены на маленьких кусках кода.5. Цели: Основная цель unit-тестов — выявление ошибок в логике отдельных модулей и обеспечение правильного функционирования этих модулей.E2E-тесты:Определение:E2E-тесты проверяют приложение в целом, имитируя поведение пользователя, чтобы убедиться, что все части системы работают вместе должным образом. Основные характеристики:1. Полное тестирование: E2E-тесты проверяют все слои приложения, включая фронтенд, бэкенд, базы данных и другие взаимодействия. Они проверяют, как различные модули и компоненты работают вместе.2. Сложность: E2E-тесты более сложные в написании и поддержке, поскольку требуют настройки тестовых данных и окружения.3. Скорость: E2E-тесты обычно медленнее, чем unit-тесты, из-за необходимости симуляции всей системы и взаимодействия с различными компонентами.4. Инструменты: Для E2E-тестирования часто используются инструменты, такие как Protractor, Cypress, Selenium и другие.5. Пользовательский опыт: E2E-тесты предназначены для проверки пользовательского опыта, начиная с загрузки страницы и заканчивая действиями пользователя, такими как нажатия кнопок и ввод данных.6. Цели: Основная цель E2E-тестов — удостовериться, что приложение работает как единое целое и что все его части правильно взаимодействуют друг с другом.Заключение:В целом, оба типа тестирования важны и дополняют друг друга в процессе разработки программного обеспечения. Unit-тесты обеспечивают проверку отдельных компонентов на грамматические ошибки и ошибки логики, тогда как E2E-тесты подтверждают , что приложение работает корректно при взаимодействии всех компонентов. Чаще всего в проектах комбинируют оба подхода, чтобы получить более полное покрытие и уверенность в качестве кода.",
      "level": "Senior",
      "active": false
    },
    {
      "id": "a203",
      "title": "Что такое pipe? Расскажите про async pipe?",
      "response": "В Angular pipe (пайп) — это специальный механизм, позволяющий трансформировать данные в шаблонах. Пайпы применяются для изменения форматирования, преобразования и фильтрации данных при их отображении в UI. Они представляют собой функции, которые могут быть использованы в выражениях Angular для изменения значений, прежде чем они будут отображены в HTML.Основные характеристики пайпов:\n1. Чистота: Пайпы могут быть чистыми или грязными. Чистые пайпы не изменяют входные данные и возвращают одно и то же значение для одного и того же входного значения. Грязные пайпы могут возвращать разные результаты при каждом вызове.2. Параметры: Пайпы могут принимать дополнительные параметры для настройки их поведения.3. Композиция: Пайпы могут быть вложены друг в друга, позволяя комбинировать их функции.Async Pipe Async Pipe — это специальный пайп в Angular, который упрощает работу с асинхронными данными, такими как результаты HTTP-запросов, промисы или потоки (Observables). Он позволяет автоматически подписываться на Observable или промис и обновлять представление, когда приходит новое значение.Основные функции Async Pipe: 1. Подписка и отписка: Async Pipe автоматически подписывается на Observable при загрузке компонента и отписывается при уничтожении компонента. Это помогает избежать утечек памяти и упрощает управление подписками.2. Актуализация данных: Async Pipe автоматически обновляет отображаемые данные в шаблоне, когда Observable эмитирует новое значение. Пайпы, в том числе Async Pipe, являются очень удобным инструментом для работы с данными в Angular. Они позволяют легко и эффективно форматировать и трансформировать данные непосредственно в шаблонах, а также упрощают работу с асинхронными данными, автоматизируя управление подписками и актуализацией данных в пользовательском интерфейсе.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "faee",
      "title": "Жизненный цикл компоненты",
      "response": "В Angular жизненный цикл компонента описывает последовательность событий и методов, через которые проходит компонент с момента его создания до уничтожения. Понимание жизненного цикла компонентов позволяет разработчикам лучше управлять состоянием и поведением компонентов, а также выполнять определенные действия на различных этапах их существования. Основные стадии жизненного цикла компонента и их хуки 1. Создание - ngOnChanges(): Вызывается при изменении входных свойств компонента. Этот хук получает объект SimpleChanges, который содержит информацию о предыдущих и текущих значениях входных свойств. Используется для реакции на изменения входных данных.2. Изменение - ngDoCheck(): Вызывается во время каждого цикла обнаружения изменений и позволяет разработчику реагировать на изменения, которые Angular не может отследить автоматически. 3. Отображение - ngAfterContentInit(): Вызывается после того, как контент (ng-content) был проинициализирован. Это позволяет выполнять действия, которые зависят от наличия содержимого в компоненте.- ngAfterContentChecked(): Вызывается после проверки содержания компонента. Здесь можно выполнять действия, зависимые от изменений в контенте.- ngAfterViewInit(): Вызывается после инициализации представления компонента и всех дочерних представлений. Здесь можно выполнять действия, которые требуют доступа к дочерним компонентам.- ngAfterViewChecked(): Вызывается после проверки представления и дочерних представлений. Этот метод можно использовать для выполнения дополнительных действий после каждой проверки.4. Уничтожение:- ngOnDestroy(): Вызывается перед уничтожением компонента. Здесь можно выполнять финальную уборку, освобождать ресурсы, такие как подписки на события или таймеры, для предотвращения утечек памяти.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "35d6",
      "title": "Почему change работает раньше onInit (чендж детекшн)",
      "response": "Почему изменение данных может вызвать обнаружение изменений до выполнения метода ngOnInit.1. Состояние данных перед ngOnInit():- Когда компонент инициализируется, его свойства могут быть уже установлены в определенные значения. Если эти свойства изменяются до вызова ngOnInit, Angular запускает обнаружение изменений, чтобы отражать эти изменения в интерфейсе.2. Процесс обнаружения изменений:- Angular использует механизм изменений, чтобы отслеживать изменения состояния в приложении. Этот механизм реагирует на изменения, происходящие в свойствах компонента.3. Очередность вызовов:- Как только Angular заметит изменения входных данных или состояния, он инициирует обнаружение изменений, что может привести к перерисовке компонента, даже если метод ngOnInit еще не был вызван. Однако, после этого Angular также вызовет ngOnInit() для выполнения дополнительной логики и инициализации.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "99ed",
      "title": "Viewchild от contentChild",
      "response": "В Angular @ViewChild и @ContentChild — это декораторы, которые используются для получения ссылок на компоненты, директивы или элементы DOM, но у них есть разные области применения и методы работы. Давайте рассмотрим каждую из этих аннотаций более подробно.@ViewChild Определение:@ViewChild позволяет получить доступ к дочерним компонентам, директивам или элементам шаблона, которые находятся в пределах самого компонента. Это означает, что @ViewChild используется для доступа к элементам, которые находятся в шаблоне текущего компонента.@ContentChild Определение:\n@ContentChild позволяет получить доступ к дочерним компонентам или элементам, которые были переданы в родительский компонент через ng-content>. Это означает, что @ContentChild используется для доступа к элементам, которые находятся вне шаблона текущего компонента, но были вставлены в него. Как использовать: Для использования @ContentChild необходимо вставить элемент в родительский компонент, проделав это с помощью ng-content. <br><app-parent><br>  <child-component></child-component><br></app-parent><br> Основные отличия 1. Положение элементов:- @ViewChild: Получает доступ к дочерним компонентам, директивам или элементам, которые находятся внутри текущего компонента. - @ContentChild: Получает доступ к элементам, которые были переданы в текущий компонент через ng-content.2. Событие инициализации:- @ViewChild: Необходимо использовать в методах жизненного цикла, таких как ngAfterViewInit, чтобы быть уверенным, что элемент инициализирован.- @ContentChild: Обычно используется в ngAfterContentInit, поскольку контент может быть вставлен после инициализации компонента.3. Контекст использования:- @ViewChild: Используется для взаимодействия с элементами/компонентами, которые являются частью самого компонента (например, элементы формы, дочерние компоненты).- @ContentChild: Используется для получения доступа к элементам, которые вставлены в компонент извне, например, элементы, переданные через контент.",
      "level": "Middle",
      "active": true
    },
    {
      "id": "05c6",
      "title": "Как стили навесить на viewChild (renderer2) ",
      "response": "В Angular, чтобы навесить стили на элемент, полученный с помощью @ViewChild, вы можете использовать Renderer2. Это позволяет вам динамически изменять стили элемента в безопасном и независимом от платформы способом. Ниже приведен пример того, как это можно сделать.Шаги для изменения стилей с помощью Renderer2 и @ViewChild 1. Импортируйте необходимые модули.2. Получите ссылку на элемент через @ViewChild.3. Используйте сервис Renderer2 для управления стилями.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "7ead",
      "title": "У нас есть код модули, как разбить код на модули ",
      "response": "Разбиение кода на модули - это важный аспект организации и управления проектом в Angular. Модули позволяют вам структурировать приложение, улучшить его читаемость и повторное использование кода. Вот шаги и рекомендации о том, как разбить код на модули в Angular:Причины для разбивки на модули 1. Структурирование кода: Модули помогают организовать код по функциональным направлениям.2. Улучшение производительности: Модули могут загружаться лениво (lazy loading), что ускоряет начальную загрузку приложения.3. Повторное использование: Модули можно использовать в разных частях приложения или даже в других проектах.Шаги для разбиения кода на модули 1. Определите функциональные области Сначала разделите приложение на логические секции. Например:- Пользовательский интерфейс (UI)- Аутентификация - Продукты или товары - Заказы или корзина - Админ-панель 2. Создайте модули 3. Переместите компоненты и сервисы 4. Настройте маршрутизацию 5. Импортируйте общий модуль 6. Настройте ленивую загрузку (если необходимо)",
      "level": "Junior",
      "active": false
    },
    {
      "id": "0e9a",
      "title": " Стал бы ты провайдить сервисы в шаред модуль",
      "response": "Да, обычно сервисы провайдятся в shared модуль, чтобы их можно было использовать в разных модулях приложения. Это помогает избежать дублирования кода и упрощает управление  зависимостями. Убедитесь, что сервисы являются stateless (без состояния) или могут безопасно работать с состоянием, если это необходимо",
      "level": "Middle",
      "active": false
    },
    {
      "id": "db83",
      "title": "Реактивные формы плюсы в чем плюсы",
      "response": "Плюсы реактивных форм в Angular:1. Контроль состояния: Обеспечивает строгий контроль над состоянием формы и её элементами.2. Модульность: Упрощает разделение форм на мелкие, управляемые компоненты.3. Тестируемость: Упрощает тестирование, так как логика формы отделена от представления.4. Удобное управление валидаторами: Легко добавлять и изменять валидаторы в реальном времени.5. Лучше с асинхронными данными: Удобнее работать с асинхронными операциями, такими как запросы к серверу.6. Императивный подход: Позволяет управлять формами через программный код, что может быть более понятно для разработчиков.'7. Динамическое изменение форм: Упрощает создание форм с динамическим набором полей и зависимостями между ними.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "46e1",
      "title": "Разница между 6-ым и 9-ым Angular? Что поменялось в плане работы с backEnd",
      "response": "Angular активно развивается, и между версиями 6 и 9 были внесены значительные изменения и улучшения. Вот основные изменения и отличия между Angular 6 и Angular 9, особенно в контексте работы с бэкендом:1. Ivy Renderer - Angular 9: Одной из самых заметных изменений в Angular 9 стал новый рендерер под названием Ivy. Ivy улучшает производительность, уменьшает размер бандла и значительно ускоряет время компиляции. Благодаря Ivy теперь проще и быстрее оптимизировать загрузку приложений.- Angular 6: Использовал стандартный рендерер.2. Анализ времени сборки - Angular 9: Новый рендерер Ivy предоставляет улучшенные возможности для анализа приложения и позволяет лучше оптимизировать время сборки и размеры финального бандла.3. Упрощение использования Angular для работы с HTTP - Angular 6: В этой версии были введены улучшения в модуле HttpClient, но основные изменения в основном касались улучшения обращений к API.- Angular 9: Были улучшены возможности работы с HttpClient и добавлены дополнительные возможности, такие как более удобные инструменты для использования RxJS на уровне сервисов. Более гибкие механизмы для обработки ошибок и применения интерсепторов.4. Ручное указание зависимостей - Angular 9: Улучшена поддержка \"Ручного указания зависимостей\" через providedIn на уровне сервиса, что делает внедрение зависимостей более простым и понятным. Это улучшает работу с DI и некоторыми сценариями, которые могут возникнуть при взаимодействии с бэкендом.5. Улучшения в CLI - Angular 9: Улучшены инструменты Angular CLI, которые обеспечивают более простой и быстрый процесс создания приложений и управления зависимостями. Новые функции, такие как возможность создания компонентов без необходимости вручную обновлять модули, делают разработку быстрее.6. Зависимости на уровне библиотеки - Angular 9: Старая структура зависимостей была улучшена для библиотек, что сделало процесс работы с библиотеками более интуитивным. Это упрощает интеграцию сторонних библиотек и работу с API, обеспечивая более гладкое взаимодействие с бэкендом.7. Поддержка Internationalization (i18n) - Angular 9: Улучшение системы локализации, что позволяет проще работать с многоязычными приложениями.Заключение: общем,Angular 9 обеспечивает более удобную компиляцию, лучшую производительность и оптимизацию. Работая с бэкендом, у разработчиков теперь есть дополнительные инструменты, которые упрощают процесс интеграции с API и обработку данных. Улучшенная отдача от Ivy также делает общую производительность приложений выше по сравнению с Angular 6.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "9cb9",
      "title": "Что такое компонент в Angular?",
      "response": "Компоненты являются основными строительными блоками Angular-приложений и содержат логику и представление.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "12dd",
      "title": "Что такое сервисы и как их использовать?",
      "response": "Сервисы — это классы, которые предоставляют определённый функционал и могут быть использованы для  обмена данными и выполнения логики, которая не привязана к конкретному компоненту. Сервисы помогают реализовать архитектуру, при которой код становится более модульным, переиспользуемым и легче поддерживаемым.Обычно они используются для взаимодействия с API, хранения и обработки данных, а также для реализации различных функций,таких как маршрутизация, аутентификация и т.д. Основные характеристики сервисов:1. Инъекция зависимостей: Angular использует механизм инъекции зависимостей для создания экземпляров сервисов,что позволяет автоматически управлять их жизненным циклом и зависимостями.2. Переиспользуемость: Сервисы могут быть использованы в разных компонентах, что повышает переиспользуемость кода.3. Модульность: Сервисы способствуют разделению бизнес-логики и логики представления (UI), что улучшает структуру кода.4. Тестируемость: Благодаря высокой модульности, сервисы легче тестировать отдельно от компонентов.Как правило, сервис регистрируется автоматически при использовании декоратора @Injectable с свойством providedIn: 'root'. Это делает его доступным в корневом модуле вашего приложения. Вы также можете зарегистрировать сервис в конкретном модуле или компоненте,добавив его в массив providers соответствующего декоратора.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "efc2",
      "title": "Каковы основные характеристики Angular?",
      "response": "1. Компонентный подход Angular основан на компонентной архитектуре, что позволяет разбивать интерфейс приложения на управляемые и переиспользуемые компоненты. Каждый компонент инкапсулирует свою логику, шаблон и стили, что упрощает разработку и сопровождение приложения.2. Двусторонняя привязка данных Angular поддерживает двустороннюю привязку данных (two-way data binding), что позволяет автоматически синхронизировать данные между моделью и представлением. Это упрощает взаимодействие между компонентами и инкапсулирует обновления данных, что делает разработку более интуитивной.3. Модули Angular использует систему модулей, что позволяет организовать код в независимые и логически связанные группы. Каждый модуль может содержать компоненты, директивы, сервисы и другие модули, что способствует модульному подходу и лучшей управляемости кода.4. Инъекция зависимостей (Dependency Injection) Angular предоставляет встроенную поддержку инъекции зависимостей, что упрощает управление зависимостями между классами и улучшает тестируемость приложения. Это позволяет легче управлять жизненным циклом объектов и их взаимодействием.  5. Маршрутизация Angular включает встроенный модуль маршрутизации, который позволяет организовать навигацию между различными представлениями или страницами приложения. Это делает приложения более удобными для пользователей и улучшает организацию кода.6. Реактивные формы Angular позволяет работать с формами через реактивные формы или шаблонные формы, что обеспечивает  мощные инструменты для валидации и отслеживания состояния. Реактивные формы позволяют динамически управлять формами в приложении, облегчая их настройку и валидацию. 7. RxJS и реактивное программирование Angular активно использует библиотеку RxJS, которая предоставляет инструменты для работы с асинхронными данными и потоками событий. Это дает разработчикам возможность эффективно управлять потоками данных и событий с использованием Observable.8. Генерация и сборка с помощью CLI Angular CLI (Command Line Interface) позволяет быстро создавать и управлять Angular приложениями. Он предлагает команды для создания новых компонентов, сервисов, модулей и т.д., а также автоматизирует процесс сборки, тестирования и развертывания.9. Тестируемость Angular разработан с учетом тестируемости. Он поддерживает юнит-тестирование компонентов и сервисов с помощью таких инструментов, как Jasmine и Karma. Это позволяет легко писать и запускать тесты, что способствует повышению качества кода.  10. Поддержка Progressive Web Apps (PWA) Angular обеспечивает поддержку создания прогрессивных веб-приложений, которые могут работать как нативные приложения на мобильных устройствах. PWA имеют повышенную скорость загрузки,работоспособность в оффлайн-режиме и возможность установки на домашний экран.11. Поддержка SEO Angular предоставляет механизмы для улучшения поисковой оптимизации (SEO) приложений, включая серверный  рендеринг с использованием Angular Universal. Это помогает приложениям эффективно индексироваться поисковыми системами.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "3b48",
      "title": "Что такое NgModule?",
      "response": "NgModule — это основной строительный блок приложения в Angular, который используется для организации и структурирования кода. Он позволяет группировать связанные компоненты, директивы, пайпы и сервисы в единое целое. Основная цель NgModule — определить область видимости и зависимости для различных частей вашего приложения. Вот основные аспекты NgModule:Основные характеристики NgModule:1. Определение модуля:Каждый Angular-модуль определяется с помощью декоратора @NgModule, который принимает объект конфигурации.Этот объект содержит метаданные, описывающие модуль.2. Импортируемые и экспортируемые модули:- Imports: Позволяет модулю импортировать другие модули, что делает доступными их компоненты, директивы и пайпы. Это позволяет разделять функциональность на разные модули и повторно использовать код.- Exports: Позволяет экспортировать компоненты, директивы и пайпы, чтобы они были доступны в других модулях, которые импортируют текущий модуль.3. Область видимости:Модули определяют область видимости для компонентов и сервисов. Компоненты, указанные в разделе  declarations, могут быть использованы только внутри этого модуля, если не экспортированы.4. Декларации:В разделе declarations указываются компоненты, директивы и пайпы, которые принадлежат этому модулю.5. Сервис и DI:Модули могут предоставлять сервисы через секцию providers. Angular автоматически создает экземпляр сервиса  и обеспечивает его инъекцию в компоненты, пользовательские директивы и другие сервисы.6. Основной модуль:Каждое Angular-приложение имеет как минимум один корневой модуль, обычно называемый AppModule, который инициализирует приложение.NgModule играет жизненно важную роль в организации Angular-приложений. Он обеспечивает модульность, упрощая управление зависимостями, структурирование кода и повторное использование компонентов. Правильное использование NgModule помогает создавать масштабируемые и поддерживаемые приложения.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "eb3b",
      "title": "Data binding (привязка к данным)",
      "response": "В шаблоне Angular привязка создает живую связь между частью пользовательского интерфейса, созданной из шаблона (элемент DOM, директива или компонент), и моделью (экземпляр компонента,к которому принадлежит шаблон). Эту связь можно использовать для синхронизации представления с моделью, для уведомления модели о том, что в представлении происходит событие или действие пользователя, или для того и другого. Алгоритм обнаружения изменений Angular отвечает за поддержание синхронизации представления и модели.Примеры связывания включают в себя:интерполяции текста {{value}},свойство связывание [value] привязка событий (click) двусторонняя привязка [{ngModel}] Привязки всегда состоят из двух частей: цели , которая будет получать связанное значение, и шаблонного выражения , которое создает значение из модели.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "7fae",
      "title": "Что такое @Pipe",
      "response": "функция которая преобразует разметку через | если есть доп свойства то через : есть pure и impure pipe - у него есть метод трансформ Pipe (или \"трубка\") в Angular — это специальный механизм, который позволяет преобразовывать данные в шаблонах приложения. Pipes используются для обработки и изменения данных перед их отображением пользователю. Они могут применяться для форматирования текста, преобразования дат, чисел, массивов и многого другого.Основные характеристики Pipe:1. Простота использования:- Pipes можно легко использовать в шаблонах Angular. Для этого достаточно указать название pipe и передать ему необходимые параметры в интерполяции или директиве. 2. Чистые и не чистые Pipes:- Пайпы могут быть чистыми и не чистыми. Чистые Pipes возвращают один и тот же результат при одинаковых входных данных, а не чистые могут выдавать разные результаты с одинаковыми входными данными (например,если они зависят от динамических данных, таких как текущее время).3. Встроенные Pipes:- Angular предоставляет несколько встроенных pipes, например:- DatePipe: преобразует дату в заданный формат.- CurrencyPipe: форматирует число в валюту.- DecimalPipe: форматирует число в десятичный формат.- JsonPipe: преобразует объект в JSON-строку для отладки.Пользовательские Pipes:- Вы можете создавать свои собственные pipes, чтобы реализовать специфическую логику преобразования  данных. Для этого необходимо использовать декоратор @Pipe и реализовать метод transform(value: any, ...args: any[]): any.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "7140",
      "title": "Хуки жизненного цикла",
      "response": "1.OnChanges - вызывается каждый раз, при установлении свойства 2.OnInit - один раз при инициализации компонента 3.DoCheck - при каждом проверки  изменении свойств 4.AfterContentInit - после проецирования контента в компоненте, вставка в html 5.AfterContentChecket - после проверки изменения проецируемого контент в шаблон 6.AfterViewInit - после инициализации представления родительского или дочернего компонента 7.AfterViewChecket - после проверки представления родительского или дочернего  компонента 8.OnDestroy - один раз после уничтожения компонента",
      "level": "Junior",
      "active": false
    },
    {
      "id": "0ea7",
      "title": "Модуль и его свойства",
      "response": "6.Модуль - класс с декоратором @ngModule - обьединяющая структура  для компонент, сервисов, пайпов, директив свойства - 1.Импорт - массив модулей нужных для нашего 2.Экспорт - массив компонент, пайпов, директив для экспорта 3.declaration - массив компонент, пайп, директив 4.providers - сервисы",
      "level": "Junior",
      "active": false
    },
    {
      "id": "95e7",
      "title": "Lazy loading",
      "response": "Асинхронная маршрутизация, позволяет не сразу создавать модуль, а когда пользователь переходит по определённому роутингу",
      "level": "Junior",
      "active": false
    },
    {
      "id": "768c",
      "title": "Что такое интерсепторы (interceptors) в Angular?",
      "response": "Интерсепторы (interceptors) в Angular являются частью модуля HttpClient и предоставляют мощный механизм для перехвата и обработки HTTP-запросов и ответов. Они позволяют разработчикам добавлять функциональность для каждого запроса и ответа на глобальном уровне, не изменяя сами компоненты или сервисы. Это может быть полезно для обработки заголовков, управления ошибками, добавления токенов аутентификации, логирования, кеширования и других задач.Интерсепторы являются классами, которые реализуют интерфейс HttpInterceptor. Для их создания необходимо выполнить следующие шаги:1. Создание класса интерсептора. Он должен реализовать метод intercept, который принимает два параметра: объект HttpRequest и объект HttpHandler. Этот метод должен возвращать объект Observable, который представляет ответ от сервера.2. Регистрация интерсептора. Интерсептор необходимо зарегистрировать в корневом модуле приложения или в соответствующем модуле, добавив его в массив providers.Применение интерсепторов:Интерсепторы могут использоваться для различных задач:1. Добавление токенов авторизации. Например, вы можете добавлять JWT-токены в заголовки каждого  защищенного запроса.2. Обработка ошибок. Интерсептор может обрабатывать ошибки от сервера и предоставлять единый подход к этому, вместо необходимости делать это в каждом сервисе или компоненте.3. Логирование. Вы можете записывать все исходящие запросы и входящие ответы для отладки или аудита.4. Модификация запросов и ответов. Интерсепторы могут изменять или фильтровать данные запроса и ответа перед их отправкой или после получения.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "befa",
      "title": "Взаимодействие с формами",
      "response": "В Angular взаимодействие с формами осуществляется с помощью двух основных подходов: реактивные формы и шаблонные формы.Оба подхода позволяют обрабатывать пользовательский ввод и валидировать данные, но используют разные механизмы и подходы.1. Шаблонные формы (Template-driven Forms)Шаблонные формы ориентированы на использование декларативного подхода и позволяют управлять формами через HTML-шаблоны.Для работы с ними нужно импортировать модуль FormsModule.2. Реактивные формы (Reactive Forms) Реактивные формы ориентированы на использование императивного подхода, предоставляя большую гибкость и контроль над формами.Для работы с реактивными формами нужно импортировать модуль ReactiveFormsModule.Оба подхода поддерживают валидацию форм. В шаблонных формах валидация осуществляется через атрибуты (например, required),а в реактивных формах — через встроенные валидаторы или пользовательские валидаторы.Шаблонные формы проще и быстрее в реализации, в то время как реактивные формы предоставляют  больше контроля и гибкости, особенно для сложных сценариев.",
      "level": "Middle",
      "active": false
    }
  ],
  "algorithms": [
    {
      "id": "b117",
      "title": "Что такое алгоритмы?",
      "response": "Алгоритмы в программировании представляют собой последовательность четко определенных шагов или правил, которые используются для решения определенной задачи или выполнения определенной операции. Алгоритм можно рассматривать как набор инструкций, который переводит входные данные в выходные результаты. Алгоритмы широко применяются в программировании для выполнения различных задач, таких как сортировка данных, поиск информации, обработка изображений и многое другое.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "42c0",
      "title": "Сортировка массива пузырьком",
      "response": " Сортировка пузырьком (Bubble Sort) — один из самых простых алгоритмов сортировки. Он работает путем многократного прохода по массиву, сравнения соседних элементов и их обмена местами, если они находятся в неправильном порядке. Процесс продолжается до тех пор, пока не будет выполнен проход без обменов, что означает, что массив отсортирован. Принцип работы алгоритма:1. Начните с первого элемента массива.2. Сравните текущий элемент с следующим.3. Если текущий элемент больше следующего, обменяйте их.4. Перейдите к следующему элементу и повторите шаги 2-3 до конца массива.5. После завершения одного полного прохода, повторяйте процесс для всего массива, пока не будет выполнен проход без обменов.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "3607",
      "title": "Поиск числа в массиве",
      "response": "Поиск числа в массиве может быть выполнен различными алгоритмами в зависимости от того, отсортирован массив или нет.1. Линейный поиск (Linear Search) Линейный поиск — это самый простой алгоритм, который исследует каждый элемент массива по порядку. Он проверяет каждое значение, пока не найдет нужное число или не достигнет конца массива.2. Бинарный поиск (Binary Search) Бинарный поиск — это более эффективный алгоритм, который применяется только для отсортированных массивов. Он работает, разбивая массив пополам и проверяя, находится ли искомый элемент в левой или правой половине. Сравнение алгоритмов \n- Линейный поиск:\n- Сложность времени: O(n) в худшем случае.\n- Прост в реализации и применим для неотсортированных массивов.- Бинарный поиск:- Сложность времени: O(log n) в худшем случае.- Эффективен только для отсортированных массивов и требует меньшего числа сравнений.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "bfc8",
      "title": "Поиск в глубину",
      "response": "Поиск в глубину (Depth-First Search, DFS) — это алгоритм для обхода или поиска в структуре данных ,такой как граф или дерево. Основная идея алгоритма состоит в том, чтобы начинать с корневой вершины (или произвольной начальной вершины для графов) и как можно глубже исследовать каждую ветвь, прежде чем отступить. DFS может быть реализован как с помощью рекурсии, так и с помощью стека. Принцип работы алгоритма DFS:1. Начинайте с корневой вершины и помечайте её как посещённую.2. Исследуйте все непосещённые соседние вершины, переходя в одну из них и повторяя шаг 1. 3. Если не осталось непосещённых соседей, вернитесь (отступите) к предыдущей вершине и повторите процесс для других непосещённых соседей.4. Повторяйте процесс, пока все вершины не будут посещены или пока не будет найдено нужное значение (если поиск).Характеристики DFS:- Сложность времени: O(V + E), где V — количество вершин, а E — количество рёбер в графе.- Сложность по памяти: O(V), т.к. необходимо хранить стеки или рекурсивные вызовы.- DFS может использоваться для решения задач вроде нахождения компонента связности, проверки простой связности графа,поиска циклов, топологической сортировки и других.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "7157",
      "title": "Обход дерева",
      "response": "Обходы дерева — это методы, с помощью которых можно пройти по всем узлам дерева в определённом порядке. Существуют три основных типа обхода для бинарных деревьев:1. Прямой обход (Pre-order traversal) В этом методе сначала обрабатывается (или посещается) текущий узел, затем левые дочерние узлы, и в конце правые дочерние узлы. Этот способ полезен, например, для создания копии дерева или преобразования дерева в префиксную запись.2. Центрированный обход (In-order traversal) При центреходе сначала обрабатываются левые дочерние узлы, затем текущий узел,и в конце правые дочерние узлы. Этот метод используется в бинарных деревьях поиска,поскольку при его выполнении узлы будут посещаться в отсортированном порядке.3. Обратный обход (Post-order traversal) В этом методе сначала обрабатываются левые и правые дочерние узлы, и только после этого текущий узел. Этот метод часто используется, когда необходимо выполнить действия, зависящие от дочерних узлов, например, при удалении дерева или вычислении значения в нём. Прямой обход подходит для случаев, когда нужно работать с родительским узлом первым, центрированный обход — для работы с отсортированными данными, а обратный обход — для обработки дочерних узлов перед родительскими.",
      "level": "Senior",
      "active": false
    },
    {
      "id": "7355",
      "title": "Алгоритм рекурсивного спуска",
      "response": "Алгоритм рекурсивного спуска — это метод, который применяется для решения различных задач, включая анализ и обработку выражений, синтаксический анализ и компиляцию языков программирования. Он используется для реализации рекурсивных грамматик. Рекурсивный спуск реализует синтаксический анализ программы, разбивая её на подзадачи с помощью рекурсии. Основные идеи алгоритма 1. Рекурсивные функции: Каждый элемент грамматики или конструкции языка реализуется через функцию. Если конструкция может быть рекурсивной, функция вызывает саму себя. 2. Грамматика: Рекурсивный спуск легче всего реализуется для грамматик, которые не содержат левой рекурсии. Это означает, что рекурсивные правила не должны вызывать самих себя в левой части.3. Состояние: В процессе анализа алгоритм работает с состоянием, которое включает в себя текущий токен, индекс в исходном потоке и, возможно, дополнительные параметры для хранения промежуточных  результатов.Преимущества:- Простота реализации и понимания.- Хорошо подходит для задач синтаксического анализа.Недостатки: - Неэффективен для грамматик с левой рекурсией.- Может привести к переполнению стека при глубокой рекурсии.",
      "level": "Senior",
      "active": false
    }
  ],
  "linux": [
    {
      "id": "22a9"
    }
  ],
  "categories": [
    {
      "id": "0",
      "name": "Структуры данных",
      "endpoint": "/data-struct"
    },
    {
      "id": "1",
      "name": "JavaScript",
      "endpoint": "/javascript"
    },
    {
      "id": "2",
      "name": "Обьектно-ориентированное программирование",
      "endpoint": "/oop"
    },
    {
      "id": "3",
      "name": "Тестирование",
      "endpoint": "/testing"
    },
    {
      "id": "4",
      "name": "Angular",
      "endpoint": "/angular"
    },
    {
      "id": "5",
      "name": "TypeScript",
      "endpoint": "/typescript"
    },
    {
      "id": "6",
      "name": "Паттерны проектирования",
      "endpoint": "/patterns"
    },
    {
      "id": "7",
      "name": "Сетевые протоколы",
      "endpoint": "/net-protocols"
    },
    {
      "id": "8",
      "name": "Алгоритмы",
      "endpoint": "/algorithms"
    },
    {
      "id": "9",
      "name": "Linux",
      "endpoint": "/linux"
    },
    {
      "id": "10",
      "name": "rxjs",
      "endpoint": "/rxjs"
    },
    {
      "id": "11",
      "name": "Git",
      "endpoint": "/git"
    },
    {
      "id": "12",
      "name": "CSS",
      "endpoint": "/css"
    }
  ],
  "javascript": [],
  "css": [
    {
      "id": "500f",
      "title": "Что такое CSS3 и чем он отличается от предыдущих версий CSS?",
      "response": "CSS3 (Cascading Style Sheets Level 3) — это третья версия каскадных таблиц стилей, которая используется для описания внешнего вида и формата документа, написанного на HTML или XML (включая такие) языки разметки, как SVG и XHTML). CSS3 добавляет новые возможности и улучшения по сравнению с предыдущими версиями, что делает стилизацию веб-страниц более гибкой и мощной.Основные отличия CSS3 от предыдущих версий CSS:1. Модули: - CSS3 организован в виде модулей, каждый из которых отвечает за определенные функции. Это позволяет разработчикам использовать только те части CSS3, которые им нужны, без необходимости загружать весь стандарт.- Например, есть модули для градиентов, теней, анимаций и т. д.2. Новые селекторы:- CSS3 предлагает множество новых селекторов, таких как :nth-child(), :not(), :first-of-type, и других. Эти селекторы делают выбор элементов более точным и простым.3. Градиенты:- В CSS3 можно использовать градиенты без необходимости в использовании изображений.Благодаря свойству background можно создавать линейные и радиальные градиенты прямо в CSS.4. Медиазапросы:- CSS3 вводит медиазапросы, которые позволяют применять стили в зависимости от различных условий, таких как размер экрана устройства. Это является основой для создания адаптивного дизайна.5. Новые свойства для работы с шрифтами:- CSS3 предоставляет поддержку @font-face, которая позволяет загружать и использовать шрифты на веб-страницах, улучшая типографику и дизайн.6. Флексбокс и Grid Layout:- CSS3 вводит новые единицы и модели компоновки, такие как Flexbox и CSS Grid.Они значительно упрощают создание сложных макетов, позволяя лучше управлять расположением и размером элементов.7. Анимации иTransitions:- В CSS3 можно создавать анимации без использования JavaScript, используя свойства transition и animation. Это позволяет добавлять плавные изменения стилей и анимацию к элементам при взаимодействии с пользователем.8. Тени:- CSS3 позволяет добавлять тени к элементам с помощью свойств box-shadow и text-shadow,что дает больше возможностей для дизайна.Заключение:CSS3 представляет собой значительное улучшение по сравнению с предыдущими версиями,предоставляя разработчикам мощные инструменты для создания современных и привлекательных веб-интерфейсов.Эти улучшения делают CSS3 более адаптивным, мощным и удобным для работы,что в свою очередь улучшает пользовательский опыт и визуальную привлекательность веб-страниц.",
      "level": "Junior",
      "active": true
    },
    {
      "id": "5a8e",
      "title": "Какие новые селекторы были добавлены в CSS3? Приведите примеры.",
      "response": "В CSS3 были добавлены несколько новых селекторов, которые делают выбор элементов более гибким и точным.Вот некоторые из них с примерами использования:1. Селекторы по псевдоклассам - :nth-child(n):- Выбирает элементы, которые являются n-ыми дочерними элементами своего родителя, где n может быть числом,ключевым словом или формулой.:nth-of-type(n):- Работает аналогично :nth-child(n), но только для элементов определенного типа.:first-child и :last-child: - Селекторы для выбора первого или последнего дочернего элемента.:not(selector):- Выбирает все элементы, которые не соответствуют указанному селектору.2. Селекторы по состоянию - :hover: - Селектор для применения стилей при наведении мыши на элемент.:focus:- Селектор для элементов, находящихся в фокусе, например, при клике или при использовании клавиатуры.3. Псевдоэлементы - ::before и ::after:- Позволяют добавлять контент перед или после содержимого элемента.4. Групповые селекторы - :checked:- Выбирает элементы формы, такие как радио-кнопки или чекбоксы, которые отмечены.:disabled и :enabled:- Выбирает отключенные или включенные элементы формы.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "4cba",
      "title": "Что такое медиазапросы в CSS3, и как они используются для адаптивного дизайна?",
      "response": "Медиазапросы (media queries) в CSS3 — это мощный инструмент, который позволяет применять различные стили к документу в зависимости от определённых характеристик устройства, на котором он отображается. Это широко используется для создания адаптивного дизайна, который позволяет веб-страницам выглядеть и работать оптимально на разных устройствах, таких как мобильные телефоны, планшеты и десктопы.Основные функции медиазапросов:1. Тargeting Different Devices:- Медиазапросы позволяют определять параметры устройства, включая ширину экрана, высоту, плотность пикселей и ориентацию (пейзаж или портрет).2. Применение различных стилей:- С помощью медиазапросов возможно изменять стиль элементов в зависимости от устройства,обеспечивая лучшую читаемость и удобство пользователей.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "c8fc",
      "title": "Какие знаете методологии верстки? (БЭМ, SMACSS, ECSS, RSCSS, OOCSS)",
      "response": "1. БЭМ (Блок, Элемент, Модификатор)- Описание: БЭМ (Block, Element, Modifier) — это методология, разработанная для повышения читаемости и повторяемости кода. Она делит интерфейс на независимые блоки, которые могут быть модифицированы.- Структура:- Блок: независимый компонент (например, header, menu).- Элемент: часть блока, не имеющая смысла вне его (например, menu__item).- Модификатор: модификация блока или элемента (например, button--large, menu--open).2. SMACSS (Scalable and Modular Architecture for CSS) - Описание: SMACSS — это методология, направленная на создание масштабируемой и модульной архитектуры CSS. Она делит стили на категории и акцентирует внимание на гибкости и лёгкости поддержки.- Категории:- Baseline: основные стили для приложения.- Layout: стили для глобального макета.- Module: повторно используемые компоненты.- State: состояния элементов (например, состояние активности).- Theme: стили для различных тем оформления.3. ECSS (Essential CSS) - Описание: ECSS — это методология, фокусирующаяся на уменьшении избыточности и упрощении структуры CSS. В ней акцентируется внимание на том, что стили должны отражать структуру HTML.- Принципы:- Избегание дублирования свойств.- Минимизация вложенности.- Простота и легкость в поддержке.4. RSCSS (Reasonable System for CSS Styles)- Описание: RSCSS — это методология, которая акцентирует внимание на ясной структуре, читаемости и легкости поддержки. Она предлагает определенный набор практик для организации стилей.- Структура:- Component: ядро стиля элемента.- Modifier: изменения состояния компонента.- Namespace: пространство имен для идентификации компонентов.5. OOCSS (Object Oriented CSS) - Описание: OOCSS (Объектно-Ориентированный CSS) — это методология, которая относится к подходу к созданию интерфейсов, пропагандируемому объектно-ориентированным программированием. Основное внимание уделяется разделению структуры и внешнего вида.- Основные принципы:- Разделение структуры и кожи: стиль объектов (например, цвета, шрифты) отделяется от их структуры.- Повторное использование: максимальное использование классов для повторного использования.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "a60f",
      "title": "Шаблонизаторы css. Фреймворки на серверной стороне",
      "response": "Шаблонизаторы CSS и серверные фреймворки играют важную роль в разработке веб-приложений. Давайте рассмотрим их подробнее.Шаблонизаторы CSS Шаблонизаторы CSS позволяют использовать различные приемы для упрощения написания стилей, создания структуры и переиспользования кода. Вот несколько наиболее распространенных шаблонизаторов и препроцессоров CSS:1. Sass (Syntactically Awesome Style Sheets)- Описание: Sass добавляет к CSS переменные, вложенность, функции и миксины. Он компилируется в стандартный CSS.2.LESS - Описание: LESS также является препроцессором, который добавляет возможности работы с переменными, миксинами и вложенностью.3.Stylus - Описание: Stylus – гибкий и мощный препроцессор, позволяющий писать CSS в более краткой и удобной форме.4.PostCSS - Описание: PostCSS — это инструмент для обработки CSS с помощью JavaScript-плагинов. Он может использоваться для добавления переменных, функций и других возможностей, аналогичных Sass и LESS. - Пример использования: Использование плагинов, таких как autoprefixer для автоматического добавления вендорных префиксов.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "bcb0",
      "title": "Основные правила БЭМ. Максимальная вложенность по БЭМ. Где в БЭМ может быть каскад? Где можно использовать/где нельзя",
      "response": "Основные правила БЭМ 1. Именование:'- Используйте нижнее подчеркивание (_) для разделения блоков и элементов, а также дефис (-) для разделения слов.- Блоки именуются в единственном числе (например, menu), элементы — в форме block__element (например, menu__item), модификаторы — block--modifier или block__element--modifier (например, button--primary или menu__item--active).2. Разделение на блоки и элементы:- Блок — это независимый компонент, который может использоваться в любом месте и не зависит от других блоков.- Элемент — это часть блока, смысл которой не имеет значения вне его.3. Модификаторы:- Модификатор определяет вид, состояние или поведение блока или элемента. Он позволяет создать разные вариации одного и того же блока/элемента.4. Композиция:- БЭМ поддерживает композицию, когда один блок может содержать другие блоки. Это помогает структурировать интерфейс без излишней вложенности.5. Отсутствие каскадности:- БЭМ как методология ограничивает использование каскада. Структура классов должна быть такой, чтобы стили можно было легко переопределить без использования каскадных селекторов на основе иерархий.Максимальная вложенность по БЭМ В БЭМ рекомендованная максимальная вложенность составляет 2-3 уровня. Это позволяет избежать излишней сложности Подходы с более глубокой вложенностью усложняют понимание структуры и могут затруднить переиспользование стилей и компонентов.Где в БЭМ может быть каскад?Каскад может быть использован ограниченно, например:- Внутри блока, когда некоторые стили блока могут зависеть от состояний модификаторов. Например, вы можете использовать каскад для управления видимостью или размером элементов внутри блока  Где можно использовать/где нельзя Можно использовать:- Модификаторы для изменения стилей блока или элемента.- Стилизованные компоненты, которые не относятся к другим блокам, например, кнопки, заголовки и т. д. Нельзя использовать:- Глубокую вложенность в 4 и более уровня (это приводит к усложнению понимания и поддержки).- Применять CSS-классы через каскад на основе иерархии, чтобы избежать конфликта и непредсказуемого поведения стилей.- Избегайте избыточности — не дублируйте стили и не создавайте множество модификаторов для одной и той же функциональности.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "5f4c",
      "title": "border-box особенности, отличия от стандартного",
      "response": "Свойство box-sizing в CSS определяет, как рассчитываются размеры элемента, включая его ширину и высоту. Значение border-box — одно из возможных значений для этого свойства, и оно имеет определённые особенности по сравнению со стандартным значением content-box. Давайте рассмотрим эти особенности и отличия:box-sizing: content-box (стандартное значение)1. Оригинальное значение: Это значение является значением по умолчанию для всех элементов. Когда устанавливается ширина или высота элемента, это значение не включает границы и внутренние отступы (padding).2. Рассчет размеров: Ширина и высота (width, height) элемента рассчитываются только для внутреннего содержимого, что означает, что если вы добавляете границы или внутренние отступы, они увеличивают общий размер элемента:- Общий размер элемента = width + padding + border box-sizing: border-box 1. Границы и отступы учитываются: Когда box-sizing установлен в border-box, ширина и высота элемента включают в себя как внутренние отступы (padding), так и границы (border). Это значительно упрощает расчет размеров элемента.2. Рассчет размеров: Размеры элемента устанавливаются более интуитивно, так как они включают в себя все компоненты, и при создании макетов проще контролировать размеры элементов:- Общий размер элемента = width (включает padding и border) content-box Как считаются размеры | Только содержимое (width/height) Как рассчитывается общий размер | width + padding + border | width Интуитивность | Меньше интуитивно, требует дополнительного расчета Использование | Иногда требует дополнительных вычислений border-box Как считаются размеры | Включает содержимое, padding и border | Как рассчитывается общий размер| width равен размеру элемента, включая все | Интуитивность | Более интуитивно и удобно в верстке | Использование| Широко используется в адаптивной и гибкой вёрстке |",
      "level": "Middle",
      "active": false
    },
    {
      "id": "97f0",
      "title": "Что такое уникальность (специфичность) селектора",
      "response": "Уникальность (или специфичность) селектора в CSS — это мера того, как браузер определяет, какие стили применяются к элементу, когда к нему применяется несколько правил CSS. Специфичность помогает избежать конфликтов и обеспечивает правильное применение стилей, когда несколько селекторов совпадают с одним и тем же элементом. Она рассчитывается на основе различных типов селекторов с учётом их значимости.Как вычисляется специфичность?Специфичность определяется по системе указателей, которая складывается из разных категорий селекторов. Основные категории и их вес:1. Инлайн-стили (1, 0, 0, 0) - Такие стили применяются непосредственно в атрибуте style элемента HTML. - Пример: div style=\"color: red;\">. 2. Идентификаторы (0, 1, 0, 0) - Стили, определенные через ID селектор. У ID селекторов имеется вес одного пункта. - Пример: #header.3. Классы, псевдоклассы и атрибуты (0, 0, 1, 0) - Это селекторы классов, псевдоклассов (например, :hover, :nth-child) и атрибутов.- Пример: .menu, input[type=\"text\"].4. Теги и псевдоэлементы (0, 0, 0, 1)- Селекторы тегов (например, div, p) и псевдоэлементы (например, ::before, ::after).- Пример: p, div.menu.Как работает специфичность?Когда браузер применяет стили, он оценивает специфичность всех соответствующих селекторов. Если два или более селектора применяются к одному элементу, браузер выберет селектор с наивысшей специфичностью. Если специфичность совпадает, то последнее по порядку правило в CSS будет применено.Важные нюансы - Порядок расположения селекторов в CSS имеет значение. Если два селектора имеют одинаковую специфичность, то применяется последний из них.- Инлайн-стили имеют наивысшую специфичность и всегда будут применяться, если стилей на уровне внешнего CSS недостаточно.- Чтобы определить, какой стиль применяется, удобно использовать инструменты разработчика в браузере.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "900d",
      "title": "Какой атрибут делает поле формы обязательным для заполнения?",
      "response": "Чтобы сделать поле формы обязательным для заполнения в HTML, используется атрибут required. Когда этот атрибут добавлен к элементу формы (например, к input>, textarea>, или select>), браузер будет проверять, заполнено ли это поле перед отправкой формы.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "db4c",
      "title": "Важны ли стили для SEO?",
      "response": "Стили (CSS) не влияют напрямую на SEO (поисковую оптимизацию) с точки зрения ранжирования в поисковых системах, но они играют косвенно важную роль в улучшении общего пользовательского опыта и восприятии сайта. Вот несколько аспектов, в которых стили могут повлиять на SEO:1. Пользовательский опыт - Время загрузки: Оптимизированные стили могут способствовать более быстрому рендерингу страницы. Быстро загружающиеся сайты с хорошей версткой предлагают лучший пользовательский опыт, что может положительно сказаться на ранжировании. - Читабельность: Хорошо оформленный текст (например, размер шрифта, цвет, контраст) повышает читабельность, что может снизить показатель отказов и повысить время, проведенное на сайте.2. Мобильная адаптация- Отзывчивый дизайн: Стили, которые обеспечивают адаптацию сайта под различные устройства (мобильные, планшеты, компьютеры), важны для SEO, поскольку Google учитывает мобильную версию сайта при поисковой индексации и ранжировании.- Мобильный пользовательский опыт: Если CSS сайта хорошо оптимизирован и делает контент удобным для просмотра на мобильных устройствах, это может positively wow пользовательский опыт, что тоже важно для SEO.3. Структура страницы - Грамотное использование HTML и CSS: Стили могут помочь создать более понятную структуру страницы. Например, использование списков, заголовков и других семантических элементов помогает поисковым системам лучше индексировать контент.- Классные селекторы: Правильное применение классов и идентификаторов может позволить вам легко управлять контентом и выделять важные элементы, которые могут быть полезны для SEO.4. Индексация - Скрытый контент: Некоторые стили могут использоваться для скрытия контента (например, display: none). Если поисковые системы найдут такой скрытый контент, это может негативно сказаться на вашем SEO, особенно если они сочтут это попыткой манипуляции.- Кроссбраузерная совместимость: Хорошо стилизованный сайт, который выглядит и работает одинаково хорошо во всех браузерах, повышает вероятности, что пользователи не будут сталкиваться с проблемами, которые могли бы уменьшить их доверие к сайту.",
      "level": "Senior",
      "active": false
    },
    {
      "id": "8203",
      "title": "Что такое препроцессор? Приведите примеры препроцессоров.",
      "response": "Препроцессор — это инструмент, который предварительно обрабатывает исходный код, написанный на одном языке, переводя его в другой язык или в простой машинный код. Препроцессоры часто используются в веб-разработке для улучшения структуры, читаемости и удобства работы с кодом. Они позволяют применять различные функциональные возможности, такие как переменные, вложенные правила, функции и миксины, что делает написание и сопровождение кода более эффективным.Вот примеры самых распространенных типов препроцессоров:1. CSS-препроцессоры - Sass (Syntactically Awesome Style Sheets):- Sass добавляет в CSS такие возможности, как переменные, вложенность, миксины, функции и другие.- LESS:- LESS также поддерживает такие возможности, как переменные, вложенность, операции и логические условные конструкции.- Stylus:- Stylus — это гибкий и мощный CSS-препроцессор, который сильно отличается от обычного CSS, позволяя писать менее явный код.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "8390",
      "title": "Миксины в less",
      "response": "Миксины в Less — это один из ключевых инструментов, который позволяет повторно использовать группы стилей в вашем CSS-коде. Они более удобны, чем простые классы, так как позволяют инкапсулировать стиль и применять его к различным элементам. Это особенно полезно при создании сложных стилей, которые могут применяться к нескольким селекторам или в разных контекстах.Основные характеристики миксинов в Less:1. Определение миксина: Миксин определяется с помощью специального синтаксиса, используя имя миксина, за которым следует перечень свойств.2. Параметры: Миксины могут принимать параметры, что позволяет делать их более гибкими и адаптируемыми к различным условиям.3. Наследование: Миксины могут наследовать другие миксины, что способствует уменьшению дублирования кода.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "d678",
      "title": "Амперсанд (&) в less",
      "response": "В Less символ амперсанда (&) используется для обозначения родительского селектора в контексте вложенных стилей. Это позволяет создавать более структурированные и организованные правила CSS, избегая дублирования кода и делая его более читабельным. Рассмотрим подробнее, как и где можно использовать амперсанд в Less.Основные применения амперсанда (&) в Less 1. Вложенные селекторы:Амперсанд позволяет обращаться к родительскому селектору внутри вложенных правил. Это особенно полезно при создании комбинаций классов или когда нужно изменить свойства в зависимости от состояния элемента.2. Использование с псевдоклассами и псевдоэлементами:Вы можете использовать амперсанд, чтобы добавить псевдоклассы или псевдоэлементы к текущему селектору 3. Комбинированные селекторы:Используя амперсанд, вы можете создать более сложные селекторы без дублирования кода.4. Миксины с амперсантом:Амперсанд также можно использовать внутри миксинов, что позволяет использовать родительский селектор в различных контекстах.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "ae04",
      "title": "Что такое постпроцессор? Как пост-процессор работает «под капотом»?",
      "response": "Постпроцессор — это инструмент, который работает с уже скомпилированным CSS-кодом, добавляя дополнительные преобразования и оптимизации. В отличие от препроцессора, который модифицирует исходный код на этапе его написания и компиляции (например, Sass, Less, Stylus), постпроцессор обрабатывает уже готовый CSS-файл, выполняя различные задачи, такие как оптимизация, добавление вендорных префиксов, минификация и другие преобразования. Примеры популярных постпроцессоров 1. PostCSS — это самый распространенный инструмент для постобработки CSS. Он предоставляет API для создания плагинов, что позволяет добавлять функциональность.2. Autoprefixer — это плагин для PostCSS, который автоматически добавляет вендорные префиксы к CSS-свойствам, чтобы обеспечить кросс-браузерную совместимость.3. CSSNano — постпроцессор, который минифицирует CSS для уменьшения размера файлов и увеличения скорости загрузки.Как постпроцессор работает «под капотом»?1. Чтение исходного CSS: Постпроцессор сначала считывает уже скомпилированный CSS-файл, который необходимо обработать.2. Парсинг: Код CSS разбивается на абстрактное синтаксическое дерево (AST, Abstract Syntax Tree). AST — это структура данных, представляющая иерархические отношения между элементами CSS.3. Обработка через плагины: Постпроцессоры часто используют плагины для выполнения различных преобразований. Например:- Вендорные префиксы: Проверка свойств на необходимость добавления префиксов с помощью формул, определяющих, для каких браузеров и версий это требуется.- Минификация: Удаление пробелов, комментариев и сокращение длинных свойств для уменьшения размера файла.4. Генерация итогового CSS: После применения всех заданных преобразований, постпроцессор формирует окончательный CSS-код, который затем может быть записан в файл или использован в браузере.",
      "level": "Senior",
      "active": false
    },
    {
      "id": "4ac5",
      "title": "Расскажите как работает z-index? Если z-index не задан?",
      "response": "z-index — это CSS-свойство, которое контролирует порядок наложения элементов в трехмерном пространстве веб-страницы. Оно определяет, какой элемент будет располагаться \"над\" или \"под\" другим элементом, когда они накладываются друг на друга. Чтобы правильно понять, как работает z-index, нужно учитывать несколько вещей.Основные понятия 1. Контекст наложения:- z-index работает только в пределах контекста наложения. Контекст наложения создается для элементов, имеющих определенные свойства position (например, relative, absolute, fixed или sticky) и с заданным значением z-index.- Каждый элемент с position и определенным z-index образует собственный контекст наложения для его потомков.2. Значения z-index:- z-index принимает целые числа, включая отрицательные значения. Больше значение z-index означает, что элемент будет находиться выше (ближе к зрителю) по сравнению с элементами с меньшими значениями z-index.- Например, если у вас есть три элемента с z-index: 1, z-index: 2, и z-index: 3, элемент с z-index: 3 будет находиться выше остальных.3. Автоматическое поведение:- Если z-index не задан, элементы располагаются на основание порядка их размещения в HTML-документе. Элементы, которые расположены в документе позже, будут отображаться выше тех, которые расположены раньше. Например, если у вас есть два перекрывающихся элемента, и ни один из них не имеет установленных z-index, тот, который написан после другого в HTML, будет виден сверху.Заданный z-index:- Элементы с установленными значениями z-index и соответствующими позициями могут перекрывать другие элементы.- Не заданный z-index:- Если у элемента не установлен z-index, но он имеет position, он будет принимать значение z-index: auto по умолчанию. При этом он будет помещён в порядок наложения в соответствии с его положением в документе и контекстом наложения.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "f0e0",
      "title": "Зачем нужны mediaQueries?",
      "response": "Media queries (медиа-запросы) — это важный инструмент в CSS, предназначенный для создания адаптивных и отзывчивых веб-дизайнов. Они позволяют изменять стиль веб-страницы в зависимости от различных характеристик устройства, на котором она отображается. Вот основные причины, зачем нужны media queries:1. Адаптивный дизайн Медиа-запросы позволяют разработчикам создавать адаптивные макеты, которые могут автоматически изменять свое отображение в зависимости от размера экрана устройства. Это помогает обеспечить удобство использования на мобильных устройствах, планшетах и настольных компьютерах.2. Оптимизация пользовательского опыта С помощью медиа-запросов можно изменять элементы интерфейса, такие как размеры шрифтов, отступы, расположение изображений и многое другое, чтобы улучшить пользовательский опыт в зависимости от устройства. Например, на мобильных устройствах можно сделать текст более крупным и уменьшить количество столбцов в сетке. 3. Перегрузка контента Медиа-запросы позволяют включать или отключать определенные стили, изображения и другие элементы в зависимости от размера экрана или других параметров устройства. Например, можно загружать менее тяжелые изображения для мобильных устройств, чтобы сократить время загрузки. 4. Контроль за производительностью Используя медиа-запросы, разработчики могут оптимизировать производительность сайта, загружая только нужные стили и контент в зависимости от устройства. Это особенно важно для мобильных пользователей с ограниченным доступом к данным.5. Поддержка различных разрешений и ориентаций Медиа-запросы позволяют адаптировать дизайн в зависимости от разрешения экрана и ориентации устройства (портретная или альбомная). Это особенно актуально для планшетов и смартфонов, которые могут работать в разных режимах.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "64c1",
      "title": "Чем отличается {display: none} от {visibility: hidden}",
      "response": "Свойства CSS {display: none} и {visibility: hidden} часто используются для управления видимостью элементов на веб-странице, но они имеют разные эффекты на элементы и их поведение в документе. Вот основные различия между ними:1. Отображение элемента - {display: none}: - Убирает элемент из потока документа. Элемент не будет отображаться на странице, и он не будет занимать место. Это означает, что соседние элементы могут занять место, которое было освобождено. - {visibility: hidden}: - Скрывает элемент, но элемент по-прежнему занимает место в потоке документа. То есть, пространство, которое он занимал, остается, но содержимое не отображается.2. События - {display: none}: - Элементы с этим стилем не участвуют в обработке событий. Например, на них не срабатывают клики или другие события мыши.- {visibility: hidden}:- Скрытые элементы по-прежнему могут обрабатывать события (например, на них можно назначить обработчики), но поскольку они невидимы, пользователи не могут с ними взаимодействовать.3. Использование в анимации - Элементы с {visibility: hidden} могут использоваться в анимациях, так как они по-прежнему существуют в DOM-дереве.  Элементы с {display: none} не могут участвовать в анимации, поскольку они полностью убираются из DOM. 4. Примеры использования - {display: none} подходит для случаев, когда необходимо полностью удалить элемент с экрана, например, скрытие модальных окон или переключение между вкладками.- {visibility: hidden} может быть использовано, например, для временного скрытия элементов интерфейса (таких как подсказки), где важно сохранить место в компоновке страницы.Когда вы выбираете между {display: none} и {visibility: hidden}, определите, требуется ли вам сохранить место для элемента в потоковой компоновке. Если элемент не должен занимать место — используйте {display: none}. Если нужно скрыть его, но сохранить место — используйте {visibility: hidden}.",
      "level": "Senior",
      "active": false
    },
    {
      "id": "a30b",
      "title": "Что такое свойство Position",
      "response": "Свойство position в CSS определяет, как элемент будет позиционирован на странице, а также взаимодействие с другими элементами в документе. Оно играет важную роль в компоновке веб-страниц. Значения свойства position определяют контекст позиционирования для элемента.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "13ea",
      "title": "Назовите возможные свойства position",
      "response": "1. static - Это значение по умолчанию для всех элементов. Элементы с position: static располагаются в естественном потоке документа. Позиционирование не зависит от других элементов.- Свойства top, right, bottom, и left для таких элементов игнорируются. 2. relative - Элемент позиционируется относительно своего нормального положения в потоке документа. - Если задать свойства top, right, bottom, или left, элемент будет смещен от его первоначального положения, но при этом займет свое обычное место в потоке, и другие элементы будут вести себя так, будто он находится в своём исходном месте.3.. absolute - Элемент позиционируется относительно ближайшего предка с ненормальным (то есть не static) позиционированием. Если таких предков нет, элемент будет позиционироваться относительно окна обозревателя (viewport).- При использовании position: absolute элемент вынимается из потока документа, то есть не занимает места, и другие элементы будут располагаться так, как будто его нет.4. fixed - Элемент фиксирован в отношении окна браузера, а не потока документа. Это означает, что он останется на одном и том же месте экрана при прокрутке страницы.- Также вынимается из потока документа, как и элемент с position: absolute.5. sticky - Элемент ведёт себя как relative, пока не достигнет определённой позиции прокрутки, после чего ведет себя как fixed. - Это означает, что элемент будет оставаться в своем нормальном положении до тех пор, пока его верхняя граница не достигнет верхней части viewport, после чего он будет оставаться на месте при дальнейшей прокрутке.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "77c3",
      "title": "Объясните, что такое Flexbox и как он упрощает работу с расположением элементов на странице",
      "response": "Flexbox (Flexible Box Layout) — это модель компоновки CSS, предназначенная для более эффективного распределения пространства и выравнивания элементов в контейнерах, даже когда их размер неизвестен или динамически меняется. Flexbox предоставляет гибкий и интуитивно  понятный способ управления расположением элементов, что значительно упрощает создание адаптивных и отзывчивых дизайнов. Основные характеристики Flexbox:1. Гибкость: Flexbox позволяет элементам внутри контейнера изменять свои размеры и порядок в зависимости от доступного пространства, что обеспечивает гибкость макета.2. Выравнивание: Flexbox облегчает выравнивание элементов по горизонтали и вертикали, позволяя  разработчикам быстро выравнивать элементы по центру, краям или между собой. 3. Перенос элементов: Элементы могут быть легко перенесены на новую строку или в колонку, что полезно для адаптивных макетов.4. Простота управления: Flexbox делает управление пространством между элементами более понятным и простым.Можно задать отступы и размеры, которые автоматически адаптируются.Основные компоненты Flexbox:1. Контейнер Flexbox: Элемент, к которому применяются свойства Flexbox. Это родительский элемент, содержащий дочерние элементы (flex items).2. Элементы Flexbox: Дочерние элементы контейнера, которые будут управляться с помощью Flexbox.Основные свойства Flexbox:CSS-свойства для контейнера:- display: flex;: Применяет модель Flexbox к элементу.- flex-direction: Определяет направление расположения элементов (по умолчанию — row).- Примеры:- row — элементы располагаются по горизонтали.- column — элементы располагаются по вертикали.- justify-content: Устанавливает выравнивание элементов по главной оси.- Примеры:- flex-start — выравнивание по началу.- flex-end — выравнивание по концу.- center — центрирование.- space-between — равномерное распределение с отступами между элементами.- space-around — равномерное распределение с отступами вокруг элементов.- align-items: Устанавливает выравнивание по поперечной оси.- Примеры:- flex-start — выравнивание по верхнему краю.- flex-end — выравнивание по нижнему краю.- center — вертикальное центрирование.- stretch — растяжение элементов на весь доступный размер.CSS-свойства для элементов:- flex-grow: Определяет, как элемент может расти, чтобы заполнить доступное пространство.- flex-shrink: Определяет, как элемент может сжиматься, чтобы избежать переполнения контейнера.- flex-basis: Устанавливает начальный размер элемента перед распределением пространства.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "ea99",
      "title": "В чем разница между display: block, display: inline, и display: inline-block?",
      "response": "- display: block: Элемент занимает всю ширину, начинается с новой строки, подходит для заголовков,абзацев и других блочных элементов.- display: inline: Элемент занимает только необходимую ширину, не начинается с новой строки, подходит для текста и других элементов, где не требуется контроль высоты.- display: inline-block: Элемент располагается рядом с другими элементами, не начиная новую строку,но может иметь заданную ширину и высоту, что делает его полезным для создания адаптивных интерфейсов.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "efe1",
      "title": "Как работают трансформации (transform) и трансляции (transition) в CSS3? Приведите примеры использования.",
      "response": "В CSS3 трансформации и трансляции — это два мощных инструмента,которые позволяют изменять положение, размер, угол и другие свойства элементов на веб-странице с помощью эффектов анимации и визуальных преобразований.1. Трансформации (transform) Свойство transform позволяет изменять 2D и 3D представления элементов.Оно может использоваться для таких преобразований, как:- Поворот (rotate) - Масштабирование (scale) - Перемещение (translate) - Наклон (skew) 2. Трансляции (transition) Свойство transition обеспечивает плавный переход между состояниями CSS. Оно позволяет контролировать изменение других CSS-свойств со временем (например, цвет, размер, положение или трансформацию).Вы можете указать время перехода, тип временной функции (ease, linear, ease-in и т. д.)  и свойства, к которым применяется переход.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "ea62",
      "title": "Что такое градиенты в CSS3 и как их можно использовать? Приведите пример градиента.",
      "response": "Градиенты в CSS3 — это плавные переходы между двумя или более цветами, которые могут использоваться в качестве фонов, заливок и других визуальных эффектов в веб-дизайне.Градиенты позволяют создавать красивые и современные эффекты, добавляя глубину и стиль на страницы без необходимости использования изображений.Типы градиентов в CSS:1. Линейные градиенты (linear-gradient):Линейный градиент плавно переходит между цветами в заданном направлении,которое можно определить с помощью угла или ключевых слов (например, to right, to bottom и т. д.).2. Радиальные градиенты (radial-gradient):Радиальный градиент создаёт эффект перехода от центра к внешним краям в виде круга или эллипса.Линейные градиенты:- direction: направление градиента (например, to right, to bottom, или угол в градусах).- color-stop: цветовые точки, которые определяют цвета градиента.Радиальные градиенты:- shape: форма градиента (например, circle или ellipse).- size: размер градиента (например, farthest-corner или closest-side).- position: положение градиента (например, center).- color-stop: цветовые точки.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "9049",
      "title": "Как использовать псевдоэлементы и псевдоклассы в CSS3? Приведите примеры",
      "response": "Псевдоэлементы и псевдоклассы в CSS3 — это мощные инструменты, которые позволяют нацеливаться на определённые части элементов или состояния элементов без изменения HTML-код. Это особенно полезно для создания стилизованных интерфейсов и улучшения внешнего вида страниц. Псевдоэлементы Псевдоэлементы позволяют стилизовать определённые части элемента. В CSS3 существуют следующие псевдоэлементы:- ::before — добавляет содержимое перед содержимым элемента. - ::after — добавляет содержимое после содержимого элемента. - ::first-line — стилизует первую строку текста элемента.- ::first-letter — стилизует первую букву текста.Псевдоклассы Псевдоклассы применяются к элементам на основе их состояния или положения в документе.Вот несколько распространённых псевдоклассов:- :hover — применяется, когда курсор находится над элементом.- :focus — применяется, когда элемент имеет фокус (например, поле ввода).- :nth-child(n) — выбирает элементы по их порядковому номеру.- :first-child — применяет стиль к первому дочернему элементу.- :last-child — применяет стиль к последнему дочернему элементу.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "ec55",
      "title": "Что такое свойства box-shadow и text-shadow и как они работают?",
      "response": "Свойства box-shadow и text-shadow в CSS используются для создания теней вокруг объектов и текста соответственно. Эти свойства помогают добавить глубину и объем на веб-страницы,улучшая визуальное восприятие элементов.1. Свойство box-shadow Свойство box-shadow добавляет тень к элементам блоков . Оно определяет, как будет выглядеть тень, и имеет следующий синтаксис:(box-shadow: h-offset v-offset blur-radius spread-radius color;)- h-offset: Горизонтальное смещение тени (положительное значение смещает в право, отрицательное — влево).- v-offset: Вертикальное смещение тени (положительное значение смещает вниз, отрицательное — вверх)- blur-radius: Радиус размытия тени (чем больше значение, тем более размытой будет тень)- spread-radius: Радиус распространения тени (положительное значение увеличивает размер тени, отрицательное — уменьшает).- color: Цвет тени (возможно использование любых форматов цвета, например, HEX, RGB, RGBA и т.д.).Свойство text-shadow Свойство text-shadow используется для добавления теней к тексту. Синтаксис следующий:text-shadow: h-offset v-offset blur-radius color;- h-offset: Горизонтальное смещение тени (как и для box-shadow).- v-offset: Вертикальное смещение тени (как и для box-shadow).- blur-radius: Радиус размытия тени (помимо этого, увеличивает глубину).- color: Цвет тени.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "cccd",
      "title": "Объясните, как делать анимации с помощью CSS3. Каковы различные ключевые кадры (keyframes)?",
      "response": "Анимации в CSS3 позволяют создавать плавные переходы между состояниями элементов на веб-странице,добавляя динамическое взаимодействие и визуальный интерес.Для создания анимаций в CSS3 используется свойство animation и ключевые кадры (keyframes), которые определяют,как элемент будет выглядеть в разные моменты времени.Синтаксис анимации Чтобы создать анимацию, вам нужно выполнить следующие основные шаги:1. Определить ключевые кадры с помощью правила @keyframes.2. Применить анимацию к элементу с помощью свойства animation.1. Определение ключевых кадров Правило @keyframes позволяет задать анимацию, описывая, как элемент должен выглядеть на разных этапах анимации. Репрезентация анимации может включать множество ключевых кадров, но обычно используются два основных состояния: начальное (0%) и конечное (100%).Применение анимации Чтобы использовать определённые ключевые кадры, необходимо применить их к элементу с помощью свойства animation. Свойство animation Свойство animation может включать различные параметры: - animation-name: имя анимации (например, example) - animation-duration: длительность анимации (например, 4s или 2s) - animation-timing-function: функция временной анимации (например, linear, ease, ease-in, ease-out) - animation-delay: время задержки перед началом анимации - animation-iteration-count: количество повторений анимации (например, infinite или 3) - animation-direction: направление анимации (например, normal, reverse, alternate, alternate-reverse) - animation-fill-mode: определяет, как будет выглядеть элемент после окончания анимации (например, forwards, backwards)",
      "level": "Junior",
      "active": false
    },
    {
      "id": "ce3d",
      "title": "Что такое CSS-препроцессоры и почему они были созданы?",
      "response": "CSS-препроцессоры — это инструменты, которые расширяют возможности стандартного CSS,добавляя дополнительные функции и улучшая структуру стилей. Они предназначены для упрощения процесса написания и управления стилями в крупных проектах. К популярным CSS-препроцессорам относятся SASS (Syntactically Awesome Style Sheets), LESS и Stylus. Основные причины возникновения CSS-препроцессоров:1. Улучшение структуры кода Препроцессоры позволяют использовать вложенные правила, что делает код более читаемым и понятным.Это позволяет легко организовывать и управлять стилями, особенно в крупных проектах с иерархическими структурами.2. Повторно используемые стили:Препроцессоры поддерживают использование переменных, миксинов и функций, что позволяет избежать дублирования кода и легко обновлять стили в рамках проекта.3.Модулярность:Многие препроцессоры поддерживают возможность разбивки стилей на отдельные, более мелкие файлы, которые затем можно импортировать в основной файл. Это помогает организовать проект и улучшает управляемость кода.4.Расширенные функции и инструменты: Препроцессоры предлагают дополнительные функции, такие как математические операции,условные конструкции и циклы. Это позволяет создавать более динамичные и сложные стили.5. Упрощение управления стилями:Благодаря использованию функций, переменных и других функций, управление стилями становится более гибким и простым.Это особенно полезно в крупных проектах, где необходимо быстро вносить изменения.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "3a55",
      "title": "Объясните основные преимущества использования SASS в проекте.",
      "response": "SASS (Syntactically Awesome Style Sheets) — это один из самых популярных CSS-препроцессоров, который добавляет множество возможностей для написания стилей. Вот основные преимущества использования SASS в проектах:1. Вложенность SASS поддерживает вложенные правила, что позволяет организовать стили в логической иерархии,отражающей структуру HTML. Это делает код более читабельным и упрощает его поддержку.2. Переменные SASS позволяет использовать переменные, что упрощает управление значениями, такими как цвета, размеры шрифтов и другие параметры.Это также позволяет избежать дублирования кода.3. Миксины Миксины (mixins) позволяют создавать наборы стилей, которые можно повторно использовать по всему проекту,передавая им переменные.Это особенно удобно для стилизации повторяющихся элементов или условий.4. Функции SASS предоставляет встроенные функции для выполнения вычислений и манипуляций со значениями, а также возможность  создавать свои собственные функции.Это упрощает создание сложных стилей и взаимодействие с математикой.5. Парциальные файлы и импорты SASS позволяет разбивать стили на парциальные файлы, которые можно импортировать в основной файл.Это делает структуру проекта более организованной и облегчает управление стилями.6. Расширяемость (Extend) С помощью директивы @extend можно делиться стилями между классами, что позволяет избежать дублирования кода и упрощает обновление стилей.7. Сложные селекторы SASS позволяет использовать сложные селекторы с логическими условиями и операциями, что делает код более выразительным.8. Временные функции С помощью временных функций можно создавать анимации и переходы с динамическими значениями,что упрощает их написание и чтение.9. Улучшенная читаемость SASS упрощает написание кода и делает его более понятным, что особенно важно для  командной работы и поддержки проектов.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "6a40",
      "title": "Каковы основные синтаксические отличия между SASS и LESS?",
      "response": "SASS и LESS — это два популярных CSS-препроцессора, и хотя они оба предназначены для расширения возможностей CSS,они имеют различные синтаксические особенности. Давайте рассмотрим основные синтаксические отличия между SASS и LESS:1. Синтаксис- SASS SASS использует отступы вместо фигурных скобок и точек с запятой для определения блоков кода. Это работает как синтаксис, основанный на отступах, что делает код более чистым и читабельным.- LESS:LESS требует фигурные скобки и точки с запятой для определения блоков и завершения строк,что делает его ближе к привычному синтаксису CSS.2. Переменные - Объявление переменной: В SASS переменные обозначаются с помощью знака доллара  - LESS: Переменные обозначаются с помощью @ а присваивается (:) 3. Миксины в SASS 3.1. Объявление миксина: В SASS миксины объявляются с помощью директивы @mixin, за которой следует имя миксина и его параметры (если они есть).- Использование миксина: Для применения миксина в селекторе используется директива @include.3.2. Миксины в LESS - Объявление миксина: В LESS создается миксин через класс или с помощью функции, и для определения параметров используются символы @. - Использование миксина: Миксин вызывается простым обращением к его имени, за которым следуют переданные параметры в круглых скобках.3.3. Основные отличия между SASS и LESS - Синтаксис:- В SASS используется директива @mixin для объявления и @include для использования. Это выглядит несколько более формально.- В LESS миксины объявляются как функции и применяются просто как класс: мы вызываем имя миксина как из класса.- Вложенность:- В SASS можно вызывать миксины внутри других миксинов, и это можно делать на любом уровне вложенности.- В LESS тоже поддерживается вложенность, но как в функциях с параметрами, так и в точности, как в обычных классах.- Поддержка параметров:- Оба препроцессора поддерживают параметры для миксинов, однако в SASS можно задавать параметры по умолчанию и использовать @content для передачи дополнительных стилей.4. Наблюдение за изменениями и вложенными правилами - Оба препроцессора поддерживают вложенные правила, но SASS имеет более развитую функциональность благодаря директиве @extend, которая позволяет делиться стилями между классами, избегая дублирования.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "0476",
      "title": "Объясните концепцию переменных в SASS и LESS. Приведите пример.",
      "response": "Концепция переменных в SASS и LESS заключается в возможности хранения значений,таких как цвета, размеры шрифтов или любые другие значения, которые могут быть использованы многократно в стилях. Это улучшает управляемость,читабельность и поддержку кода, так как позволяет вносить изменения в единое место, а не искать каждое вхождение в коде.- Гибкость: Оба препроцессора позволяют использовать переменные в любом месте, где ожидается значение,однако SASS предлагает дополнительные возможности,такие как ссылки на переменные в миксинах и использование переменных как параметров с заданием значений по умолчанию.",
      "level": "Senior",
      "active": false
    },
    {
      "id": "aabf",
      "title": "Что такое вложенность правил (nesting), и как она работает в препроцессорах?",
      "response": "Вложенность правил (nesting) — это концепция, которая позволяет разработчикам писать CSS-правила внутри других CSS-правил, создавая структурированное и иерархическое представление стилей.Эта возможность значительно улучшает читаемость и организацию кода, позволяя легче видеть, как стили группируются и применяются к различным элементам страницы.Как работает вложенность в SASS и LESS Вложенность в SASS В SASS вложенность реализуется путем написания селекторов внутри других селекторов.Это делает код более логичным и удобным для восприятия. Вложенность в LESS В LESS вложенность работает аналогично. Вы можете писать селекторы внутри других  селекторов, что также делает структуру кода более понятной Основные преимущества вложенности 1. Упрощенная структура: Позволяет быстрее находить и редактировать связанные стили,поскольку визуально они находятся рядом друг с другом.2. Лучшая читабельность: Код становится более понятным и структурированным, что упрощает работу с большими стилевыми файлами. 3. Избежание дублирования: Вложенные правила позволяют избежать повторного написания общего селектора,сохраняя стильный код чистым и организованным.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "66da",
      "title": "Как работают миксины (mixins) в SASS и LESS, и для чего они используются?",
      "response": "Миксины (mixins) — это одна из ключевых функций препроцессоров CSS, таких как SASS и LESS, которые позволяют разработчикам создавать повторно используемые группы CSS-правил. Миксины помогают избегать дублирования кода, улучшая поддержку и организацию стилей. Давайте подробно рассмотрим, как работают миксины в SASS и LESS, а также их использование и преимущества. 1. Миксины в SASS Объявление миксина:В SASS миксин создается с помощью директивы @mixin, за которой следует имя миксина и его параметры (при необходимости).Использование миксина:Для применения миксина в стиле используется директива @include.Как работают миксины в LESS: Объявление миксина:Миксин объявляется с помощью имени с параметрами (при необходимости) и фигурных  скобок, в которых содержатся стили. Параметры могут быть опциональными и могут иметь значения по умолчанию.Использование миксина:Чтобы использовать миксин в другом селекторе, просто вызовите его имя как функцию,передав необходимые параметры в круглых скобках.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "37c9",
      "title": "Что такое функции и операции в SASS? Приведите примеры их использования.",
      "response": "Функции и операции в SASS являются мощными инструментами для выполнения вычислений и манипуляций с данными,что позволяет создавать более динамичные и гибкие стили . Давайте подробнее рассмотрим каждую из этих концепций и приведем примеры их использования.1. Функции в SASS Функции в SASS позволяют выполнять определенные манипуляции с данными и возвращать результат.SASS предоставляет множество встроенных функций для работы с цветами, математикой, строками и другими типами данных.Кроме того, разработчики могут создавать свои собственные функции.Примеры встроенных функций:- lighten: осветляет цвет.- darken: затемняет цвет.- multiply: умножает два значения.- round: округляет число.2. Операции в SASS Операции в SASS позволяют выполнять математические вычисления с числами и длинами.Например, вы можете складывать, вычитать, умножать и делить значения, что упрощает создание ыадаптивных и динамических дизайнов.Создание пользовательской функции Вы также можете создавать свои собственные функции в SASS для выполнения специфических задач. Для этого используется директива @function.Примеры операций:- Сложение (+) - Вычитание (-)- Умножение (*)- Деление (/)",
      "level": "Middle",
      "active": false
    },
    {
      "id": "4255",
      "title": "Объясните, что такое \"partials\" в SASS и как их можно использовать для организации кода.",
      "response": "Partials в SASS — это специальные Sass-файлы, которые предназначены для хранения частей стилей, которые можно импортировать в другие файлы SASS. Это позволяет организовать CSS-код,делая его более структурированным и легким в обслуживании. Используя partials, вы можете разбить ваш CSS на меньшие, управляемые файлы и избежать дублирования кода.Преимущества использования partials в SASS:1. Организация кода: Разделение стилей на логические блоки (например, для различных компонентов,страниц или секций), что упрощает навигацию и редактирование.2. Упрощение поддержки: Легче находить и менять стили, так как каждый файл отвечает за отдельный аспект или часть дизайна.3. Повторное использование: Вы можете импортировать одни и те же partials в нескольких файлах, что снижает дублирование кода.4. Лучшие рабочие практики: Меньшие файлы с ограниченным количеством кода легче тестировать,понимать и расширять.Как использовать partials:1. Создание partials:Назовите ваши partials с префиксом подчеркивания (_), чтобы обозначить, что это только часть  стилей, а не полный файл CSS. Например, вы можете создать следующие файлы:- _variables.scss (для хранения переменных) - _mixins.scss (для хранения миксинов) - _buttons.scss (для стилизации кнопок) - _header.scss (для стилизации заголовка) - _footer.scss (для стилизации подвала) 2. Импорт partials: Используя команду @import, вы можете подключить созданные partials в основном файле стилей.3. Сборка файла:После компиляции SASS в ваш основной файл (например, main.css), все стили из импортированных файлов будут собраны и скомпилированы в один CSS-файл.Использование partials в SASS позволяет организовать стили более структурированно и управляемо.Вы сможете легко поддерживать и развивать ваш проект, обращаясь к отдельным частям стилей, без излишнегодублирования кода. Разделение кода на partials соответствует принципам модульности и лучшим практикам разработки,что значительно улучшает процесс работы с CSS.",
      "level": "Senior",
      "active": false
    },
    {
      "id": "fd28",
      "title": "Как происходит компиляция файлов SASS или LESS в CSS? Какие инструменты вы можете использовать для этого?",
      "response": "Компиляция файлов SASS или LESS в CSS — это процесс преобразования стилей,написанных с использованием этих препроцессоров, в стандартный CSS, который браузеры могут интерпретировать. Этот процесс необходим, поскольку браузеры не поддерживают SASS или LESS напрямую,так как это расширенные синтаксисы для написания CSS.Как происходит компиляция 1. Написание стилей: Вы создаете файлы с помощью SASS (с расширением .scss или .sass) или LESS (с расширением .less).2. Запуск компилятора: Используя специальный инструмент или командную строку, вы запускаете компилятор, который обрабатывает ваш SASS или LESS код.3. Обработка файла: Компилятор считывает ваш файл, анализирует его, выполняет все определенные функции, операции, миксины и partials, и затем генерирует итоговый CSS-файл.4. Вывод: Скомпилированный CSS-файл сохраняется на диск и может быть подключен к HTML-документу.Инструменты для компиляции Существует несколько инструментов, которые можно использовать для компиляции SASS и LESS в CSS:1. CLI-компиляторы - SASS CLI: Официальный компилятор для SASS можно установить через npm или использовать предварительно собранные бинарники.npm install -g sass sass input.scss output.css - LESS CLI: Аналогичный подход можно использовать для LESS. npm install -g less less input.less output.css 2. Сборщики проектов - Webpack: С помощью плагинов, таких как sass-loader и less-loader, вы можете интегрировать SASS и LESS в сборку вашего проекта.npm install sass-loader css-loader style-loader --save-dev - Gulp: Это задача для автоматизации, которая позволяет писать задачи для компиляции SASS и LESS. Плагины gulp-sass и gulp-less могут помочь в этом.  npm install gulp gulp-sass gulp-less --save-dev - Grunt: Используйте плагины grunt-sass и grunt-contrib-less для компиляции SASS и LESS.npm install grunt-sass grunt-contrib-less --save-dev 3. Расширения и плагины для редакторов - Visual Studio Code: Существуют расширения, такие как Live Sass Compiler и Easy LESS, которые позволяют компилировать файлы в реальном времени.  - Atom и Sublime Text: Поддерживают плагины для SASS и LESS, которые позволяют  компилировать код непосредственно из редактора.4. Инструменты для разработки - CodeKit: Это приложение для macOS, которое автоматически компилирует файлов SASS и LESS при их изменении.- Prepros: Многофункциональный инструмент, которые позволяет компилировать SASS  и LESS (и другие препроцессоры) с поддержкой Live Reload.",
      "level": "Senior",
      "active": false
    },
    {
      "id": "e4b7",
      "title": "Что такое @import в SASS и LESS, и как он помогает в управлении файлами стилей?",
      "response": "Директива @import в SASS и LESS — это механизм, который позволяет импортировать и объединять файлы стилей, что существенно облегчает управление и организацию кода. Рассмотрим, как она работает в каждом из препроцессоров  и как помогает в управлении файлами стилей. 1. @import в SASS В SASS директива @import используется для включения одного SASS-файла в другой.Это позволяет разбить код на логические части и упрощает его организацию.SASS автоматически компилирует все импортированные файлы в один CSS-файл.2. @import в LESS В LESS также используется директива @import для объединения различных файлов. Подобно SASS, это позволяет структурировать код и облегчить его поддержку и расширение. Преимущества использования @import 1. Организация кода: Использование @import позволяет разбить код на логические части, что делает его более понятным и структурированным.2. Управление зависимостями: Импортируя файлы с переменными, миксинами и стилями,вы можете легко управлять зависимостями между различными частями кода.3. Переиспользование кода: Миксины и переменные могут быть определены в одном файле и использованы в других,что снижает дублирование кода.4. Удобство работы: Поддерживать и обновлять стили становится проще благодаря отделению различных компонентов друг от друга. 5. Компиляция в CSS: При компиляции все имена и стили объединяются в один CSS-файл, что упрощает подключение стилей на веб-странице.",
      "level": "Middle",
      "active": false
    }
  ],
  "git": [
    {
      "id": "968a",
      "title": "Основные понятия Git",
      "response": "1. Репозиторий (repository): Это основное хранилище для вашего проекта, где хранится вся история изменений.2. Коммит (commit): Это сохранение изменений в репозитории. Каждый коммит содержит сообщение о том, что было изменено.3. Ветка (branch): Это параллельная линия разработки, позволяющая работать над новыми функциями или исправлениями без влияния на основную ветку.4. Слияние (merge): Это процесс объединения изменений из одной ветки в другую.5. Конфликты (conflicts): Возникают, когда изменения в двух ветках конфликтуют, и Git не может автоматически объединить их.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "13aa",
      "title": "Основные команды Git",
      "response": "1. git init: Инициализация нового репозитория.2. git clone [url]: Клонирование существующего репозитория.3. git add [file]: Добавление файлов к индексации (подготовка к коммиту).4. git commit -m \"message\": Сохранение изменений с сообщением.5. git status: Проверка статуса файлов в репозитории.6. git log: Просмотр истории коммитов.7. git branch: Просмотр существующих веток.8. git checkout [branch]: Переключение на другую ветку.9. git merge [branch]: Слияние указанной ветки с текущей.10. git pull: Получение последних изменений из удалённого репозитория и автоматическое слияние.11. git push: Отправка коммитов на удалённый репозиторий.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "ab6a",
      "title": "Git hookss",
      "response": "Git hooks — это специальные скрипты, которые выполняются автоматически при выполнении определённых действий с репозиторием Git. Они позволяют настраивать процессы автоматизации и улучшать рабочий процесс разработки. Git поддерживает хуки для различных событий, таких как коммиты, слияния, и отправка данных в удалённый репозиторий. Эти хуки написаны в языке сценариев,таком как Bash, и могут быть настроены в зависимости от ваших нужд.Основные виды хуков 1. pre-commit: Выполняется перед созданием коммита. Используется для проверки кода на ошибки,форматирования, запуска тестов и т.д. Если скрипт завершится с ненулевым кодом, коммит не будет выполнен.2. prepare-commit-msg: Запускается перед открытием редактора для ввода сообщения коммита.Используется для изменения или дополнения стандартного сообщения о коммите.3. commit-msg: Выполняется после того, как сообщение коммита было введено, но перед его сохранением. Полезно для проверки формата сообщения коммита.4. post-commit: Выполняется после завершения коммита. Может использоваться для уведомлений,запуска сборки или других задач, которые должны выполняться после коммита.5. pre-push: Выполняется перед отправкой данных в удалённый репозиторий. Этот хук может использоваться для проверки, что все тесты проходят, прежде чем выполнить git push.6. post-merge: Выполняется после успешного слияния веток. Может использоваться для выполнения дополнительных действий, таких как установка зависимостей или очистка.7. pre-receive, update, post-receive: Эти хуки выполняются на стороне сервера при получении изменений от клиента. Используются для проверки входящих изменений, обеспечения соблюдения политик разработки и т.д.\nКак настроить хуки 1. Путь к хукам: Хуки располагаются в директории вашего Git-репозитория по пути .git/hooks/.По умолчанию в этой директории находятся примеры хуков с расширением .sample, которые можно использовать как шаблоны.2. Создание хука: Чтобы создать хук, просто переименуйте файл, удалив расширение .sample и добавьте ваш код. Например, для создания хуку pre-commit создайте файл с именем pre-commit в директории .git/hooks/.3.После создания хуков не забудьте сделать файл исполняемым, выполнив команду +x .git/hooks/pre-commit Примеры применения хуков - Автоматическое форматирование кода с использованием линтеров. - Запуск тестов перед коммитом или отправкой изменений. - Обработка и проверка сообщений коммита на соответствие стандартам.- Уведомление разработчиков через электронную почту о завершении коммитов или слияний.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "cdc8",
      "title": " Рабочие пространства (Worktrees)",
      "response": "Рабочие пространства (Worktrees) в Git \nпозволяют вам создавать несколько рабочих каталогов для одного\n     репозитория, что позволяет одновременно работать над несколькими ветками         без необходимости переключения между ними. Это особенно полезно для разработчиков, \n        которые хотят разрабатывать или тестировать разные изменения в отдельных ветках одновременно.\n        Основные преимущества Worktrees\n        1. Одновременная работа с несколькими ветками: Вы можете иметь активные копии различных веток в разных каталогах, что позволяет вам работать над несколькими задачами одновременно.2. Изолированное окружение: Каждое рабочее пространство является количеством независимым,что помогает избежать конфликтов и путаницы между изменениями и состояниями веток.\n       3. Упрощение тестирования и деплоя: Рабочие пространства позволяют легко протестировать изменения в одной ветке, не затрагивая другие ветки и не переключаясь между ними.\n        Основные команды для работы с Worktrees 1. Создание нового рабочего пространства:Чтобы создать новое рабочее пространство на основе существующей ветки, используйте команду:git worktree add (путь_к_новому_рабочему_каталогу) (ветка) Эта команда создаст новое рабочее пространство в каталоге ../new-feature-branch на основе ветки feature-branch.2. Просмотр существующих рабочих пространств:Для просмотра всех рабочих пространств в вашем репозитории выполните команду:git worktree list 3. Удаление рабочего пространства:Если вам больше не нужно рабочее пространство, вы можете удалить его с помощью команды:git worktree remove (путь_к_рабочему_каталогу) Обратите внимание, что для успешного удаления рабочего пространства необходимо, чтобы оно было пустым (т.е. в нём не должно быть несохранённых изменений).4. Переключение между рабочими пространствами:После создания рабочего пространства вы можете просто перейти в его каталог и работать, как если бы вы находились в обычном репозитории.Примеры применения Worktrees - Работа над несколькими функциональностями: Если у вас есть несколько функциональностей, которые вы хотите разработать одновременно, вы можете создать отдельные рабочие пространства для каждой из них.- Проверка состояния ветки: Вы можете тестировать изменения в одной ветке, не боясь привести в замешательство незафиксированные изменения в текущей ветке.- Облегчение командной работы: Когда несколько разработчиков работают над проектом, каждый из них может создать своё рабочее пространство для своей задачи, что облегчает совместную работу.",
      "level": "Middle",
      "active": false
    },
    {
      "id": "e3ac",
      "title": "Отмена изменений",
      "response": "Git предоставляет несколько способов отмены изменений:git checkout, git revert и git reset. Это позволяет разработчикам гибко обрабатывать различные ошибки или откатывать изменения.",
      "level": "Junior",
      "active": false
    },
    {
      "id": "95e7",
      "title": "daswqeerfqwer",
      "response": "asd",
      "level": "Junior",
      "active": false
    },
    {
      "id": "3c28",
      "title": "фы",
      "response": "асмясчм",
      "level": "Junior",
      "active": false
    },
    {
      "id": "a77e",
      "title": " asd",
      "response": " d",
      "level": "Junior",
      "active": false
    },
    {
      "id": "aeff",
      "title": "фыв",
      "response": "вввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввв",
      "level": "Junior",
      "active": false
    },
    {
      "id": "0b5c",
      "title": "asdasd",
      "response": "ddddddasdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd",
      "level": "Junior",
      "active": true
    },
    {
      "id": "7685",
      "title": "йцуйцу",
      "response": "фыцввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввв",
      "level": "Junior",
      "active": false
    },
    {
      "id": "d250",
      "title": "цйуцу",
      "response": "вввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввввв\n",
      "level": "Junior",
      "active": false
    },
    {
      "id": "a75e",
      "title": "edsadasdasd",
      "response": "edsadasdasd dsdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasdedsadasdasd\n",
      "level": "Junior",
      "active": false
    }
  ]
}